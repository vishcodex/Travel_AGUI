{"version":3,"sources":["../src/apply/default.ts","../src/utils.ts","../src/agent/subscriber.ts","../src/verify/verify.ts","../src/transform/http.ts","../src/run/http-request.ts","../src/transform/sse.ts","../src/transform/proto.ts","../src/legacy/convert.ts","../src/legacy/types.ts","../src/agent/agent.ts","../src/chunks/transform.ts","../src/agent/http.ts","../src/index.ts"],"sourcesContent":["import {\n  EventType,\n  TextMessageStartEvent,\n  TextMessageContentEvent,\n  Message,\n  ToolCallStartEvent,\n  ToolCallArgsEvent,\n  StateSnapshotEvent,\n  StateDeltaEvent,\n  MessagesSnapshotEvent,\n  CustomEvent,\n  BaseEvent,\n  AssistantMessage,\n  ToolCallResultEvent,\n  ToolMessage,\n  RunAgentInput,\n  TextMessageEndEvent,\n  ToolCallEndEvent,\n  RawEvent,\n  RunStartedEvent,\n  RunFinishedEvent,\n  RunErrorEvent,\n  StepStartedEvent,\n  StepFinishedEvent,\n} from \"@ag-ui/core\";\nimport { mergeMap, mergeAll, defaultIfEmpty, concatMap } from \"rxjs/operators\";\nimport { of, EMPTY } from \"rxjs\";\nimport { structuredClone_ } from \"../utils\";\nimport { applyPatch } from \"fast-json-patch\";\nimport {\n  AgentStateMutation,\n  AgentSubscriber,\n  runSubscribersWithMutation,\n} from \"@/agent/subscriber\";\nimport { Observable } from \"rxjs\";\nimport { AbstractAgent } from \"@/agent/agent\";\nimport untruncateJson from \"untruncate-json\";\n\nexport const defaultApplyEvents = (\n  input: RunAgentInput,\n  events$: Observable<BaseEvent>,\n  agent: AbstractAgent,\n  subscribers: AgentSubscriber[],\n): Observable<AgentStateMutation> => {\n  let messages = structuredClone_(input.messages);\n  let state = structuredClone_(input.state);\n  let currentMutation: AgentStateMutation = {};\n\n  const applyMutation = (mutation: AgentStateMutation) => {\n    if (mutation.messages !== undefined) {\n      messages = mutation.messages;\n      currentMutation.messages = mutation.messages;\n    }\n    if (mutation.state !== undefined) {\n      state = mutation.state;\n      currentMutation.state = mutation.state;\n    }\n  };\n\n  const emitUpdates = () => {\n    const result = structuredClone_(currentMutation) as AgentStateMutation;\n    currentMutation = {};\n    if (result.messages !== undefined || result.state !== undefined) {\n      return of(result);\n    }\n    return EMPTY;\n  };\n\n  return events$.pipe(\n    concatMap(async (event) => {\n      const mutation = await runSubscribersWithMutation(\n        subscribers,\n        messages,\n        state,\n        (subscriber, messages, state) =>\n          subscriber.onEvent?.({ event, agent, input, messages, state }),\n      );\n      applyMutation(mutation);\n\n      if (mutation.stopPropagation === true) {\n        return emitUpdates();\n      }\n\n      switch (event.type) {\n        case EventType.TEXT_MESSAGE_START: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onTextMessageStartEvent?.({\n                event: event as TextMessageStartEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { messageId, role } = event as TextMessageStartEvent;\n\n            // Create a new message using properties from the event\n            const newMessage: Message = {\n              id: messageId,\n              role: role,\n              content: \"\",\n            };\n\n            // Add the new message to the messages array\n            messages.push(newMessage);\n            applyMutation({ messages });\n          }\n          return emitUpdates();\n        }\n\n        case EventType.TEXT_MESSAGE_CONTENT: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onTextMessageContentEvent?.({\n                event: event as TextMessageContentEvent,\n                messages,\n                state,\n                agent,\n                input,\n                textMessageBuffer: messages[messages.length - 1].content ?? \"\",\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { delta } = event as TextMessageContentEvent;\n\n            // Get the last message and append the content\n            const lastMessage = messages[messages.length - 1];\n            lastMessage.content = lastMessage.content! + delta;\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.TEXT_MESSAGE_END: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onTextMessageEndEvent?.({\n                event: event as TextMessageEndEvent,\n                messages,\n                state,\n                agent,\n                input,\n                textMessageBuffer: messages[messages.length - 1].content ?? \"\",\n              }),\n          );\n          applyMutation(mutation);\n\n          await Promise.all(\n            subscribers.map((subscriber) => {\n              subscriber.onNewMessage?.({\n                message: messages[messages.length - 1],\n                messages,\n                state,\n                agent,\n                input,\n              });\n            }),\n          );\n\n          return emitUpdates();\n        }\n\n        case EventType.TOOL_CALL_START: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onToolCallStartEvent?.({\n                event: event as ToolCallStartEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { toolCallId, toolCallName, parentMessageId } = event as ToolCallStartEvent;\n\n            let targetMessage: AssistantMessage;\n\n            // Use last message if parentMessageId exists, we have messages, and the parentMessageId matches the last message's id\n            if (\n              parentMessageId &&\n              messages.length > 0 &&\n              messages[messages.length - 1].id === parentMessageId\n            ) {\n              targetMessage = messages[messages.length - 1] as AssistantMessage;\n            } else {\n              // Create a new message otherwise\n              targetMessage = {\n                id: parentMessageId || toolCallId,\n                role: \"assistant\",\n                toolCalls: [],\n              };\n              messages.push(targetMessage);\n            }\n\n            targetMessage.toolCalls ??= [];\n\n            // Add the new tool call\n            targetMessage.toolCalls.push({\n              id: toolCallId,\n              type: \"function\",\n              function: {\n                name: toolCallName,\n                arguments: \"\",\n              },\n            });\n\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.TOOL_CALL_ARGS: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) => {\n              const toolCalls =\n                (messages[messages.length - 1] as AssistantMessage)?.toolCalls ?? [];\n              const toolCallBuffer =\n                toolCalls.length > 0 ? toolCalls[toolCalls.length - 1].function.arguments : \"\";\n              const toolCallName =\n                toolCalls.length > 0 ? toolCalls[toolCalls.length - 1].function.name : \"\";\n              let partialToolCallArgs = {};\n              try {\n                // Parse from toolCallBuffer only (before current delta is applied)\n                partialToolCallArgs = untruncateJson(toolCallBuffer);\n              } catch (error) {}\n\n              return subscriber.onToolCallArgsEvent?.({\n                event: event as ToolCallArgsEvent,\n                messages,\n                state,\n                agent,\n                input,\n                toolCallBuffer,\n                toolCallName,\n                partialToolCallArgs,\n              });\n            },\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { delta } = event as ToolCallArgsEvent;\n\n            // Get the last message\n            const lastMessage = messages[messages.length - 1] as AssistantMessage;\n\n            // Get the last tool call\n            const lastToolCall = lastMessage.toolCalls![lastMessage.toolCalls!.length - 1];\n\n            // Append the arguments\n            lastToolCall.function.arguments += delta;\n\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.TOOL_CALL_END: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) => {\n              const toolCalls =\n                (messages[messages.length - 1] as AssistantMessage)?.toolCalls ?? [];\n              const toolCallArgsString =\n                toolCalls.length > 0 ? toolCalls[toolCalls.length - 1].function.arguments : \"\";\n              const toolCallName =\n                toolCalls.length > 0 ? toolCalls[toolCalls.length - 1].function.name : \"\";\n              let toolCallArgs = {};\n              try {\n                toolCallArgs = JSON.parse(toolCallArgsString);\n              } catch (error) {}\n              return subscriber.onToolCallEndEvent?.({\n                event: event as ToolCallEndEvent,\n                messages,\n                state,\n                agent,\n                input,\n                toolCallName,\n                toolCallArgs,\n              });\n            },\n          );\n          applyMutation(mutation);\n\n          await Promise.all(\n            subscribers.map((subscriber) => {\n              subscriber.onNewToolCall?.({\n                toolCall: (messages[messages.length - 1] as AssistantMessage).toolCalls![\n                  (messages[messages.length - 1] as AssistantMessage).toolCalls!.length - 1\n                ],\n                messages,\n                state,\n                agent,\n                input,\n              });\n            }),\n          );\n\n          return emitUpdates();\n        }\n\n        case EventType.TOOL_CALL_RESULT: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onToolCallResultEvent?.({\n                event: event as ToolCallResultEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { messageId, toolCallId, content, role } = event as ToolCallResultEvent;\n\n            const toolMessage: ToolMessage = {\n              id: messageId,\n              toolCallId,\n              role: role || \"tool\",\n              content: content,\n            };\n\n            messages.push(toolMessage);\n\n            await Promise.all(\n              subscribers.map((subscriber) => {\n                subscriber.onNewMessage?.({\n                  message: toolMessage,\n                  messages,\n                  state,\n                  agent,\n                  input,\n                });\n              }),\n            );\n\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.STATE_SNAPSHOT: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onStateSnapshotEvent?.({\n                event: event as StateSnapshotEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { snapshot } = event as StateSnapshotEvent;\n\n            // Replace state with the literal snapshot\n            state = snapshot;\n\n            applyMutation({ state });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.STATE_DELTA: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onStateDeltaEvent?.({\n                event: event as StateDeltaEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { delta } = event as StateDeltaEvent;\n\n            try {\n              // Apply the JSON Patch operations to the current state without mutating the original\n              const result = applyPatch(state, delta, true, false);\n              state = result.newDocument;\n              applyMutation({ state });\n            } catch (error: unknown) {\n              const errorMessage = error instanceof Error ? error.message : String(error);\n              console.warn(\n                `Failed to apply state patch:\\n` +\n                  `Current state: ${JSON.stringify(state, null, 2)}\\n` +\n                  `Patch operations: ${JSON.stringify(delta, null, 2)}\\n` +\n                  `Error: ${errorMessage}`,\n              );\n              // If patch failed, only emit updates if there were subscriber mutations\n              // This prevents emitting updates when both patch fails AND no subscriber mutations\n            }\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.MESSAGES_SNAPSHOT: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onMessagesSnapshotEvent?.({\n                event: event as MessagesSnapshotEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { messages: newMessages } = event as MessagesSnapshotEvent;\n\n            // Replace messages with the snapshot\n            messages = newMessages;\n\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.RAW: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onRawEvent?.({\n                event: event as RawEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.CUSTOM: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onCustomEvent?.({\n                event: event as CustomEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.RUN_STARTED: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onRunStartedEvent?.({\n                event: event as RunStartedEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.RUN_FINISHED: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onRunFinishedEvent?.({\n                event: event as RunFinishedEvent,\n                messages,\n                state,\n                agent,\n                input,\n                result: (event as RunFinishedEvent).result,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.RUN_ERROR: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onRunErrorEvent?.({\n                event: event as RunErrorEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.STEP_STARTED: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onStepStartedEvent?.({\n                event: event as StepStartedEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.STEP_FINISHED: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onStepFinishedEvent?.({\n                event: event as StepFinishedEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.TEXT_MESSAGE_CHUNK: {\n          throw new Error(\"TEXT_MESSAGE_CHUNK must be tranformed before being applied\");\n        }\n\n        case EventType.TOOL_CALL_CHUNK: {\n          throw new Error(\"TOOL_CALL_CHUNK must be tranformed before being applied\");\n        }\n\n        case EventType.THINKING_START: {\n          return emitUpdates();\n        }\n\n        case EventType.THINKING_END: {\n          return emitUpdates();\n        }\n\n        case EventType.THINKING_TEXT_MESSAGE_START: {\n          return emitUpdates();\n        }\n\n        case EventType.THINKING_TEXT_MESSAGE_CONTENT: {\n          return emitUpdates();\n        }\n\n        case EventType.THINKING_TEXT_MESSAGE_END: {\n          return emitUpdates();\n        }\n      }\n\n      // This makes TypeScript check that the switch is exhaustive\n      // If a new EventType is added, this will cause a compile error\n      const _exhaustiveCheck: never = event.type;\n      return emitUpdates();\n    }),\n    mergeAll(),\n    // Only use defaultIfEmpty when there are subscribers to avoid emitting empty updates\n    // when patches fail and there are no subscribers (like in state patching test)\n    subscribers.length > 0 ? defaultIfEmpty({} as AgentStateMutation) : (stream: any) => stream,\n  );\n};\n","export const structuredClone_ = <T>(obj: T): T => {\n  if (typeof structuredClone === \"function\") {\n    return structuredClone(obj);\n  }\n\n  try {\n    return JSON.parse(JSON.stringify(obj));\n  } catch (err) {\n    return { ...obj } as T;\n  }\n};\n","import {\n  BaseEvent,\n  Message,\n  RunAgentInput,\n  RunErrorEvent,\n  RunFinishedEvent,\n  RunStartedEvent,\n  State,\n  StateDeltaEvent,\n  StateSnapshotEvent,\n  StepFinishedEvent,\n  StepStartedEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  TextMessageStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n  ToolCallResultEvent,\n  ToolCallStartEvent,\n  MessagesSnapshotEvent,\n  RawEvent,\n  CustomEvent,\n  ToolCall,\n} from \"@ag-ui/core\";\nimport { AbstractAgent } from \"./agent\";\nimport { structuredClone_ } from \"@/utils\";\n\nexport interface AgentStateMutation {\n  messages?: Message[];\n  state?: State;\n  stopPropagation?: boolean;\n}\n\nexport interface AgentSubscriberParams {\n  messages: Message[];\n  state: State;\n  agent: AbstractAgent;\n  input: RunAgentInput;\n}\n\n// Utility type to allow callbacks to be implemented either synchronously or asynchronously.\nexport type MaybePromise<T> = T | Promise<T>;\n\nexport interface AgentSubscriber {\n  // Request lifecycle\n  onRunInitialized?(\n    params: AgentSubscriberParams,\n  ): MaybePromise<Omit<AgentStateMutation, \"stopPropagation\"> | void>;\n  onRunFailed?(\n    params: { error: Error } & AgentSubscriberParams,\n  ): MaybePromise<Omit<AgentStateMutation, \"stopPropagation\"> | void>;\n  onRunFinalized?(\n    params: AgentSubscriberParams,\n  ): MaybePromise<Omit<AgentStateMutation, \"stopPropagation\"> | void>;\n\n  // Events\n  onEvent?(\n    params: { event: BaseEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onRunStartedEvent?(\n    params: { event: RunStartedEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onRunFinishedEvent?(\n    params: { event: RunFinishedEvent; result?: any } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onRunErrorEvent?(\n    params: { event: RunErrorEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onStepStartedEvent?(\n    params: { event: StepStartedEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onStepFinishedEvent?(\n    params: { event: StepFinishedEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onTextMessageStartEvent?(\n    params: { event: TextMessageStartEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onTextMessageContentEvent?(\n    params: {\n      event: TextMessageContentEvent;\n      textMessageBuffer: string;\n    } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onTextMessageEndEvent?(\n    params: { event: TextMessageEndEvent; textMessageBuffer: string } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onToolCallStartEvent?(\n    params: { event: ToolCallStartEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onToolCallArgsEvent?(\n    params: {\n      event: ToolCallArgsEvent;\n      toolCallBuffer: string;\n      toolCallName: string;\n      partialToolCallArgs: Record<string, any>;\n    } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onToolCallEndEvent?(\n    params: {\n      event: ToolCallEndEvent;\n      toolCallName: string;\n      toolCallArgs: Record<string, any>;\n    } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onToolCallResultEvent?(\n    params: { event: ToolCallResultEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onStateSnapshotEvent?(\n    params: { event: StateSnapshotEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onStateDeltaEvent?(\n    params: { event: StateDeltaEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onMessagesSnapshotEvent?(\n    params: { event: MessagesSnapshotEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onRawEvent?(\n    params: { event: RawEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onCustomEvent?(\n    params: { event: CustomEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  // State changes\n  onMessagesChanged?(\n    params: Omit<AgentSubscriberParams, \"input\"> & { input?: RunAgentInput },\n  ): MaybePromise<void>;\n  onStateChanged?(\n    params: Omit<AgentSubscriberParams, \"input\"> & { input?: RunAgentInput },\n  ): MaybePromise<void>;\n  onNewMessage?(\n    params: { message: Message } & Omit<AgentSubscriberParams, \"input\"> & {\n        input?: RunAgentInput;\n      },\n  ): MaybePromise<void>;\n  onNewToolCall?(\n    params: { toolCall: ToolCall } & Omit<AgentSubscriberParams, \"input\"> & {\n        input?: RunAgentInput;\n      },\n  ): MaybePromise<void>;\n}\n\nexport async function runSubscribersWithMutation(\n  subscribers: AgentSubscriber[],\n  initialMessages: Message[],\n  initialState: State,\n  executor: (\n    subscriber: AgentSubscriber,\n    messages: Message[],\n    state: State,\n  ) => MaybePromise<AgentStateMutation | void>,\n): Promise<AgentStateMutation> {\n  let messages: Message[] = initialMessages;\n  let state: State = initialState;\n\n  let stopPropagation: boolean | undefined = undefined;\n\n  for (const subscriber of subscribers) {\n    try {\n      const mutation = await executor(\n        subscriber,\n        structuredClone_(messages),\n        structuredClone_(state),\n      );\n\n      if (mutation === undefined) {\n        // Nothing returned â€“ keep going\n        continue;\n      }\n\n      // Merge messages/state so next subscriber sees latest view\n      if (mutation.messages !== undefined) {\n        messages = mutation.messages;\n      }\n\n      if (mutation.state !== undefined) {\n        state = mutation.state;\n      }\n\n      stopPropagation = mutation.stopPropagation;\n\n      if (stopPropagation === true) {\n        break;\n      }\n    } catch (error) {\n      // Log subscriber errors but continue processing (silence during tests)\n      const isTestEnvironment =\n        process.env.NODE_ENV === \"test\" || process.env.JEST_WORKER_ID !== undefined;\n\n      if (!isTestEnvironment) {\n        console.error(\"Subscriber error:\", error);\n      }\n      // Continue to next subscriber unless we want to stop propagation\n      continue;\n    }\n  }\n\n  return {\n    ...(JSON.stringify(messages) !== JSON.stringify(initialMessages) ? { messages } : {}),\n    ...(JSON.stringify(state) !== JSON.stringify(initialState) ? { state } : {}),\n    ...(stopPropagation !== undefined ? { stopPropagation } : {}),\n  };\n}\n","import { BaseEvent, EventType, AGUIError } from \"@ag-ui/core\";\nimport { Observable, throwError, of } from \"rxjs\";\nimport { mergeMap } from \"rxjs/operators\";\n\nexport const verifyEvents =\n  (debug: boolean) =>\n  (source$: Observable<BaseEvent>): Observable<BaseEvent> => {\n    // Declare variables in closure to maintain state across events\n    let activeMessageId: string | undefined;\n    let activeToolCallId: string | undefined;\n    let runFinished = false;\n    let runError = false; // New flag to track if RUN_ERROR has been sent\n    // New flags to track first/last event requirements\n    let firstEventReceived = false;\n    // Track active steps\n    let activeSteps = new Map<string, boolean>(); // Map of step name -> active status\n    let activeThinkingStep = false;\n    let activeThinkingStepMessage = false;\n\n    return source$.pipe(\n      // Process each event through our state machine\n      mergeMap((event) => {\n        const eventType = event.type;\n\n        if (debug) {\n          console.debug(\"[VERIFY]:\", JSON.stringify(event));\n        }\n\n        // Check if run has errored\n        if (runError) {\n          return throwError(\n            () =>\n              new AGUIError(\n                `Cannot send event type '${eventType}': The run has already errored with 'RUN_ERROR'. No further events can be sent.`,\n              ),\n          );\n        }\n\n        // Check if run has already finished\n        if (runFinished && eventType !== EventType.RUN_ERROR) {\n          return throwError(\n            () =>\n              new AGUIError(\n                `Cannot send event type '${eventType}': The run has already finished with 'RUN_FINISHED'. Start a new run with 'RUN_STARTED'.`,\n              ),\n          );\n        }\n\n        // Forbid lifecycle events and tool events inside a text message\n        if (activeMessageId !== undefined) {\n          // Define allowed event types inside a text message\n          const allowedEventTypes = [\n            EventType.TEXT_MESSAGE_CONTENT,\n            EventType.TEXT_MESSAGE_END,\n            EventType.RAW,\n          ];\n\n          // If the event type is not in the allowed list, throw an error\n          if (!allowedEventTypes.includes(eventType)) {\n            return throwError(\n              () =>\n                new AGUIError(\n                  `Cannot send event type '${eventType}' after 'TEXT_MESSAGE_START': Send 'TEXT_MESSAGE_END' first.`,\n                ),\n            );\n          }\n        }\n\n        // Forbid lifecycle events and text message events inside a tool call\n        if (activeToolCallId !== undefined) {\n          // Define allowed event types inside a tool call\n          const allowedEventTypes = [\n            EventType.TOOL_CALL_ARGS,\n            EventType.TOOL_CALL_END,\n            EventType.RAW,\n          ];\n\n          // If the event type is not in the allowed list, throw an error\n          if (!allowedEventTypes.includes(eventType)) {\n            // Special handling for nested tool calls for better error message\n            if (eventType === EventType.TOOL_CALL_START) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TOOL_CALL_START' event: A tool call is already in progress. Complete it with 'TOOL_CALL_END' first.`,\n                  ),\n              );\n            }\n\n            return throwError(\n              () =>\n                new AGUIError(\n                  `Cannot send event type '${eventType}' after 'TOOL_CALL_START': Send 'TOOL_CALL_END' first.`,\n                ),\n            );\n          }\n        }\n\n        // Handle first event requirement and prevent multiple RUN_STARTED\n        if (!firstEventReceived) {\n          firstEventReceived = true;\n          if (eventType !== EventType.RUN_STARTED && eventType !== EventType.RUN_ERROR) {\n            return throwError(() => new AGUIError(`First event must be 'RUN_STARTED'`));\n          }\n        } else if (eventType === EventType.RUN_STARTED) {\n          // Prevent multiple RUN_STARTED events\n          return throwError(\n            () =>\n              new AGUIError(\n                `Cannot send multiple 'RUN_STARTED' events: A 'RUN_STARTED' event was already sent. Each run must have exactly one 'RUN_STARTED' event at the beginning.`,\n              ),\n          );\n        }\n\n        // Validate event based on type and current state\n        switch (eventType) {\n          // Text message flow\n          case EventType.TEXT_MESSAGE_START: {\n            // Can't start a message if one is already in progress\n            if (activeMessageId !== undefined) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TEXT_MESSAGE_START' event: A text message is already in progress. Complete it with 'TEXT_MESSAGE_END' first.`,\n                  ),\n              );\n            }\n\n            activeMessageId = (event as any).messageId;\n            return of(event);\n          }\n\n          case EventType.TEXT_MESSAGE_CONTENT: {\n            // Must be in a message and IDs must match\n            if (activeMessageId === undefined) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TEXT_MESSAGE_CONTENT' event: No active text message found. Start a text message with 'TEXT_MESSAGE_START' first.`,\n                  ),\n              );\n            }\n\n            if ((event as any).messageId !== activeMessageId) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TEXT_MESSAGE_CONTENT' event: Message ID mismatch. The ID '${(event as any).messageId}' doesn't match the active message ID '${activeMessageId}'.`,\n                  ),\n              );\n            }\n\n            return of(event);\n          }\n\n          case EventType.TEXT_MESSAGE_END: {\n            // Must be in a message and IDs must match\n            if (activeMessageId === undefined) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TEXT_MESSAGE_END' event: No active text message found. A 'TEXT_MESSAGE_START' event must be sent first.`,\n                  ),\n              );\n            }\n\n            if ((event as any).messageId !== activeMessageId) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TEXT_MESSAGE_END' event: Message ID mismatch. The ID '${(event as any).messageId}' doesn't match the active message ID '${activeMessageId}'.`,\n                  ),\n              );\n            }\n\n            // Reset message state\n            activeMessageId = undefined;\n            return of(event);\n          }\n\n          // Tool call flow\n          case EventType.TOOL_CALL_START: {\n            // Can't start a tool call if one is already in progress\n            if (activeToolCallId !== undefined) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TOOL_CALL_START' event: A tool call is already in progress. Complete it with 'TOOL_CALL_END' first.`,\n                  ),\n              );\n            }\n\n            activeToolCallId = (event as any).toolCallId;\n            return of(event);\n          }\n\n          case EventType.TOOL_CALL_ARGS: {\n            // Must be in a tool call and IDs must match\n            if (activeToolCallId === undefined) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TOOL_CALL_ARGS' event: No active tool call found. Start a tool call with 'TOOL_CALL_START' first.`,\n                  ),\n              );\n            }\n\n            if ((event as any).toolCallId !== activeToolCallId) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TOOL_CALL_ARGS' event: Tool call ID mismatch. The ID '${(event as any).toolCallId}' doesn't match the active tool call ID '${activeToolCallId}'.`,\n                  ),\n              );\n            }\n\n            return of(event);\n          }\n\n          case EventType.TOOL_CALL_END: {\n            // Must be in a tool call and IDs must match\n            if (activeToolCallId === undefined) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TOOL_CALL_END' event: No active tool call found. A 'TOOL_CALL_START' event must be sent first.`,\n                  ),\n              );\n            }\n\n            if ((event as any).toolCallId !== activeToolCallId) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TOOL_CALL_END' event: Tool call ID mismatch. The ID '${(event as any).toolCallId}' doesn't match the active tool call ID '${activeToolCallId}'.`,\n                  ),\n              );\n            }\n\n            // Reset tool call state\n            activeToolCallId = undefined;\n            return of(event);\n          }\n\n          // Step flow\n          case EventType.STEP_STARTED: {\n            const stepName = (event as any).stepName;\n            if (activeSteps.has(stepName)) {\n              return throwError(\n                () => new AGUIError(`Step \"${stepName}\" is already active for 'STEP_STARTED'`),\n              );\n            }\n            activeSteps.set(stepName, true);\n            return of(event);\n          }\n\n          case EventType.STEP_FINISHED: {\n            const stepName = (event as any).stepName;\n            if (!activeSteps.has(stepName)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'STEP_FINISHED' for step \"${stepName}\" that was not started`,\n                  ),\n              );\n            }\n            activeSteps.delete(stepName);\n            return of(event);\n          }\n\n          // Run flow\n          case EventType.RUN_STARTED: {\n            // We've already validated this above\n            return of(event);\n          }\n\n          case EventType.RUN_FINISHED: {\n            // Can't be the first event (already checked)\n            // and can't happen after already being finished (already checked)\n\n            // Check that all steps are finished before run ends\n            if (activeSteps.size > 0) {\n              const unfinishedSteps = Array.from(activeSteps.keys()).join(\", \");\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'RUN_FINISHED' while steps are still active: ${unfinishedSteps}`,\n                  ),\n              );\n            }\n\n            runFinished = true;\n            return of(event);\n          }\n\n          case EventType.RUN_ERROR: {\n            // RUN_ERROR can happen at any time\n            runError = true; // Set flag to prevent any further events\n            return of(event);\n          }\n\n          case EventType.CUSTOM: {\n            return of(event);\n          }\n\n          // Text message flow\n          case EventType.THINKING_TEXT_MESSAGE_START: {\n            if (!activeThinkingStep) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_TEXT_MESSAGE_START' event: A thinking step is not in progress. Create one with 'THINKING_START' first.`,\n                  ),\n              );\n            }\n            // Can't start a message if one is already in progress\n            if (activeThinkingStepMessage) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_TEXT_MESSAGE_START' event: A thinking message is already in progress. Complete it with 'THINKING_TEXT_MESSAGE_END' first.`,\n                  ),\n              );\n            }\n\n            activeThinkingStepMessage = true;\n            return of(event);\n          }\n\n          case EventType.THINKING_TEXT_MESSAGE_CONTENT: {\n            // Must be in a message and IDs must match\n            if (!activeThinkingStepMessage) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_TEXT_MESSAGE_CONTENT' event: No active thinking message found. Start a message with 'THINKING_TEXT_MESSAGE_START' first.`,\n                  ),\n              );\n            }\n\n            return of(event);\n          }\n\n          case EventType.THINKING_TEXT_MESSAGE_END: {\n            // Must be in a message and IDs must match\n            if (!activeThinkingStepMessage) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_TEXT_MESSAGE_END' event: No active thinking message found. A 'THINKING_TEXT_MESSAGE_START' event must be sent first.`,\n                  ),\n              );\n            }\n\n            // Reset message state\n            activeThinkingStepMessage = false;\n            return of(event);\n          }\n\n          case EventType.THINKING_START: {\n            if (activeThinkingStep) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_START' event: A thinking step is already in progress. End it with 'THINKING_END' first.`,\n                  ),\n              );\n            }\n\n            activeThinkingStep = true;\n            return of(event);\n          }\n\n          case EventType.THINKING_END: {\n            // Must be in a message and IDs must match\n            if (!activeThinkingStep) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_END' event: No active thinking step found. A 'THINKING_START' event must be sent first.`,\n                  ),\n              );\n            }\n\n            // Reset message state\n            activeThinkingStep = false;\n            return of(event);\n          }\n\n          default: {\n            return of(event);\n          }\n        }\n      }),\n    );\n  };\n","import { BaseEvent, EventSchemas } from \"@ag-ui/core\";\nimport { Subject, ReplaySubject, Observable } from \"rxjs\";\nimport { HttpEvent, HttpEventType } from \"../run/http-request\";\nimport { parseSSEStream } from \"./sse\";\nimport { parseProtoStream } from \"./proto\";\nimport * as proto from \"@ag-ui/proto\";\n\n/**\n * Transforms HTTP events into BaseEvents using the appropriate format parser based on content type.\n */\nexport const transformHttpEventStream = (source$: Observable<HttpEvent>): Observable<BaseEvent> => {\n  const eventSubject = new Subject<BaseEvent>();\n\n  // Use ReplaySubject to buffer events until we decide on the parser\n  const bufferSubject = new ReplaySubject<HttpEvent>();\n\n  // Flag to track whether we've set up the parser\n  let parserInitialized = false;\n\n  // Subscribe to source and buffer events while we determine the content type\n  source$.subscribe({\n    next: (event: HttpEvent) => {\n      // Forward event to buffer\n      bufferSubject.next(event);\n\n      // If we get headers and haven't initialized a parser yet, check content type\n      if (event.type === HttpEventType.HEADERS && !parserInitialized) {\n        parserInitialized = true;\n        const contentType = event.headers.get(\"content-type\");\n\n        // Choose parser based on content type\n        if (contentType === proto.AGUI_MEDIA_TYPE) {\n          // Use protocol buffer parser\n          parseProtoStream(bufferSubject).subscribe({\n            next: (event) => eventSubject.next(event),\n            error: (err) => eventSubject.error(err),\n            complete: () => eventSubject.complete(),\n          });\n        } else {\n          // Use SSE JSON parser for all other cases\n          parseSSEStream(bufferSubject).subscribe({\n            next: (json) => {\n              try {\n                const parsedEvent = EventSchemas.parse(json);\n                eventSubject.next(parsedEvent as BaseEvent);\n              } catch (err) {\n                eventSubject.error(err);\n              }\n            },\n            error: (err) => eventSubject.error(err),\n            complete: () => eventSubject.complete(),\n          });\n        }\n      } else if (!parserInitialized) {\n        eventSubject.error(new Error(\"No headers event received before data events\"));\n      }\n    },\n    error: (err) => {\n      bufferSubject.error(err);\n      eventSubject.error(err);\n    },\n    complete: () => {\n      bufferSubject.complete();\n    },\n  });\n\n  return eventSubject.asObservable();\n};\n","import { Observable, from, defer, throwError } from \"rxjs\";\nimport { switchMap } from \"rxjs/operators\";\n\nexport enum HttpEventType {\n  HEADERS = \"headers\",\n  DATA = \"data\",\n}\n\nexport interface HttpDataEvent {\n  type: HttpEventType.DATA;\n  data?: Uint8Array;\n}\n\nexport interface HttpHeadersEvent {\n  type: HttpEventType.HEADERS;\n  status: number;\n  headers: Headers;\n}\n\nexport type HttpEvent = HttpDataEvent | HttpHeadersEvent;\n\nexport const runHttpRequest = (url: string, requestInit: RequestInit): Observable<HttpEvent> => {\n  // Defer the fetch so that it's executed when subscribed to\n  return defer(() => from(fetch(url, requestInit))).pipe(\n    switchMap((response) => {\n      // Emit headers event first\n      const headersEvent: HttpHeadersEvent = {\n        type: HttpEventType.HEADERS,\n        status: response.status,\n        headers: response.headers,\n      };\n\n      const reader = response.body?.getReader();\n      if (!reader) {\n        return throwError(() => new Error(\"Failed to getReader() from response\"));\n      }\n\n      return new Observable<HttpEvent>((subscriber) => {\n        // Emit headers event first\n        subscriber.next(headersEvent);\n\n        (async () => {\n          try {\n            while (true) {\n              const { done, value } = await reader.read();\n              if (done) break;\n              // Emit data event instead of raw Uint8Array\n              const dataEvent: HttpDataEvent = {\n                type: HttpEventType.DATA,\n                data: value,\n              };\n              subscriber.next(dataEvent);\n            }\n            subscriber.complete();\n          } catch (error) {\n            subscriber.error(error);\n          }\n        })();\n\n        return () => {\n          reader.cancel();\n        };\n      });\n    }),\n  );\n};\n","import { Observable, Subject } from \"rxjs\";\nimport { HttpEvent, HttpEventType } from \"../run/http-request\";\n\n/**\n * Parses a stream of HTTP events into a stream of JSON objects using Server-Sent Events (SSE) format.\n * Strictly follows the SSE standard where:\n * - Events are separated by double newlines ('\\n\\n')\n * - Only 'data:' prefixed lines are processed\n * - Multi-line data events are supported and joined\n * - Non-data fields (event, id, retry) are ignored\n */\nexport const parseSSEStream = (source$: Observable<HttpEvent>): Observable<any> => {\n  const jsonSubject = new Subject<any>();\n  // Create TextDecoder with stream option set to true to handle split UTF-8 characters\n  const decoder = new TextDecoder(\"utf-8\", { fatal: false });\n  let buffer = \"\";\n\n  // Subscribe to the source once and multicast to all subscribers\n  source$.subscribe({\n    next: (event: HttpEvent) => {\n      if (event.type === HttpEventType.HEADERS) {\n        return;\n      }\n\n      if (event.type === HttpEventType.DATA && event.data) {\n        // Decode chunk carefully to handle UTF-8\n        const text = decoder.decode(event.data, { stream: true });\n        buffer += text;\n\n        // Process complete events (separated by double newlines)\n        const events = buffer.split(/\\n\\n/);\n        // Keep the last potentially incomplete event in buffer\n        buffer = events.pop() || \"\";\n\n        for (const event of events) {\n          processSSEEvent(event);\n        }\n      }\n    },\n    error: (err) => jsonSubject.error(err),\n    complete: () => {\n      // Use the final call to decoder.decode() to flush any remaining bytes\n      if (buffer) {\n        buffer += decoder.decode();\n        // Process any remaining SSE event data\n        processSSEEvent(buffer);\n      }\n      jsonSubject.complete();\n    },\n  });\n\n  /**\n   * Helper function to process an SSE event.\n   * Extracts and joins data lines, then parses the result as JSON.\n   * Follows the SSE spec by only processing 'data:' prefixed lines.\n   * @param eventText The raw event text to process\n   */\n  function processSSEEvent(eventText: string) {\n    const lines = eventText.split(\"\\n\");\n    const dataLines: string[] = [];\n\n    for (const line of lines) {\n      if (line.startsWith(\"data: \")) {\n        // Extract data content (remove 'data: ' prefix)\n        dataLines.push(line.slice(6));\n      }\n    }\n\n    // Only process if we have data lines\n    if (dataLines.length > 0) {\n      try {\n        // Join multi-line data and parse JSON\n        const jsonStr = dataLines.join(\"\\n\");\n        const json = JSON.parse(jsonStr);\n        jsonSubject.next(json);\n      } catch (err) {\n        jsonSubject.error(err);\n      }\n    }\n  }\n\n  return jsonSubject.asObservable();\n};\n","import { Observable, Subject } from \"rxjs\";\nimport { HttpEvent, HttpEventType } from \"../run/http-request\";\nimport { BaseEvent } from \"@ag-ui/core\";\nimport * as proto from \"@ag-ui/proto\";\n\n/**\n * Parses a stream of HTTP events into a stream of BaseEvent objects using Protocol Buffer format.\n * Each message is prefixed with a 4-byte length header (uint32 in big-endian format)\n * followed by the protocol buffer encoded message.\n */\nexport const parseProtoStream = (source$: Observable<HttpEvent>): Observable<BaseEvent> => {\n  const eventSubject = new Subject<BaseEvent>();\n  let buffer = new Uint8Array(0);\n\n  source$.subscribe({\n    next: (event: HttpEvent) => {\n      if (event.type === HttpEventType.HEADERS) {\n        return;\n      }\n\n      if (event.type === HttpEventType.DATA && event.data) {\n        // Append the new data to our buffer\n        const newBuffer = new Uint8Array(buffer.length + event.data.length);\n        newBuffer.set(buffer, 0);\n        newBuffer.set(event.data, buffer.length);\n        buffer = newBuffer;\n\n        // Process as many complete messages as possible\n        processBuffer();\n      }\n    },\n    error: (err) => eventSubject.error(err),\n    complete: () => {\n      // Try to process any remaining data in the buffer\n      if (buffer.length > 0) {\n        try {\n          processBuffer();\n        } catch (error: unknown) {\n          console.warn(\"Incomplete or invalid protocol buffer data at stream end\");\n        }\n      }\n      eventSubject.complete();\n    },\n  });\n\n  /**\n   * Process as many complete messages as possible from the buffer\n   */\n  function processBuffer() {\n    // Keep processing while we have enough data for at least a header (4 bytes)\n    while (buffer.length >= 4) {\n      // Read message length from the first 4 bytes (big-endian uint32)\n      const view = new DataView(buffer.buffer, buffer.byteOffset, 4);\n      const messageLength = view.getUint32(0, false); // false = big-endian\n\n      // Check if we have the complete message (header + message body)\n      const totalLength = 4 + messageLength;\n      if (buffer.length < totalLength) {\n        // Not enough data yet, wait for more\n        break;\n      }\n\n      try {\n        // Extract the message (skipping the 4-byte header)\n        const message = buffer.slice(4, totalLength);\n\n        // Decode the protocol buffer message using the imported decode function\n        const event = proto.decode(message);\n\n        // Emit the parsed event\n        eventSubject.next(event);\n\n        // Remove the processed message from the buffer\n        buffer = buffer.slice(totalLength);\n      } catch (error: unknown) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        eventSubject.error(new Error(`Failed to decode protocol buffer message: ${errorMessage}`));\n        return;\n      }\n    }\n  }\n\n  return eventSubject.asObservable();\n};\n","import { mergeMap } from \"rxjs/operators\";\nimport { applyPatch } from \"fast-json-patch\";\n\nimport {\n  BaseEvent,\n  EventType,\n  TextMessageStartEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  ToolCallStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n  ToolCallResultEvent,\n  CustomEvent,\n  StateSnapshotEvent,\n  StepStartedEvent,\n  Message,\n  StateDeltaEvent,\n  MessagesSnapshotEvent,\n  ToolCall,\n} from \"@ag-ui/core\";\nimport { Observable } from \"rxjs\";\nimport {\n  LegacyTextMessageStart,\n  LegacyTextMessageContent,\n  LegacyTextMessageEnd,\n  LegacyActionExecutionStart,\n  LegacyActionExecutionArgs,\n  LegacyActionExecutionEnd,\n  LegacyRuntimeEventTypes,\n  LegacyRuntimeProtocolEvent,\n  LegacyMetaEvent,\n  LegacyAgentStateMessage,\n  LegacyMessage,\n  LegacyTextMessage,\n  LegacyActionExecutionMessage,\n  LegacyResultMessage,\n  LegacyActionExecutionResult,\n} from \"./types\";\nimport untruncateJson from \"untruncate-json\";\n\ninterface PredictStateValue {\n  state_key: string;\n  tool: string;\n  tool_argument: string;\n}\n\nexport const convertToLegacyEvents =\n  (threadId: string, runId: string, agentName: string) =>\n  (events$: Observable<BaseEvent>): Observable<LegacyRuntimeProtocolEvent> => {\n    let currentState: any = {};\n    let running = true;\n    let active = true;\n    let nodeName = \"\";\n    let syncedMessages: Message[] | null = null;\n    let predictState: PredictStateValue[] | null = null;\n    let currentToolCalls: ToolCall[] = [];\n    let toolCallNames: Record<string, string> = {};\n\n    const updateCurrentState = (newState: any) => {\n      // the legacy protocol will only support object state\n      if (typeof newState === \"object\" && newState !== null) {\n        if (\"messages\" in newState) {\n          delete newState.messages;\n        }\n        currentState = newState;\n      }\n    };\n\n    return events$.pipe(\n      mergeMap((event) => {\n        switch (event.type) {\n          case EventType.TEXT_MESSAGE_START: {\n            const startEvent = event as TextMessageStartEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.TextMessageStart,\n                messageId: startEvent.messageId,\n              } as LegacyTextMessageStart,\n            ];\n          }\n          case EventType.TEXT_MESSAGE_CONTENT: {\n            const contentEvent = event as TextMessageContentEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.TextMessageContent,\n                messageId: contentEvent.messageId,\n                content: contentEvent.delta,\n              } as LegacyTextMessageContent,\n            ];\n          }\n          case EventType.TEXT_MESSAGE_END: {\n            const endEvent = event as TextMessageEndEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.TextMessageEnd,\n                messageId: endEvent.messageId,\n              } as LegacyTextMessageEnd,\n            ];\n          }\n          case EventType.TOOL_CALL_START: {\n            const startEvent = event as ToolCallStartEvent;\n\n            currentToolCalls.push({\n              id: startEvent.toolCallId,\n              type: \"function\",\n              function: {\n                name: startEvent.toolCallName,\n                arguments: \"\",\n              },\n            });\n\n            active = true;\n            toolCallNames[startEvent.toolCallId] = startEvent.toolCallName;\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.ActionExecutionStart,\n                actionExecutionId: startEvent.toolCallId,\n                actionName: startEvent.toolCallName,\n                parentMessageId: startEvent.parentMessageId,\n              } as LegacyActionExecutionStart,\n            ];\n          }\n          case EventType.TOOL_CALL_ARGS: {\n            const argsEvent = event as ToolCallArgsEvent;\n\n            const currentToolCall = currentToolCalls[currentToolCalls.length - 1];\n            currentToolCall.function.arguments += argsEvent.delta;\n            let didUpdateState = false;\n\n            if (predictState) {\n              let currentPredictState = predictState.find(\n                (s) => s.tool == currentToolCall.function.name,\n              );\n\n              if (currentPredictState) {\n                try {\n                  const currentArgs = JSON.parse(\n                    untruncateJson(currentToolCall.function.arguments),\n                  );\n                  if (\n                    currentPredictState.tool_argument &&\n                    currentPredictState.tool_argument in currentArgs\n                  ) {\n                    updateCurrentState({\n                      ...currentState,\n                      [currentPredictState.state_key]:\n                        currentArgs[currentPredictState.tool_argument],\n                    });\n                    didUpdateState = true;\n                  } else if (!currentPredictState.tool_argument) {\n                    updateCurrentState({\n                      ...currentState,\n                      [currentPredictState.state_key]: currentArgs,\n                    });\n                    didUpdateState = true;\n                  }\n                } catch (e) {}\n              }\n            }\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.ActionExecutionArgs,\n                actionExecutionId: argsEvent.toolCallId,\n                args: argsEvent.delta,\n              } as LegacyActionExecutionArgs,\n              ...(didUpdateState\n                ? [\n                    {\n                      type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                      threadId,\n                      agentName,\n                      nodeName,\n                      runId,\n                      running,\n                      role: \"assistant\",\n                      state: JSON.stringify(currentState),\n                      active,\n                    },\n                  ]\n                : []),\n            ];\n          }\n          case EventType.TOOL_CALL_END: {\n            const endEvent = event as ToolCallEndEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.ActionExecutionEnd,\n                actionExecutionId: endEvent.toolCallId,\n              } as LegacyActionExecutionEnd,\n            ];\n          }\n          case EventType.TOOL_CALL_RESULT: {\n            const resultEvent = event as ToolCallResultEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.ActionExecutionResult,\n                actionExecutionId: resultEvent.toolCallId,\n                result: resultEvent.content,\n                actionName: toolCallNames[resultEvent.toolCallId] || \"unknown\",\n              } as LegacyActionExecutionResult,\n            ];\n          }\n          case EventType.RAW: {\n            // The legacy protocol doesn't support raw events\n            return [];\n          }\n          case EventType.CUSTOM: {\n            const customEvent = event as CustomEvent;\n            switch (customEvent.name) {\n              case \"Exit\":\n                running = false;\n                break;\n              case \"PredictState\":\n                predictState = customEvent.value as PredictStateValue[];\n                break;\n            }\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.MetaEvent,\n                name: customEvent.name,\n                value: customEvent.value,\n              } as LegacyMetaEvent,\n            ];\n          }\n          case EventType.STATE_SNAPSHOT: {\n            const stateEvent = event as StateSnapshotEvent;\n            updateCurrentState(stateEvent.snapshot);\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify(currentState),\n                active,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.STATE_DELTA: {\n            const deltaEvent = event as StateDeltaEvent;\n            const result = applyPatch(currentState, deltaEvent.delta, true, false);\n            if (!result) {\n              return [];\n            }\n            updateCurrentState(result.newDocument);\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify(currentState),\n                active,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.MESSAGES_SNAPSHOT: {\n            const messagesSnapshot = event as MessagesSnapshotEvent;\n            syncedMessages = messagesSnapshot.messages;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify({\n                  ...currentState,\n                  ...(syncedMessages ? { messages: syncedMessages } : {}),\n                }),\n                active: true,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.RUN_STARTED: {\n            // There is nothing to do in the legacy protocol\n            return [];\n          }\n          case EventType.RUN_FINISHED: {\n            if (syncedMessages) {\n              currentState.messages = syncedMessages;\n            }\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify({\n                  ...currentState,\n                  ...(syncedMessages\n                    ? {\n                        messages: convertMessagesToLegacyFormat(syncedMessages),\n                      }\n                    : {}),\n                }),\n                active: false,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.RUN_ERROR: {\n            // legacy protocol does not have an event for errors\n            console.error(\"Run error\", event);\n            return [];\n          }\n          case EventType.STEP_STARTED: {\n            const stepStarted = event as StepStartedEvent;\n            nodeName = stepStarted.stepName;\n\n            currentToolCalls = [];\n            predictState = null;\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify(currentState),\n                active: true,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.STEP_FINISHED: {\n            currentToolCalls = [];\n            predictState = null;\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify(currentState),\n                active: false,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          default: {\n            return [];\n          }\n        }\n      }),\n    );\n  };\n\nexport function convertMessagesToLegacyFormat(messages: Message[]): LegacyMessage[] {\n  const result: LegacyMessage[] = [];\n\n  for (const message of messages) {\n    if (message.role === \"assistant\" || message.role === \"user\" || message.role === \"system\") {\n      if (message.content) {\n        const textMessage: LegacyTextMessage = {\n          id: message.id,\n          role: message.role,\n          content: message.content,\n        };\n        result.push(textMessage);\n      }\n      if (message.role === \"assistant\" && message.toolCalls && message.toolCalls.length > 0) {\n        for (const toolCall of message.toolCalls) {\n          const actionExecutionMessage: LegacyActionExecutionMessage = {\n            id: toolCall.id,\n            name: toolCall.function.name,\n            arguments: JSON.parse(toolCall.function.arguments),\n            parentMessageId: message.id,\n          };\n          result.push(actionExecutionMessage);\n        }\n      }\n    } else if (message.role === \"tool\") {\n      let actionName = \"unknown\";\n      for (const m of messages) {\n        if (m.role === \"assistant\" && m.toolCalls?.length) {\n          for (const toolCall of m.toolCalls) {\n            if (toolCall.id === message.toolCallId) {\n              actionName = toolCall.function.name;\n              break;\n            }\n          }\n        }\n      }\n      const toolMessage: LegacyResultMessage = {\n        id: message.id,\n        result: message.content,\n        actionExecutionId: message.toolCallId,\n        actionName,\n      };\n      result.push(toolMessage);\n    }\n  }\n\n  return result;\n}\n","import { z } from \"zod\";\n\n// Protocol Events\nexport const LegacyRuntimeEventTypes = z.enum([\n  \"TextMessageStart\",\n  \"TextMessageContent\",\n  \"TextMessageEnd\",\n  \"ActionExecutionStart\",\n  \"ActionExecutionArgs\",\n  \"ActionExecutionEnd\",\n  \"ActionExecutionResult\",\n  \"AgentStateMessage\",\n  \"MetaEvent\",\n  \"RunStarted\",\n  \"RunFinished\",\n  \"RunError\",\n  \"NodeStarted\",\n  \"NodeFinished\",\n]);\n\nexport const LegacyRuntimeMetaEventName = z.enum([\n  \"LangGraphInterruptEvent\",\n  \"PredictState\",\n  \"Exit\",\n]);\n\nexport const LegacyTextMessageStart = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.TextMessageStart),\n  messageId: z.string(),\n  parentMessageId: z.string().optional(),\n});\n\nexport const LegacyTextMessageContent = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.TextMessageContent),\n  messageId: z.string(),\n  content: z.string(),\n});\n\nexport const LegacyTextMessageEnd = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.TextMessageEnd),\n  messageId: z.string(),\n});\n\nexport const LegacyActionExecutionStart = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.ActionExecutionStart),\n  actionExecutionId: z.string(),\n  actionName: z.string(),\n  parentMessageId: z.string().optional(),\n});\n\nexport const LegacyActionExecutionArgs = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.ActionExecutionArgs),\n  actionExecutionId: z.string(),\n  args: z.string(),\n});\n\nexport const LegacyActionExecutionEnd = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.ActionExecutionEnd),\n  actionExecutionId: z.string(),\n});\n\nexport const LegacyActionExecutionResult = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.ActionExecutionResult),\n  actionName: z.string(),\n  actionExecutionId: z.string(),\n  result: z.string(),\n});\n\nexport const LegacyAgentStateMessage = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.AgentStateMessage),\n  threadId: z.string(),\n  agentName: z.string(),\n  nodeName: z.string(),\n  runId: z.string(),\n  active: z.boolean(),\n  role: z.string(),\n  state: z.string(),\n  running: z.boolean(),\n});\n\nexport const LegacyMetaEvent = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.MetaEvent),\n  name: LegacyRuntimeMetaEventName,\n  value: z.any(),\n});\n\nexport const LegacyRuntimeProtocolEvent = z.discriminatedUnion(\"type\", [\n  LegacyTextMessageStart,\n  LegacyTextMessageContent,\n  LegacyTextMessageEnd,\n  LegacyActionExecutionStart,\n  LegacyActionExecutionArgs,\n  LegacyActionExecutionEnd,\n  LegacyActionExecutionResult,\n  LegacyAgentStateMessage,\n  LegacyMetaEvent,\n]);\n\n// Protocol Event type exports\nexport type RuntimeEventTypes = z.infer<typeof LegacyRuntimeEventTypes>;\nexport type RuntimeMetaEventName = z.infer<typeof LegacyRuntimeMetaEventName>;\nexport type LegacyTextMessageStart = z.infer<typeof LegacyTextMessageStart>;\nexport type LegacyTextMessageContent = z.infer<typeof LegacyTextMessageContent>;\nexport type LegacyTextMessageEnd = z.infer<typeof LegacyTextMessageEnd>;\nexport type LegacyActionExecutionStart = z.infer<typeof LegacyActionExecutionStart>;\nexport type LegacyActionExecutionArgs = z.infer<typeof LegacyActionExecutionArgs>;\nexport type LegacyActionExecutionEnd = z.infer<typeof LegacyActionExecutionEnd>;\nexport type LegacyActionExecutionResult = z.infer<typeof LegacyActionExecutionResult>;\nexport type LegacyAgentStateMessage = z.infer<typeof LegacyAgentStateMessage>;\nexport type LegacyMetaEvent = z.infer<typeof LegacyMetaEvent>;\nexport type LegacyRuntimeProtocolEvent = z.infer<typeof LegacyRuntimeProtocolEvent>;\n\n// Message schemas (with kind discriminator)\nexport const LegacyTextMessageSchema = z.object({\n  id: z.string(),\n  role: z.string(),\n  content: z.string(),\n  parentMessageId: z.string().optional(),\n});\n\nexport const LegacyActionExecutionMessageSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  arguments: z.any(),\n  parentMessageId: z.string().optional(),\n});\n\nexport const LegacyResultMessageSchema = z.object({\n  id: z.string(),\n  result: z.any(),\n  actionExecutionId: z.string(),\n  actionName: z.string(),\n});\n\n// Message type exports\nexport type LegacyTextMessage = z.infer<typeof LegacyTextMessageSchema>;\nexport type LegacyActionExecutionMessage = z.infer<typeof LegacyActionExecutionMessageSchema>;\nexport type LegacyResultMessage = z.infer<typeof LegacyResultMessageSchema>;\nexport type LegacyMessage = LegacyTextMessage | LegacyActionExecutionMessage | LegacyResultMessage;\n","import { defaultApplyEvents } from \"@/apply/default\";\nimport { Message, State, RunAgentInput, BaseEvent, ToolCall, AssistantMessage } from \"@ag-ui/core\";\n\nimport { AgentConfig, RunAgentParameters } from \"./types\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { structuredClone_ } from \"@/utils\";\nimport { catchError, map, tap } from \"rxjs/operators\";\nimport { finalize } from \"rxjs/operators\";\nimport { pipe, Observable, from, of } from \"rxjs\";\nimport { verifyEvents } from \"@/verify\";\nimport { convertToLegacyEvents } from \"@/legacy/convert\";\nimport { LegacyRuntimeProtocolEvent } from \"@/legacy/types\";\nimport { lastValueFrom } from \"rxjs\";\nimport { transformChunks } from \"@/chunks\";\nimport { AgentStateMutation, AgentSubscriber, runSubscribersWithMutation } from \"./subscriber\";\n\nexport interface RunAgentResult {\n  result: any;\n  newMessages: Message[];\n}\n\nexport abstract class AbstractAgent {\n  public agentId?: string;\n  public description: string;\n  public threadId: string;\n  public messages: Message[];\n  public state: State;\n  public debug: boolean = false;\n  public subscribers: AgentSubscriber[] = [];\n\n  constructor({\n    agentId,\n    description,\n    threadId,\n    initialMessages,\n    initialState,\n    debug,\n  }: AgentConfig = {}) {\n    this.agentId = agentId;\n    this.description = description ?? \"\";\n    this.threadId = threadId ?? uuidv4();\n    this.messages = structuredClone_(initialMessages ?? []);\n    this.state = structuredClone_(initialState ?? {});\n    this.debug = debug ?? false;\n  }\n\n  public subscribe(subscriber: AgentSubscriber) {\n    this.subscribers.push(subscriber);\n    return {\n      unsubscribe: () => {\n        this.subscribers = this.subscribers.filter((s) => s !== subscriber);\n      },\n    };\n  }\n\n  protected abstract run(input: RunAgentInput): Observable<BaseEvent>;\n\n  public async runAgent(\n    parameters?: RunAgentParameters,\n    subscriber?: AgentSubscriber,\n  ): Promise<RunAgentResult> {\n    this.agentId = this.agentId ?? uuidv4();\n    const input = this.prepareRunAgentInput(parameters);\n    let result: any = undefined;\n    const currentMessageIds = new Set(this.messages.map((message) => message.id));\n\n    const subscribers: AgentSubscriber[] = [\n      {\n        onRunFinishedEvent: (params) => {\n          result = params.result;\n        },\n      },\n      ...this.subscribers,\n      subscriber ?? {},\n    ];\n\n    await this.onInitialize(input, subscribers);\n\n    const pipeline = pipe(\n      () => this.run(input),\n      transformChunks(this.debug),\n      verifyEvents(this.debug),\n      (source$) => this.apply(input, source$, subscribers),\n      (source$) => this.processApplyEvents(input, source$, subscribers),\n      catchError((error) => {\n        return this.onError(input, error, subscribers);\n      }),\n      finalize(() => {\n        void this.onFinalize(input, subscribers);\n      }),\n    );\n\n    return lastValueFrom(pipeline(of(null))).then(() => {\n      const newMessages = structuredClone_(this.messages).filter(\n        (message: Message) => !currentMessageIds.has(message.id),\n      );\n      return { result, newMessages };\n    });\n  }\n\n  public abortRun() {}\n\n  protected apply(\n    input: RunAgentInput,\n    events$: Observable<BaseEvent>,\n    subscribers: AgentSubscriber[],\n  ): Observable<AgentStateMutation> {\n    return defaultApplyEvents(input, events$, this, subscribers);\n  }\n\n  protected processApplyEvents(\n    input: RunAgentInput,\n    events$: Observable<AgentStateMutation>,\n    subscribers: AgentSubscriber[],\n  ): Observable<AgentStateMutation> {\n    return events$.pipe(\n      tap((event) => {\n        if (event.messages) {\n          this.messages = event.messages;\n          subscribers.forEach((subscriber) => {\n            subscriber.onMessagesChanged?.({\n              messages: this.messages,\n              state: this.state,\n              agent: this,\n              input,\n            });\n          });\n        }\n        if (event.state) {\n          this.state = event.state;\n          subscribers.forEach((subscriber) => {\n            subscriber.onStateChanged?.({\n              state: this.state,\n              messages: this.messages,\n              agent: this,\n              input,\n            });\n          });\n        }\n      }),\n    );\n  }\n\n  protected prepareRunAgentInput(parameters?: RunAgentParameters): RunAgentInput {\n    return {\n      threadId: this.threadId,\n      runId: parameters?.runId || uuidv4(),\n      tools: structuredClone_(parameters?.tools ?? []),\n      context: structuredClone_(parameters?.context ?? []),\n      forwardedProps: structuredClone_(parameters?.forwardedProps ?? {}),\n      state: structuredClone_(this.state),\n      messages: structuredClone_(this.messages),\n    };\n  }\n\n  protected async onInitialize(input: RunAgentInput, subscribers: AgentSubscriber[]) {\n    const onRunInitializedMutation = await runSubscribersWithMutation(\n      subscribers,\n      this.messages,\n      this.state,\n      (subscriber, messages, state) =>\n        subscriber.onRunInitialized?.({ messages, state, agent: this, input }),\n    );\n    if (\n      onRunInitializedMutation.messages !== undefined ||\n      onRunInitializedMutation.state !== undefined\n    ) {\n      if (onRunInitializedMutation.messages) {\n        this.messages = onRunInitializedMutation.messages;\n        input.messages = onRunInitializedMutation.messages;\n        subscribers.forEach((subscriber) => {\n          subscriber.onMessagesChanged?.({\n            messages: this.messages,\n            state: this.state,\n            agent: this,\n            input,\n          });\n        });\n      }\n      if (onRunInitializedMutation.state) {\n        this.state = onRunInitializedMutation.state;\n        input.state = onRunInitializedMutation.state;\n        subscribers.forEach((subscriber) => {\n          subscriber.onStateChanged?.({\n            state: this.state,\n            messages: this.messages,\n            agent: this,\n            input,\n          });\n        });\n      }\n    }\n  }\n\n  protected onError(input: RunAgentInput, error: Error, subscribers: AgentSubscriber[]) {\n    return from(\n      runSubscribersWithMutation(\n        subscribers,\n        this.messages,\n        this.state,\n        (subscriber, messages, state) =>\n          subscriber.onRunFailed?.({ error, messages, state, agent: this, input }),\n      ),\n    ).pipe(\n      map((onRunFailedMutation) => {\n        const mutation = onRunFailedMutation as AgentStateMutation;\n        if (mutation.messages !== undefined || mutation.state !== undefined) {\n          if (mutation.messages !== undefined) {\n            this.messages = mutation.messages;\n            subscribers.forEach((subscriber) => {\n              subscriber.onMessagesChanged?.({\n                messages: this.messages,\n                state: this.state,\n                agent: this,\n                input,\n              });\n            });\n          }\n          if (mutation.state !== undefined) {\n            this.state = mutation.state;\n            subscribers.forEach((subscriber) => {\n              subscriber.onStateChanged?.({\n                state: this.state,\n                messages: this.messages,\n                agent: this,\n                input,\n              });\n            });\n          }\n        }\n\n        if (mutation.stopPropagation !== true) {\n          console.error(\"Agent execution failed:\", error);\n          throw error;\n        }\n\n        // Return an empty mutation instead of null to prevent EmptyError\n        return {} as AgentStateMutation;\n      }),\n    );\n  }\n\n  protected async onFinalize(input: RunAgentInput, subscribers: AgentSubscriber[]) {\n    const onRunFinalizedMutation = await runSubscribersWithMutation(\n      subscribers,\n      this.messages,\n      this.state,\n      (subscriber, messages, state) =>\n        subscriber.onRunFinalized?.({ messages, state, agent: this, input }),\n    );\n\n    if (\n      onRunFinalizedMutation.messages !== undefined ||\n      onRunFinalizedMutation.state !== undefined\n    ) {\n      if (onRunFinalizedMutation.messages !== undefined) {\n        this.messages = onRunFinalizedMutation.messages;\n        subscribers.forEach((subscriber) => {\n          subscriber.onMessagesChanged?.({\n            messages: this.messages,\n            state: this.state,\n            agent: this,\n            input,\n          });\n        });\n      }\n      if (onRunFinalizedMutation.state !== undefined) {\n        this.state = onRunFinalizedMutation.state;\n        subscribers.forEach((subscriber) => {\n          subscriber.onStateChanged?.({\n            state: this.state,\n            messages: this.messages,\n            agent: this,\n            input,\n          });\n        });\n      }\n    }\n  }\n\n  public clone() {\n    const cloned = Object.create(Object.getPrototypeOf(this));\n\n    for (const key of Object.getOwnPropertyNames(this)) {\n      const value = (this as any)[key];\n      if (typeof value !== \"function\") {\n        cloned[key] = structuredClone_(value);\n      }\n    }\n\n    return cloned;\n  }\n\n  public addMessage(message: Message) {\n    // Add message to the messages array\n    this.messages.push(message);\n\n    // Notify subscribers sequentially in the background\n    (async () => {\n      // Fire onNewMessage sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onNewMessage?.({\n          message,\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n\n      // Fire onNewToolCall if the message is from assistant and contains tool calls\n      if (message.role === \"assistant\" && message.toolCalls) {\n        for (const toolCall of message.toolCalls) {\n          for (const subscriber of this.subscribers) {\n            await subscriber.onNewToolCall?.({\n              toolCall,\n              messages: this.messages,\n              state: this.state,\n              agent: this,\n            });\n          }\n        }\n      }\n\n      // Fire onMessagesChanged sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onMessagesChanged?.({\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n    })();\n  }\n\n  public addMessages(messages: Message[]) {\n    // Add all messages to the messages array\n    this.messages.push(...messages);\n\n    // Notify subscribers sequentially in the background\n    (async () => {\n      // Fire onNewMessage and onNewToolCall for each message sequentially\n      for (const message of messages) {\n        // Fire onNewMessage sequentially\n        for (const subscriber of this.subscribers) {\n          await subscriber.onNewMessage?.({\n            message,\n            messages: this.messages,\n            state: this.state,\n            agent: this,\n          });\n        }\n\n        // Fire onNewToolCall if the message is from assistant and contains tool calls\n        if (message.role === \"assistant\" && message.toolCalls) {\n          for (const toolCall of message.toolCalls) {\n            for (const subscriber of this.subscribers) {\n              await subscriber.onNewToolCall?.({\n                toolCall,\n                messages: this.messages,\n                state: this.state,\n                agent: this,\n              });\n            }\n          }\n        }\n      }\n\n      // Fire onMessagesChanged once at the end sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onMessagesChanged?.({\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n    })();\n  }\n\n  public setMessages(messages: Message[]) {\n    // Replace the entire messages array\n    this.messages = structuredClone_(messages);\n\n    // Notify subscribers sequentially in the background\n    (async () => {\n      // Fire onMessagesChanged sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onMessagesChanged?.({\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n    })();\n  }\n\n  public setState(state: State) {\n    // Replace the entire state\n    this.state = structuredClone_(state);\n\n    // Notify subscribers sequentially in the background\n    (async () => {\n      // Fire onStateChanged sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onStateChanged?.({\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n    })();\n  }\n\n  public legacy_to_be_removed_runAgentBridged(\n    config?: RunAgentParameters,\n  ): Observable<LegacyRuntimeProtocolEvent> {\n    this.agentId = this.agentId ?? uuidv4();\n    const input = this.prepareRunAgentInput(config);\n\n    return this.run(input).pipe(\n      transformChunks(this.debug),\n      verifyEvents(this.debug),\n      convertToLegacyEvents(this.threadId, input.runId, this.agentId),\n      (events$: Observable<LegacyRuntimeProtocolEvent>) => {\n        return events$.pipe(\n          map((event) => {\n            if (this.debug) {\n              console.debug(\"[LEGACY]:\", JSON.stringify(event));\n            }\n            return event;\n          }),\n        );\n      },\n    );\n  }\n}\n","import { mergeMap, Observable, finalize } from \"rxjs\";\nimport {\n  BaseEvent,\n  TextMessageChunkEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  TextMessageStartEvent,\n  ToolCallArgsEvent,\n  ToolCallChunkEvent,\n  ToolCallEndEvent,\n  ToolCallStartEvent,\n} from \"@ag-ui/core\";\nimport { EventType } from \"@ag-ui/core\";\n\ninterface TextMessageFields {\n  messageId: string;\n}\n\ninterface ToolCallFields {\n  toolCallId: string;\n  toolCallName: string;\n  parentMessageId?: string;\n}\n\nexport const transformChunks =\n  (debug: boolean) =>\n  (events$: Observable<BaseEvent>): Observable<BaseEvent> => {\n    let textMessageFields: TextMessageFields | undefined;\n    let toolCallFields: ToolCallFields | undefined;\n    let mode: \"text\" | \"tool\" | undefined;\n\n    const closeTextMessage = () => {\n      if (!textMessageFields || mode !== \"text\") {\n        throw new Error(\"No text message to close\");\n      }\n      const event = {\n        type: EventType.TEXT_MESSAGE_END,\n        messageId: textMessageFields.messageId,\n      } as TextMessageEndEvent;\n      mode = undefined;\n      textMessageFields = undefined;\n\n      if (debug) {\n        console.debug(\"[TRANSFORM]: TEXT_MESSAGE_END\", JSON.stringify(event));\n      }\n\n      return event;\n    };\n\n    const closeToolCall = () => {\n      if (!toolCallFields || mode !== \"tool\") {\n        throw new Error(\"No tool call to close\");\n      }\n      const event = {\n        type: EventType.TOOL_CALL_END,\n        toolCallId: toolCallFields.toolCallId,\n      } as ToolCallEndEvent;\n      mode = undefined;\n      toolCallFields = undefined;\n\n      if (debug) {\n        console.debug(\"[TRANSFORM]: TOOL_CALL_END\", JSON.stringify(event));\n      }\n\n      return event;\n    };\n\n    const closePendingEvent = () => {\n      if (mode === \"text\") {\n        return [closeTextMessage()];\n      }\n      if (mode === \"tool\") {\n        return [closeToolCall()];\n      }\n      return [];\n    };\n\n    return events$.pipe(\n      mergeMap((event) => {\n        switch (event.type) {\n          case EventType.TEXT_MESSAGE_START:\n          case EventType.TEXT_MESSAGE_CONTENT:\n          case EventType.TEXT_MESSAGE_END:\n          case EventType.TOOL_CALL_START:\n          case EventType.TOOL_CALL_ARGS:\n          case EventType.TOOL_CALL_END:\n          case EventType.TOOL_CALL_RESULT:\n          case EventType.STATE_SNAPSHOT:\n          case EventType.STATE_DELTA:\n          case EventType.MESSAGES_SNAPSHOT:\n          case EventType.CUSTOM:\n          case EventType.RUN_STARTED:\n          case EventType.RUN_FINISHED:\n          case EventType.RUN_ERROR:\n          case EventType.STEP_STARTED:\n          case EventType.STEP_FINISHED:\n          case EventType.THINKING_START:\n          case EventType.THINKING_END:\n          case EventType.THINKING_TEXT_MESSAGE_START:\n          case EventType.THINKING_TEXT_MESSAGE_CONTENT:\n          case EventType.THINKING_TEXT_MESSAGE_END:\n            return [...closePendingEvent(), event];\n          case EventType.RAW:\n            return [event];\n          case EventType.TEXT_MESSAGE_CHUNK:\n            const messageChunkEvent = event as TextMessageChunkEvent;\n            const textMessageResult = [];\n            if (\n              // we are not in a text message\n              mode !== \"text\" ||\n              // or the message id is different\n              (messageChunkEvent.messageId !== undefined &&\n                messageChunkEvent.messageId !== textMessageFields?.messageId)\n            ) {\n              // close the current message if any\n              textMessageResult.push(...closePendingEvent());\n            }\n\n            // we are not in a text message, start a new one\n            if (mode !== \"text\") {\n              if (messageChunkEvent.messageId === undefined) {\n                throw new Error(\"First TEXT_MESSAGE_CHUNK must have a messageId\");\n              }\n\n              textMessageFields = {\n                messageId: messageChunkEvent.messageId,\n              };\n              mode = \"text\";\n\n              const textMessageStartEvent = {\n                type: EventType.TEXT_MESSAGE_START,\n                messageId: messageChunkEvent.messageId,\n                role: \"assistant\",\n              } as TextMessageStartEvent;\n\n              textMessageResult.push(textMessageStartEvent);\n\n              if (debug) {\n                console.debug(\n                  \"[TRANSFORM]: TEXT_MESSAGE_START\",\n                  JSON.stringify(textMessageStartEvent),\n                );\n              }\n            }\n\n            if (messageChunkEvent.delta !== undefined) {\n              const textMessageContentEvent = {\n                type: EventType.TEXT_MESSAGE_CONTENT,\n                messageId: textMessageFields!.messageId,\n                delta: messageChunkEvent.delta,\n              } as TextMessageContentEvent;\n\n              textMessageResult.push(textMessageContentEvent);\n\n              if (debug) {\n                console.debug(\n                  \"[TRANSFORM]: TEXT_MESSAGE_CONTENT\",\n                  JSON.stringify(textMessageContentEvent),\n                );\n              }\n            }\n\n            return textMessageResult;\n          case EventType.TOOL_CALL_CHUNK:\n            const toolCallChunkEvent = event as ToolCallChunkEvent;\n            const toolMessageResult = [];\n            if (\n              // we are not in a text message\n              mode !== \"tool\" ||\n              // or the tool call id is different\n              (toolCallChunkEvent.toolCallId !== undefined &&\n                toolCallChunkEvent.toolCallId !== toolCallFields?.toolCallId)\n            ) {\n              // close the current message if any\n              toolMessageResult.push(...closePendingEvent());\n            }\n\n            if (mode !== \"tool\") {\n              if (toolCallChunkEvent.toolCallId === undefined) {\n                throw new Error(\"First TOOL_CALL_CHUNK must have a toolCallId\");\n              }\n              if (toolCallChunkEvent.toolCallName === undefined) {\n                throw new Error(\"First TOOL_CALL_CHUNK must have a toolCallName\");\n              }\n              toolCallFields = {\n                toolCallId: toolCallChunkEvent.toolCallId,\n                toolCallName: toolCallChunkEvent.toolCallName,\n                parentMessageId: toolCallChunkEvent.parentMessageId,\n              };\n              mode = \"tool\";\n\n              const toolCallStartEvent = {\n                type: EventType.TOOL_CALL_START,\n                toolCallId: toolCallChunkEvent.toolCallId,\n                toolCallName: toolCallChunkEvent.toolCallName,\n                parentMessageId: toolCallChunkEvent.parentMessageId,\n              } as ToolCallStartEvent;\n\n              toolMessageResult.push(toolCallStartEvent);\n\n              if (debug) {\n                console.debug(\"[TRANSFORM]: TOOL_CALL_START\", JSON.stringify(toolCallStartEvent));\n              }\n            }\n\n            if (toolCallChunkEvent.delta !== undefined) {\n              const toolCallArgsEvent = {\n                type: EventType.TOOL_CALL_ARGS,\n                toolCallId: toolCallFields!.toolCallId,\n                delta: toolCallChunkEvent.delta,\n              } as ToolCallArgsEvent;\n\n              toolMessageResult.push(toolCallArgsEvent);\n\n              if (debug) {\n                console.debug(\"[TRANSFORM]: TOOL_CALL_ARGS\", JSON.stringify(toolCallArgsEvent));\n              }\n            }\n\n            return toolMessageResult;\n        }\n        const _exhaustiveCheck: never = event.type;\n      }),\n      finalize(() => {\n        // This ensures that we close any pending events when the source observable completes\n        return closePendingEvent();\n      }),\n    );\n  };\n","import { AbstractAgent, RunAgentResult } from \"./agent\";\nimport { runHttpRequest } from \"@/run/http-request\";\nimport { HttpAgentConfig, RunAgentParameters } from \"./types\";\nimport { RunAgentInput, BaseEvent } from \"@ag-ui/core\";\nimport { structuredClone_ } from \"@/utils\";\nimport { transformHttpEventStream } from \"@/transform/http\";\nimport { Observable } from \"rxjs\";\nimport { AgentSubscriber } from \"./subscriber\";\n\ninterface RunHttpAgentConfig extends RunAgentParameters {\n  abortController?: AbortController;\n}\n\nexport class HttpAgent extends AbstractAgent {\n  public url: string;\n  public headers: Record<string, string>;\n  public abortController: AbortController = new AbortController();\n\n  /**\n   * Returns the fetch config for the http request.\n   * Override this to customize the request.\n   *\n   * @returns The fetch config for the http request.\n   */\n  protected requestInit(input: RunAgentInput): RequestInit {\n    return {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\",\n        Accept: \"text/event-stream\",\n      },\n      body: JSON.stringify(input),\n      signal: this.abortController.signal,\n    };\n  }\n\n  public runAgent(\n    parameters?: RunHttpAgentConfig,\n    subscriber?: AgentSubscriber,\n  ): Promise<RunAgentResult> {\n    this.abortController = parameters?.abortController ?? new AbortController();\n    return super.runAgent(parameters, subscriber);\n  }\n\n  abortRun() {\n    this.abortController.abort();\n    super.abortRun();\n  }\n\n  constructor(config: HttpAgentConfig) {\n    super(config);\n    this.url = config.url;\n    this.headers = structuredClone_(config.headers ?? {});\n  }\n\n  run(input: RunAgentInput): Observable<BaseEvent> {\n    const httpEvents = runHttpRequest(this.url, this.requestInit(input));\n    return transformHttpEventStream(httpEvents);\n  }\n}\n","export * from \"./apply\";\nexport * from \"./verify\";\nexport * from \"./transform\";\nexport * from \"./run\";\nexport * from \"./legacy\";\nexport * from \"./agent\";\nexport * from \"@ag-ui/core\";\n"],"mappings":"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","names":["EventType","mergeAll","defaultIfEmpty","concatMap","of","EMPTY","structuredClone_","obj","err","__spreadValues","applyPatch","runSubscribersWithMutation","subscribers","initialMessages","initialState","executor","messages","state","stopPropagation","subscriber","mutation","structuredClone_","error","__spreadValues","untruncateJson","defaultApplyEvents","input","events$","agent","subscribers","messages","structuredClone_","state","currentMutation","applyMutation","mutation","emitUpdates","result","of","EMPTY","concatMap","event","_a","runSubscribersWithMutation","subscriber","EventType","messageId","role","newMessage","_b","delta","lastMessage","toolCallId","toolCallName","parentMessageId","targetMessage","_c","toolCalls","toolCallBuffer","partialToolCallArgs","error","lastToolCall","toolCallArgsString","toolCallArgs","content","toolMessage","snapshot","applyPatch","errorMessage","newMessages","_exhaustiveCheck","mergeAll","defaultIfEmpty","stream","EventType","AGUIError","throwError","of","mergeMap","verifyEvents","debug","source$","activeMessageId","activeToolCallId","runFinished","runError","firstEventReceived","activeSteps","activeThinkingStep","activeThinkingStepMessage","event","eventType","stepName","unfinishedSteps","EventSchemas","Subject","ReplaySubject","Observable","from","defer","throwError","switchMap","runHttpRequest","url","requestInit","defer","from","switchMap","response","_a","headersEvent","reader","Observable","subscriber","done","value","dataEvent","error","throwError","Subject","parseSSEStream","source$","jsonSubject","Subject","decoder","buffer","event","text","events","processSSEEvent","err","eventText","lines","dataLines","line","jsonStr","json","Subject","proto","parseProtoStream","source$","eventSubject","Subject","buffer","event","newBuffer","processBuffer","err","error","totalLength","message","errorMessage","proto","transformHttpEventStream","source$","eventSubject","Subject","bufferSubject","ReplaySubject","parserInitialized","event","parseProtoStream","err","parseSSEStream","json","parsedEvent","EventSchemas","mergeMap","applyPatch","EventType","z","LegacyRuntimeEventTypes","LegacyRuntimeMetaEventName","LegacyTextMessageStart","LegacyTextMessageContent","LegacyTextMessageEnd","LegacyActionExecutionStart","LegacyActionExecutionArgs","LegacyActionExecutionEnd","LegacyActionExecutionResult","LegacyAgentStateMessage","LegacyMetaEvent","LegacyRuntimeProtocolEvent","LegacyTextMessageSchema","LegacyActionExecutionMessageSchema","LegacyResultMessageSchema","untruncateJson","convertToLegacyEvents","threadId","runId","agentName","events$","currentState","running","active","nodeName","syncedMessages","predictState","currentToolCalls","toolCallNames","updateCurrentState","newState","mergeMap","event","EventType","startEvent","LegacyRuntimeEventTypes","contentEvent","endEvent","argsEvent","currentToolCall","didUpdateState","currentPredictState","s","currentArgs","untruncateJson","__spreadProps","__spreadValues","e","resultEvent","customEvent","result","applyPatch","convertMessagesToLegacyFormat","messages","_a","message","textMessage","toolCall","actionExecutionMessage","actionName","m","toolMessage","uuidv4","catchError","map","tap","finalize","pipe","from","of","lastValueFrom","mergeMap","finalize","EventType","transformChunks","debug","events$","textMessageFields","toolCallFields","mode","closeTextMessage","event","closeToolCall","closePendingEvent","messageChunkEvent","textMessageResult","textMessageStartEvent","textMessageContentEvent","toolCallChunkEvent","toolMessageResult","toolCallStartEvent","toolCallArgsEvent","_exhaustiveCheck","AbstractAgent","agentId","description","threadId","initialMessages","initialState","debug","uuidv4","structuredClone_","subscriber","s","parameters","_a","input","result","currentMessageIds","message","subscribers","params","pipeline","pipe","transformChunks","verifyEvents","source$","catchError","error","finalize","lastValueFrom","of","newMessages","events$","defaultApplyEvents","tap","event","_b","_c","onRunInitializedMutation","runSubscribersWithMutation","messages","state","from","map","onRunFailedMutation","mutation","onRunFinalizedMutation","cloned","key","value","toolCall","config","convertToLegacyEvents","HttpAgent","AbstractAgent","config","_a","structuredClone_","input","__spreadProps","__spreadValues","parameters","subscriber","httpEvents","runHttpRequest","transformHttpEventStream"]}