{"version":3,"file":"xstate-graph.umd.min.js","sources":["../../src/Mailbox.ts","../../src/constants.ts","../../src/dev/index.ts","../../src/eventUtils.ts","../../src/reportUnhandledError.ts","../../src/symbolObservable.ts","../../src/utils.ts","../../src/system.ts","../../src/createActor.ts","../../src/actions/cancel.ts","../../src/actions/spawnChild.ts","../../src/actions/stopChild.ts","../../src/guards.ts","../../src/stateUtils.ts","../../src/actions/raise.ts","../../src/State.ts","../../src/spawn.ts","../../src/actions/assign.ts","../../src/actors/index.ts","../../src/actors/transition.ts","../../src/memo.ts","../../src/StateNode.ts","../../src/StateMachine.ts","../../src/graph/utils.ts","../../src/graph/deduplicatePaths.ts","../../src/graph/pathGenerators.ts","../../src/graph/validateMachine.ts","../../src/graph/TestModel.ts","../../src/graph/actorScope.ts","../../src/graph/graph.ts","../../src/graph/adjacency.ts","../../src/graph/alterPath.ts","../../src/graph/pathFromEvents.ts","../../src/graph/shortestPaths.ts","../../src/graph/simplePaths.ts"],"sourcesContent":["interface MailboxItem<T> {\n  value: T;\n  next: MailboxItem<T> | null;\n}\n\nexport class Mailbox<T> {\n  private _active: boolean = false;\n  private _current: MailboxItem<T> | null = null;\n  private _last: MailboxItem<T> | null = null;\n\n  constructor(private _process: (ev: T) => void) {}\n\n  public start() {\n    this._active = true;\n    this.flush();\n  }\n\n  public clear(): void {\n    // we can't set _current to null because we might be currently processing\n    // and enqueue following clear shouldn't start processing the enqueued item immediately\n    if (this._current) {\n      this._current.next = null;\n      this._last = this._current;\n    }\n  }\n\n  public enqueue(event: T): void {\n    const enqueued = {\n      value: event,\n      next: null\n    };\n\n    if (this._current) {\n      this._last!.next = enqueued;\n      this._last = enqueued;\n      return;\n    }\n\n    this._current = enqueued;\n    this._last = enqueued;\n\n    if (this._active) {\n      this.flush();\n    }\n  }\n\n  private flush() {\n    while (this._current) {\n      // atm the given _process is responsible for implementing proper try/catch handling\n      // we assume here that this won't throw in a way that can affect this mailbox\n      const consumed = this._current;\n      this._process(consumed.value);\n      this._current = consumed.next;\n    }\n    this._last = null;\n  }\n}\n","export const STATE_DELIMITER = '.';\nexport const TARGETLESS_KEY = '';\nexport const NULL_EVENT = '';\nexport const STATE_IDENTIFIER = '#';\nexport const WILDCARD = '*';\nexport const XSTATE_INIT = 'xstate.init';\nexport const XSTATE_ERROR = 'xstate.error';\nexport const XSTATE_STOP = 'xstate.stop';\n","import isDevelopment from '#is-development';\nimport { AnyActor, DevToolsAdapter } from '../types.ts';\n\ninterface DevInterface {\n  services: Set<AnyActor>;\n  register(service: AnyActor): void;\n  onRegister(listener: ServiceListener): void;\n}\ntype ServiceListener = (service: AnyActor) => void;\n\nexport interface XStateDevInterface {\n  register: (service: AnyActor) => void;\n  unregister: (service: AnyActor) => void;\n  onRegister: (listener: ServiceListener) => {\n    unsubscribe: () => void;\n  };\n  services: Set<AnyActor>;\n}\n\n// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis\nexport function getGlobal(): typeof globalThis | undefined {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  if (isDevelopment) {\n    console.warn(\n      'XState could not find a global object in this environment. Please let the maintainers know and raise an issue here: https://github.com/statelyai/xstate/issues'\n    );\n  }\n}\n\nfunction getDevTools(): DevInterface | undefined {\n  const w = getGlobal();\n  if ((w as any).__xstate__) {\n    return (w as any).__xstate__;\n  }\n\n  return undefined;\n}\n\nexport function registerService(service: AnyActor) {\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  const devTools = getDevTools();\n\n  if (devTools) {\n    devTools.register(service);\n  }\n}\n\nexport const devToolsAdapter: DevToolsAdapter = (service) => {\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  const devTools = getDevTools();\n\n  if (devTools) {\n    devTools.register(service);\n  }\n};\n","import { XSTATE_INIT } from './constants.ts';\nimport { DoneActorEvent, DoneStateEvent, ErrorActorEvent } from './types.ts';\n\n/**\n * Returns an event that represents an implicit event that is sent after the\n * specified `delay`.\n *\n * @param delayRef The delay in milliseconds\n * @param id The state node ID where this event is handled\n */\nexport function createAfterEvent(delayRef: number | string, id: string) {\n  return { type: `xstate.after.${delayRef}.${id}` } as const;\n}\n\n/**\n * Returns an event that represents that a final state node has been reached in\n * the parent state node.\n *\n * @param id The final state node's parent state node `id`\n * @param output The data to pass into the event\n */\nexport function createDoneStateEvent(\n  id: string,\n  output?: unknown\n): DoneStateEvent {\n  return {\n    type: `xstate.done.state.${id}`,\n    output\n  };\n}\n\n/**\n * Returns an event that represents that an invoked service has terminated.\n *\n * An invoked service is terminated when it has reached a top-level final state\n * node, but not when it is canceled.\n *\n * @param invokeId The invoked service ID\n * @param output The data to pass into the event\n */\nexport function createDoneActorEvent(\n  invokeId: string,\n  output?: unknown\n): DoneActorEvent {\n  return {\n    type: `xstate.done.actor.${invokeId}`,\n    output,\n    actorId: invokeId\n  };\n}\n\nexport function createErrorActorEvent(\n  id: string,\n  error?: unknown\n): ErrorActorEvent {\n  return { type: `xstate.error.actor.${id}`, error, actorId: id };\n}\n\nexport function createInitEvent(input: unknown) {\n  return { type: XSTATE_INIT, input } as const;\n}\n","/**\n * This function makes sure that unhandled errors are thrown in a separate\n * macrotask. It allows those errors to be detected by global error handlers and\n * reported to bug tracking services without interrupting our own stack of\n * execution.\n *\n * @param err Error to be thrown\n */\nexport function reportUnhandledError(err: unknown) {\n  setTimeout(() => {\n    throw err;\n  });\n}\n","export const symbolObservable: typeof Symbol.observable = (() =>\n  (typeof Symbol === 'function' && Symbol.observable) ||\n  '@@observable')() as any;\n","import isDevelopment from '#is-development';\nimport { isMachineSnapshot } from './State.ts';\nimport type { StateNode } from './StateNode.ts';\nimport { TARGETLESS_KEY } from './constants.ts';\nimport type {\n  AnyActorRef,\n  AnyEventObject,\n  AnyMachineSnapshot,\n  AnyStateMachine,\n  AnyTransitionConfig,\n  ErrorActorEvent,\n  EventObject,\n  InvokeConfig,\n  MachineContext,\n  Mapper,\n  NonReducibleUnknown,\n  Observer,\n  SingleOrArray,\n  StateLike,\n  StateValue,\n  TransitionConfigTarget\n} from './types.ts';\n\nexport function matchesState(\n  parentStateId: StateValue,\n  childStateId: StateValue\n): boolean {\n  const parentStateValue = toStateValue(parentStateId);\n  const childStateValue = toStateValue(childStateId);\n\n  if (typeof childStateValue === 'string') {\n    if (typeof parentStateValue === 'string') {\n      return childStateValue === parentStateValue;\n    }\n\n    // Parent more specific than child\n    return false;\n  }\n\n  if (typeof parentStateValue === 'string') {\n    return parentStateValue in childStateValue;\n  }\n\n  return Object.keys(parentStateValue).every((key) => {\n    if (!(key in childStateValue)) {\n      return false;\n    }\n\n    return matchesState(parentStateValue[key]!, childStateValue[key]!);\n  });\n}\n\nexport function toStatePath(stateId: string | string[]): string[] {\n  if (isArray(stateId)) {\n    return stateId;\n  }\n\n  const result: string[] = [];\n  let segment = '';\n\n  for (let i = 0; i < stateId.length; i++) {\n    const char = stateId.charCodeAt(i);\n    switch (char) {\n      // \\\n      case 92:\n        // consume the next character\n        segment += stateId[i + 1];\n        // and skip over it\n        i++;\n        continue;\n      // .\n      case 46:\n        result.push(segment);\n        segment = '';\n        continue;\n    }\n    segment += stateId[i];\n  }\n\n  result.push(segment);\n\n  return result;\n}\n\nfunction toStateValue(stateValue: StateLike<any> | StateValue): StateValue {\n  if (isMachineSnapshot(stateValue)) {\n    return stateValue.value;\n  }\n\n  if (typeof stateValue !== 'string') {\n    return stateValue as StateValue;\n  }\n\n  const statePath = toStatePath(stateValue);\n\n  return pathToStateValue(statePath);\n}\n\nexport function pathToStateValue(statePath: string[]): StateValue {\n  if (statePath.length === 1) {\n    return statePath[0];\n  }\n\n  const value: StateValue = {};\n  let marker = value;\n\n  for (let i = 0; i < statePath.length - 1; i++) {\n    if (i === statePath.length - 2) {\n      marker[statePath[i]] = statePath[i + 1];\n    } else {\n      const previous = marker;\n      marker = {};\n      previous[statePath[i]] = marker;\n    }\n  }\n\n  return value;\n}\n\nexport function mapValues<P, O extends Record<string, unknown>>(\n  collection: O,\n  iteratee: (item: O[keyof O], key: keyof O, collection: O, i: number) => P\n): { [key in keyof O]: P };\nexport function mapValues(\n  collection: Record<string, unknown>,\n  iteratee: (\n    item: unknown,\n    key: string,\n    collection: Record<string, unknown>,\n    i: number\n  ) => unknown\n) {\n  const result: Record<string, unknown> = {};\n\n  const collectionKeys = Object.keys(collection);\n  for (let i = 0; i < collectionKeys.length; i++) {\n    const key = collectionKeys[i];\n    result[key] = iteratee(collection[key], key, collection, i);\n  }\n\n  return result;\n}\n\nfunction toArrayStrict<T>(value: readonly T[] | T): readonly T[] {\n  if (isArray(value)) {\n    return value;\n  }\n  return [value];\n}\n\nexport function toArray<T>(value: readonly T[] | T | undefined): readonly T[] {\n  if (value === undefined) {\n    return [];\n  }\n  return toArrayStrict(value);\n}\n\nexport function resolveOutput<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject\n>(\n  mapper:\n    | Mapper<TContext, TExpressionEvent, unknown, EventObject>\n    | NonReducibleUnknown,\n  context: TContext,\n  event: TExpressionEvent,\n  self: AnyActorRef\n): unknown {\n  if (typeof mapper === 'function') {\n    return mapper({ context, event, self });\n  }\n\n  if (\n    isDevelopment &&\n    !!mapper &&\n    typeof mapper === 'object' &&\n    Object.values(mapper).some((val) => typeof val === 'function')\n  ) {\n    console.warn(\n      `Dynamically mapping values to individual properties is deprecated. Use a single function that returns the mapped object instead.\\nFound object containing properties whose values are possibly mapping functions: ${Object.entries(\n        mapper\n      )\n        .filter(([, value]) => typeof value === 'function')\n        .map(\n          ([key, value]) =>\n            `\\n - ${key}: ${(value as () => any)\n              .toString()\n              .replace(/\\n\\s*/g, '')}`\n        )\n        .join('')}`\n    );\n  }\n\n  return mapper;\n}\n\nfunction isArray(value: any): value is readonly any[] {\n  return Array.isArray(value);\n}\n\nexport function isErrorActorEvent(\n  event: AnyEventObject\n): event is ErrorActorEvent {\n  return event.type.startsWith('xstate.error.actor');\n}\n\nexport function toTransitionConfigArray(\n  configLike: SingleOrArray<AnyTransitionConfig | TransitionConfigTarget>\n): Array<AnyTransitionConfig> {\n  return toArrayStrict(configLike).map((transitionLike) => {\n    if (\n      typeof transitionLike === 'undefined' ||\n      typeof transitionLike === 'string'\n    ) {\n      return { target: transitionLike };\n    }\n\n    return transitionLike;\n  });\n}\n\nexport function normalizeTarget<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  target: SingleOrArray<string | StateNode<TContext, TEvent>> | undefined\n): ReadonlyArray<string | StateNode<TContext, TEvent>> | undefined {\n  if (target === undefined || target === TARGETLESS_KEY) {\n    return undefined;\n  }\n  return toArray(target);\n}\n\nexport function toObserver<T>(\n  nextHandler?: Observer<T> | ((value: T) => void),\n  errorHandler?: (error: any) => void,\n  completionHandler?: () => void\n): Observer<T> {\n  const isObserver = typeof nextHandler === 'object';\n  const self = isObserver ? nextHandler : undefined;\n\n  return {\n    next: (isObserver ? nextHandler.next : nextHandler)?.bind(self),\n    error: (isObserver ? nextHandler.error : errorHandler)?.bind(self),\n    complete: (isObserver ? nextHandler.complete : completionHandler)?.bind(\n      self\n    )\n  };\n}\n\nexport function createInvokeId(stateNodeId: string, index: number): string {\n  return `${index}.${stateNodeId}`;\n}\n\nexport function resolveReferencedActor(machine: AnyStateMachine, src: string) {\n  const match = src.match(/^xstate\\.invoke\\.(\\d+)\\.(.*)/)!;\n  if (!match) {\n    return machine.implementations.actors[src];\n  }\n  const [, indexStr, nodeId] = match;\n  const node = machine.getStateNodeById(nodeId);\n  const invokeConfig = node.config.invoke!;\n  return (\n    Array.isArray(invokeConfig)\n      ? invokeConfig[indexStr as any]\n      : (invokeConfig as InvokeConfig<\n          any,\n          any,\n          any,\n          any,\n          any,\n          any,\n          any, // TEmitted\n          any // TMeta\n        >)\n  ).src;\n}\n\nexport function getAllOwnEventDescriptors(snapshot: AnyMachineSnapshot) {\n  return [...new Set([...snapshot._nodes.flatMap((sn) => sn.ownEvents)])];\n}\n","import { InspectionEvent } from './inspection.ts';\nimport {\n  AnyEventObject,\n  ActorSystemInfo,\n  AnyActorRef,\n  Observer,\n  HomomorphicOmit,\n  EventObject,\n  Subscription\n} from './types.ts';\nimport { toObserver } from './utils.ts';\n\ninterface ScheduledEvent {\n  id: string;\n  event: EventObject;\n  startedAt: number; // timestamp\n  delay: number;\n  source: AnyActorRef;\n  target: AnyActorRef;\n}\n\nexport interface Clock {\n  setTimeout(fn: (...args: any[]) => void, timeout: number): any;\n  clearTimeout(id: any): void;\n}\n\ninterface Scheduler {\n  schedule(\n    source: AnyActorRef,\n    target: AnyActorRef,\n    event: EventObject,\n    delay: number,\n    id: string | undefined\n  ): void;\n  cancel(source: AnyActorRef, id: string): void;\n  cancelAll(actorRef: AnyActorRef): void;\n}\n\ntype ScheduledEventId = string & { __scheduledEventId: never };\n\nfunction createScheduledEventId(\n  actorRef: AnyActorRef,\n  id: string\n): ScheduledEventId {\n  return `${actorRef.sessionId}.${id}` as ScheduledEventId;\n}\n\nexport interface ActorSystem<T extends ActorSystemInfo> {\n  /** @internal */\n  _bookId: () => string;\n  /** @internal */\n  _register: (sessionId: string, actorRef: AnyActorRef) => string;\n  /** @internal */\n  _unregister: (actorRef: AnyActorRef) => void;\n  /** @internal */\n  _set: <K extends keyof T['actors']>(key: K, actorRef: T['actors'][K]) => void;\n  get: <K extends keyof T['actors']>(key: K) => T['actors'][K] | undefined;\n\n  inspect: (\n    observer:\n      | Observer<InspectionEvent>\n      | ((inspectionEvent: InspectionEvent) => void)\n  ) => Subscription;\n  /** @internal */\n  _sendInspectionEvent: (\n    event: HomomorphicOmit<InspectionEvent, 'rootId'>\n  ) => void;\n  /** @internal */\n  _relay: (\n    source: AnyActorRef | undefined,\n    target: AnyActorRef,\n    event: AnyEventObject\n  ) => void;\n  scheduler: Scheduler;\n  getSnapshot: () => {\n    _scheduledEvents: Record<string, ScheduledEvent>;\n  };\n  /** @internal */\n  _snapshot: {\n    _scheduledEvents: Record<ScheduledEventId, ScheduledEvent>;\n  };\n  start: () => void;\n  _clock: Clock;\n  _logger: (...args: any[]) => void;\n}\n\nexport type AnyActorSystem = ActorSystem<any>;\n\nlet idCounter = 0;\nexport function createSystem<T extends ActorSystemInfo>(\n  rootActor: AnyActorRef,\n  options: {\n    clock: Clock;\n    logger: (...args: any[]) => void;\n    snapshot?: unknown;\n  }\n): ActorSystem<T> {\n  const children = new Map<string, AnyActorRef>();\n  const keyedActors = new Map<keyof T['actors'], AnyActorRef | undefined>();\n  const reverseKeyedActors = new WeakMap<AnyActorRef, keyof T['actors']>();\n  const inspectionObservers = new Set<Observer<InspectionEvent>>();\n  const timerMap: { [id: ScheduledEventId]: number } = {};\n  const { clock, logger } = options;\n\n  const scheduler: Scheduler = {\n    schedule: (\n      source,\n      target,\n      event,\n      delay,\n      id = Math.random().toString(36).slice(2)\n    ) => {\n      const scheduledEvent: ScheduledEvent = {\n        source,\n        target,\n        event,\n        delay,\n        id,\n        startedAt: Date.now()\n      };\n      const scheduledEventId = createScheduledEventId(source, id);\n      system._snapshot._scheduledEvents[scheduledEventId] = scheduledEvent;\n\n      const timeout = clock.setTimeout(() => {\n        delete timerMap[scheduledEventId];\n        delete system._snapshot._scheduledEvents[scheduledEventId];\n\n        system._relay(source, target, event);\n      }, delay);\n\n      timerMap[scheduledEventId] = timeout;\n    },\n    cancel: (source, id: string) => {\n      const scheduledEventId = createScheduledEventId(source, id);\n      const timeout = timerMap[scheduledEventId];\n\n      delete timerMap[scheduledEventId];\n      delete system._snapshot._scheduledEvents[scheduledEventId];\n\n      if (timeout !== undefined) {\n        clock.clearTimeout(timeout);\n      }\n    },\n    cancelAll: (actorRef) => {\n      for (const scheduledEventId in system._snapshot._scheduledEvents) {\n        const scheduledEvent =\n          system._snapshot._scheduledEvents[\n            scheduledEventId as ScheduledEventId\n          ];\n        if (scheduledEvent.source === actorRef) {\n          scheduler.cancel(actorRef, scheduledEvent.id);\n        }\n      }\n    }\n  };\n  const sendInspectionEvent = (event: InspectionEvent) => {\n    if (!inspectionObservers.size) {\n      return;\n    }\n    const resolvedInspectionEvent: InspectionEvent = {\n      ...event,\n      rootId: rootActor.sessionId\n    };\n    inspectionObservers.forEach((observer) =>\n      observer.next?.(resolvedInspectionEvent)\n    );\n  };\n\n  const system: ActorSystem<T> = {\n    _snapshot: {\n      _scheduledEvents:\n        (options?.snapshot && (options.snapshot as any).scheduler) ?? {}\n    },\n    _bookId: () => `x:${idCounter++}`,\n    _register: (sessionId, actorRef) => {\n      children.set(sessionId, actorRef);\n      return sessionId;\n    },\n    _unregister: (actorRef) => {\n      children.delete(actorRef.sessionId);\n      const systemId = reverseKeyedActors.get(actorRef);\n\n      if (systemId !== undefined) {\n        keyedActors.delete(systemId);\n        reverseKeyedActors.delete(actorRef);\n      }\n    },\n    get: (systemId) => {\n      return keyedActors.get(systemId) as T['actors'][any];\n    },\n    _set: (systemId, actorRef) => {\n      const existing = keyedActors.get(systemId);\n      if (existing && existing !== actorRef) {\n        throw new Error(\n          `Actor with system ID '${systemId as string}' already exists.`\n        );\n      }\n\n      keyedActors.set(systemId, actorRef);\n      reverseKeyedActors.set(actorRef, systemId);\n    },\n    inspect: (observerOrFn) => {\n      const observer = toObserver(observerOrFn);\n      inspectionObservers.add(observer);\n\n      return {\n        unsubscribe() {\n          inspectionObservers.delete(observer);\n        }\n      };\n    },\n    _sendInspectionEvent: sendInspectionEvent as any,\n    _relay: (source, target, event) => {\n      system._sendInspectionEvent({\n        type: '@xstate.event',\n        sourceRef: source,\n        actorRef: target,\n        event\n      });\n\n      target._send(event);\n    },\n    scheduler,\n    getSnapshot: () => {\n      return {\n        _scheduledEvents: { ...system._snapshot._scheduledEvents }\n      };\n    },\n    start: () => {\n      const scheduledEvents = system._snapshot._scheduledEvents;\n      system._snapshot._scheduledEvents = {};\n      for (const scheduledId in scheduledEvents) {\n        const { source, target, event, delay, id } =\n          scheduledEvents[scheduledId as ScheduledEventId];\n        scheduler.schedule(source, target, event, delay, id);\n      }\n    },\n    _clock: clock,\n    _logger: logger\n  };\n\n  return system;\n}\n","import isDevelopment from '#is-development';\nimport { Mailbox } from './Mailbox.ts';\nimport { XSTATE_STOP } from './constants.ts';\nimport { devToolsAdapter } from './dev/index.ts';\nimport {\n  createDoneActorEvent,\n  createErrorActorEvent,\n  createInitEvent\n} from './eventUtils.ts';\nimport { reportUnhandledError } from './reportUnhandledError.ts';\nimport { symbolObservable } from './symbolObservable.ts';\nimport { AnyActorSystem, Clock, createSystem } from './system.ts';\n\n// those are needed to make JSDoc `@link` work properly\nimport type {\n  fromObservable,\n  fromEventObservable\n} from './actors/observable.ts';\nimport type { fromCallback } from './actors/callback.ts';\nimport type { fromPromise } from './actors/promise.ts';\nimport type { fromTransition } from './actors/transition.ts';\nimport type { createMachine } from './createMachine.ts';\n\nexport let executingCustomAction: boolean = false;\n\nimport type {\n  ActorScope,\n  AnyActorLogic,\n  AnyActorRef,\n  ConditionalRequired,\n  DoneActorEvent,\n  EmittedFrom,\n  EventFromLogic,\n  InputFrom,\n  IsNotNever,\n  Snapshot,\n  SnapshotFrom\n} from './types.ts';\nimport {\n  ActorOptions,\n  ActorRef,\n  EventObject,\n  InteropSubscribable,\n  Observer,\n  Subscription\n} from './types.ts';\nimport { toObserver } from './utils.ts';\n\nexport const $$ACTOR_TYPE = 1;\n\n// those values are currently used by @xstate/react directly so it's important to keep the assigned values in sync\nexport enum ProcessingStatus {\n  NotStarted = 0,\n  Running = 1,\n  Stopped = 2\n}\n\nconst defaultOptions = {\n  clock: {\n    setTimeout: (fn, ms) => {\n      return setTimeout(fn, ms);\n    },\n    clearTimeout: (id) => {\n      return clearTimeout(id);\n    }\n  } as Clock,\n  logger: console.log.bind(console),\n  devTools: false\n};\n\n/**\n * An Actor is a running process that can receive events, send events and change\n * its behavior based on the events it receives, which can cause effects outside\n * of the actor. When you run a state machine, it becomes an actor.\n */\nexport class Actor<TLogic extends AnyActorLogic>\n  implements\n    ActorRef<SnapshotFrom<TLogic>, EventFromLogic<TLogic>, EmittedFrom<TLogic>>\n{\n  /** The current internal state of the actor. */\n  private _snapshot!: SnapshotFrom<TLogic>;\n  /**\n   * The clock that is responsible for setting and clearing timeouts, such as\n   * delayed events and transitions.\n   */\n  public clock: Clock;\n  public options: Readonly<ActorOptions<TLogic>>;\n\n  /** The unique identifier for this actor relative to its parent. */\n  public id: string;\n\n  private mailbox: Mailbox<EventFromLogic<TLogic>> = new Mailbox(\n    this._process.bind(this)\n  );\n\n  private observers: Set<Observer<SnapshotFrom<TLogic>>> = new Set();\n  private eventListeners: Map<\n    string,\n    Set<(emittedEvent: EmittedFrom<TLogic>) => void>\n  > = new Map();\n  private logger: (...args: any[]) => void;\n\n  /** @internal */\n  public _processingStatus: ProcessingStatus = ProcessingStatus.NotStarted;\n\n  // Actor Ref\n  public _parent?: AnyActorRef;\n  /** @internal */\n  public _syncSnapshot?: boolean;\n  public ref: ActorRef<\n    SnapshotFrom<TLogic>,\n    EventFromLogic<TLogic>,\n    EmittedFrom<TLogic>\n  >;\n  // TODO: add typings for system\n  private _actorScope: ActorScope<\n    SnapshotFrom<TLogic>,\n    EventFromLogic<TLogic>,\n    AnyActorSystem,\n    EmittedFrom<TLogic>\n  >;\n\n  private _systemId: string | undefined;\n\n  /** The globally unique process ID for this invocation. */\n  public sessionId: string;\n\n  /** The system to which this actor belongs. */\n  public system: AnyActorSystem;\n  private _doneEvent?: DoneActorEvent;\n\n  public src: string | AnyActorLogic;\n\n  /**\n   * Creates a new actor instance for the given logic with the provided options,\n   * if any.\n   *\n   * @param logic The logic to create an actor from\n   * @param options Actor options\n   */\n  constructor(\n    public logic: TLogic,\n    options?: ActorOptions<TLogic>\n  ) {\n    const resolvedOptions = {\n      ...defaultOptions,\n      ...options\n    };\n\n    const { clock, logger, parent, syncSnapshot, id, systemId, inspect } =\n      resolvedOptions;\n\n    this.system = parent\n      ? parent.system\n      : createSystem(this, {\n          clock,\n          logger\n        });\n\n    if (inspect && !parent) {\n      // Always inspect at the system-level\n      this.system.inspect(toObserver(inspect));\n    }\n\n    this.sessionId = this.system._bookId();\n    this.id = id ?? this.sessionId;\n    this.logger = options?.logger ?? this.system._logger;\n    this.clock = options?.clock ?? this.system._clock;\n    this._parent = parent;\n    this._syncSnapshot = syncSnapshot;\n    this.options = resolvedOptions as ActorOptions<TLogic> &\n      typeof defaultOptions;\n    this.src = resolvedOptions.src ?? logic;\n    this.ref = this;\n    this._actorScope = {\n      self: this,\n      id: this.id,\n      sessionId: this.sessionId,\n      logger: this.logger,\n      defer: (fn) => {\n        this._deferred.push(fn);\n      },\n      system: this.system,\n      stopChild: (child) => {\n        if (child._parent !== this) {\n          throw new Error(\n            `Cannot stop child actor ${child.id} of ${this.id} because it is not a child`\n          );\n        }\n        (child as any)._stop();\n      },\n      emit: (emittedEvent) => {\n        const listeners = this.eventListeners.get(emittedEvent.type);\n        const wildcardListener = this.eventListeners.get('*');\n        if (!listeners && !wildcardListener) {\n          return;\n        }\n        const allListeners = [\n          ...(listeners ? listeners.values() : []),\n          ...(wildcardListener ? wildcardListener.values() : [])\n        ];\n        for (const handler of allListeners) {\n          handler(emittedEvent);\n        }\n      },\n      actionExecutor: (action) => {\n        const exec = () => {\n          this._actorScope.system._sendInspectionEvent({\n            type: '@xstate.action',\n            actorRef: this,\n            action: {\n              type: action.type,\n              params: action.params\n            }\n          });\n          if (!action.exec) {\n            return;\n          }\n          const saveExecutingCustomAction = executingCustomAction;\n          try {\n            executingCustomAction = true;\n            action.exec(action.info, action.params);\n          } finally {\n            executingCustomAction = saveExecutingCustomAction;\n          }\n        };\n        if (this._processingStatus === ProcessingStatus.Running) {\n          exec();\n        } else {\n          this._deferred.push(exec);\n        }\n      }\n    };\n\n    // Ensure that the send method is bound to this Actor instance\n    // if destructured\n    this.send = this.send.bind(this);\n\n    this.system._sendInspectionEvent({\n      type: '@xstate.actor',\n      actorRef: this\n    });\n\n    if (systemId) {\n      this._systemId = systemId;\n      this.system._set(systemId, this);\n    }\n\n    this._initState(options?.snapshot ?? options?.state);\n\n    if (systemId && (this._snapshot as any).status !== 'active') {\n      this.system._unregister(this);\n    }\n  }\n\n  private _initState(persistedState?: Snapshot<unknown>) {\n    try {\n      this._snapshot = persistedState\n        ? this.logic.restoreSnapshot\n          ? this.logic.restoreSnapshot(persistedState, this._actorScope)\n          : persistedState\n        : this.logic.getInitialSnapshot(this._actorScope, this.options?.input);\n    } catch (err) {\n      // if we get here then it means that we assign a value to this._snapshot that is not of the correct type\n      // we can't get the true `TSnapshot & { status: 'error'; }`, it's impossible\n      // so right now this is a lie of sorts\n      this._snapshot = {\n        status: 'error',\n        output: undefined,\n        error: err\n      } as any;\n    }\n  }\n\n  // array of functions to defer\n  private _deferred: Array<() => void> = [];\n\n  private update(snapshot: SnapshotFrom<TLogic>, event: EventObject): void {\n    // Update state\n    this._snapshot = snapshot;\n\n    // Execute deferred effects\n    let deferredFn: (typeof this._deferred)[number] | undefined;\n\n    while ((deferredFn = this._deferred.shift())) {\n      try {\n        deferredFn();\n      } catch (err) {\n        // this error can only be caught when executing *initial* actions\n        // it's the only time when we call actions provided by the user through those deferreds\n        // when the actor is already running we always execute them synchronously while transitioning\n        // no \"builtin deferred\" should actually throw an error since they are either safe\n        // or the control flow is passed through the mailbox and errors should be caught by the `_process` used by the mailbox\n        this._deferred.length = 0;\n        this._snapshot = {\n          ...(snapshot as any),\n          status: 'error',\n          error: err\n        };\n      }\n    }\n\n    switch ((this._snapshot as any).status) {\n      case 'active':\n        for (const observer of this.observers) {\n          try {\n            observer.next?.(snapshot);\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n        }\n        break;\n      case 'done':\n        // next observers are meant to be notified about done snapshots\n        // this can be seen as something that is different from how observable work\n        // but with observables `complete` callback is called without any arguments\n        // it's more ergonomic for XState to treat a done snapshot as a \"next\" value\n        // and the completion event as something that is separate,\n        // something that merely follows emitting that done snapshot\n        for (const observer of this.observers) {\n          try {\n            observer.next?.(snapshot);\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n        }\n\n        this._stopProcedure();\n        this._complete();\n        this._doneEvent = createDoneActorEvent(\n          this.id,\n          (this._snapshot as any).output\n        );\n        if (this._parent) {\n          this.system._relay(this, this._parent, this._doneEvent);\n        }\n\n        break;\n      case 'error':\n        this._error((this._snapshot as any).error);\n        break;\n    }\n    this.system._sendInspectionEvent({\n      type: '@xstate.snapshot',\n      actorRef: this,\n      event,\n      snapshot\n    });\n  }\n\n  /**\n   * Subscribe an observer to an actor’s snapshot values.\n   *\n   * @remarks\n   * The observer will receive the actor’s snapshot value when it is emitted.\n   * The observer can be:\n   *\n   * - A plain function that receives the latest snapshot, or\n   * - An observer object whose `.next(snapshot)` method receives the latest\n   *   snapshot\n   *\n   * @example\n   *\n   * ```ts\n   * // Observer as a plain function\n   * const subscription = actor.subscribe((snapshot) => {\n   *   console.log(snapshot);\n   * });\n   * ```\n   *\n   * @example\n   *\n   * ```ts\n   * // Observer as an object\n   * const subscription = actor.subscribe({\n   *   next(snapshot) {\n   *     console.log(snapshot);\n   *   },\n   *   error(err) {\n   *     // ...\n   *   },\n   *   complete() {\n   *     // ...\n   *   }\n   * });\n   * ```\n   *\n   * The return value of `actor.subscribe(observer)` is a subscription object\n   * that has an `.unsubscribe()` method. You can call\n   * `subscription.unsubscribe()` to unsubscribe the observer:\n   *\n   * @example\n   *\n   * ```ts\n   * const subscription = actor.subscribe((snapshot) => {\n   *   // ...\n   * });\n   *\n   * // Unsubscribe the observer\n   * subscription.unsubscribe();\n   * ```\n   *\n   * When the actor is stopped, all of its observers will automatically be\n   * unsubscribed.\n   *\n   * @param observer - Either a plain function that receives the latest\n   *   snapshot, or an observer object whose `.next(snapshot)` method receives\n   *   the latest snapshot\n   */\n  public subscribe(observer: Observer<SnapshotFrom<TLogic>>): Subscription;\n  public subscribe(\n    nextListener?: (snapshot: SnapshotFrom<TLogic>) => void,\n    errorListener?: (error: any) => void,\n    completeListener?: () => void\n  ): Subscription;\n  public subscribe(\n    nextListenerOrObserver?:\n      | ((snapshot: SnapshotFrom<TLogic>) => void)\n      | Observer<SnapshotFrom<TLogic>>,\n    errorListener?: (error: any) => void,\n    completeListener?: () => void\n  ): Subscription {\n    const observer = toObserver(\n      nextListenerOrObserver,\n      errorListener,\n      completeListener\n    );\n\n    if (this._processingStatus !== ProcessingStatus.Stopped) {\n      this.observers.add(observer);\n    } else {\n      switch ((this._snapshot as any).status) {\n        case 'done':\n          try {\n            observer.complete?.();\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n          break;\n        case 'error': {\n          const err = (this._snapshot as any).error;\n          if (!observer.error) {\n            reportUnhandledError(err);\n          } else {\n            try {\n              observer.error(err);\n            } catch (err) {\n              reportUnhandledError(err);\n            }\n          }\n          break;\n        }\n      }\n    }\n\n    return {\n      unsubscribe: () => {\n        this.observers.delete(observer);\n      }\n    };\n  }\n\n  public on<TType extends EmittedFrom<TLogic>['type'] | '*'>(\n    type: TType,\n    handler: (\n      emitted: EmittedFrom<TLogic> &\n        (TType extends '*' ? unknown : { type: TType })\n    ) => void\n  ): Subscription {\n    let listeners = this.eventListeners.get(type);\n    if (!listeners) {\n      listeners = new Set();\n      this.eventListeners.set(type, listeners);\n    }\n    const wrappedHandler = handler.bind(undefined);\n    listeners.add(wrappedHandler);\n\n    return {\n      unsubscribe: () => {\n        listeners.delete(wrappedHandler);\n      }\n    };\n  }\n\n  /** Starts the Actor from the initial state */\n  public start(): this {\n    if (this._processingStatus === ProcessingStatus.Running) {\n      // Do not restart the service if it is already started\n      return this;\n    }\n\n    if (this._syncSnapshot) {\n      this.subscribe({\n        next: (snapshot: Snapshot<unknown>) => {\n          if (snapshot.status === 'active') {\n            this.system._relay(this, this._parent!, {\n              type: `xstate.snapshot.${this.id}`,\n              snapshot\n            });\n          }\n        },\n        error: () => {}\n      });\n    }\n\n    this.system._register(this.sessionId, this);\n    if (this._systemId) {\n      this.system._set(this._systemId, this);\n    }\n    this._processingStatus = ProcessingStatus.Running;\n\n    // TODO: this isn't correct when rehydrating\n    const initEvent = createInitEvent(this.options.input);\n\n    this.system._sendInspectionEvent({\n      type: '@xstate.event',\n      sourceRef: this._parent,\n      actorRef: this,\n      event: initEvent\n    });\n\n    const status = (this._snapshot as any).status;\n\n    switch (status) {\n      case 'done':\n        // a state machine can be \"done\" upon initialization (it could reach a final state using initial microsteps)\n        // we still need to complete observers, flush deferreds etc\n        this.update(\n          this._snapshot,\n          initEvent as unknown as EventFromLogic<TLogic>\n        );\n        // TODO: rethink cleanup of observers, mailbox, etc\n        return this;\n      case 'error':\n        this._error((this._snapshot as any).error);\n        return this;\n    }\n\n    if (!this._parent) {\n      this.system.start();\n    }\n\n    if (this.logic.start) {\n      try {\n        this.logic.start(this._snapshot, this._actorScope);\n      } catch (err) {\n        this._snapshot = {\n          ...(this._snapshot as any),\n          status: 'error',\n          error: err\n        };\n        this._error(err);\n        return this;\n      }\n    }\n\n    // TODO: this notifies all subscribers but usually this is redundant\n    // there is no real change happening here\n    // we need to rethink if this needs to be refactored\n    this.update(this._snapshot, initEvent as unknown as EventFromLogic<TLogic>);\n\n    if (this.options.devTools) {\n      this.attachDevTools();\n    }\n\n    this.mailbox.start();\n\n    return this;\n  }\n\n  private _process(event: EventFromLogic<TLogic>) {\n    let nextState;\n    let caughtError;\n    try {\n      nextState = this.logic.transition(\n        this._snapshot,\n        event,\n        this._actorScope\n      );\n    } catch (err) {\n      // we wrap it in a box so we can rethrow it later even if falsy value gets caught here\n      caughtError = { err };\n    }\n\n    if (caughtError) {\n      const { err } = caughtError;\n\n      this._snapshot = {\n        ...(this._snapshot as any),\n        status: 'error',\n        error: err\n      };\n      this._error(err);\n      return;\n    }\n\n    this.update(nextState, event);\n    if (event.type === XSTATE_STOP) {\n      this._stopProcedure();\n      this._complete();\n    }\n  }\n\n  private _stop(): this {\n    if (this._processingStatus === ProcessingStatus.Stopped) {\n      return this;\n    }\n    this.mailbox.clear();\n    if (this._processingStatus === ProcessingStatus.NotStarted) {\n      this._processingStatus = ProcessingStatus.Stopped;\n      return this;\n    }\n    this.mailbox.enqueue({ type: XSTATE_STOP } as any);\n\n    return this;\n  }\n\n  /** Stops the Actor and unsubscribe all listeners. */\n  public stop(): this {\n    if (this._parent) {\n      throw new Error('A non-root actor cannot be stopped directly.');\n    }\n    return this._stop();\n  }\n  private _complete(): void {\n    for (const observer of this.observers) {\n      try {\n        observer.complete?.();\n      } catch (err) {\n        reportUnhandledError(err);\n      }\n    }\n    this.observers.clear();\n  }\n  private _reportError(err: unknown): void {\n    if (!this.observers.size) {\n      if (!this._parent) {\n        reportUnhandledError(err);\n      }\n      return;\n    }\n    let reportError = false;\n\n    for (const observer of this.observers) {\n      const errorListener = observer.error;\n      reportError ||= !errorListener;\n      try {\n        errorListener?.(err);\n      } catch (err2) {\n        reportUnhandledError(err2);\n      }\n    }\n    this.observers.clear();\n    if (reportError) {\n      reportUnhandledError(err);\n    }\n  }\n  private _error(err: unknown): void {\n    this._stopProcedure();\n    this._reportError(err);\n    if (this._parent) {\n      this.system._relay(\n        this,\n        this._parent,\n        createErrorActorEvent(this.id, err)\n      );\n    }\n  }\n  // TODO: atm children don't belong entirely to the actor so\n  // in a way - it's not even super aware of them\n  // so we can't stop them from here but we really should!\n  // right now, they are being stopped within the machine's transition\n  // but that could throw and leave us with \"orphaned\" active actors\n  private _stopProcedure(): this {\n    if (this._processingStatus !== ProcessingStatus.Running) {\n      // Actor already stopped; do nothing\n      return this;\n    }\n\n    // Cancel all delayed events\n    this.system.scheduler.cancelAll(this);\n\n    // TODO: mailbox.reset\n    this.mailbox.clear();\n    // TODO: after `stop` we must prepare ourselves for receiving events again\n    // events sent *after* stop signal must be queued\n    // it seems like this should be the common behavior for all of our consumers\n    // so perhaps this should be unified somehow for all of them\n    this.mailbox = new Mailbox(this._process.bind(this));\n\n    this._processingStatus = ProcessingStatus.Stopped;\n    this.system._unregister(this);\n\n    return this;\n  }\n\n  /** @internal */\n  public _send(event: EventFromLogic<TLogic>) {\n    if (this._processingStatus === ProcessingStatus.Stopped) {\n      // do nothing\n      if (isDevelopment) {\n        const eventString = JSON.stringify(event);\n\n        console.warn(\n          `Event \"${event.type}\" was sent to stopped actor \"${this.id} (${this.sessionId})\". This actor has already reached its final state, and will not transition.\\nEvent: ${eventString}`\n        );\n      }\n      return;\n    }\n\n    this.mailbox.enqueue(event);\n  }\n\n  /**\n   * Sends an event to the running Actor to trigger a transition.\n   *\n   * @param event The event to send\n   */\n  public send(event: EventFromLogic<TLogic>) {\n    if (isDevelopment && typeof event === 'string') {\n      throw new Error(\n        `Only event objects may be sent to actors; use .send({ type: \"${event}\" }) instead`\n      );\n    }\n    this.system._relay(undefined, this, event);\n  }\n\n  private attachDevTools(): void {\n    const { devTools } = this.options;\n    if (devTools) {\n      const resolvedDevToolsAdapter =\n        typeof devTools === 'function' ? devTools : devToolsAdapter;\n\n      resolvedDevToolsAdapter(this);\n    }\n  }\n  public toJSON() {\n    return {\n      xstate$$type: $$ACTOR_TYPE,\n      id: this.id\n    };\n  }\n\n  /**\n   * Obtain the internal state of the actor, which can be persisted.\n   *\n   * @remarks\n   * The internal state can be persisted from any actor, not only machines.\n   *\n   * Note that the persisted state is not the same as the snapshot from\n   * {@link Actor.getSnapshot}. Persisted state represents the internal state of\n   * the actor, while snapshots represent the actor's last emitted value.\n   *\n   * Can be restored with {@link ActorOptions.state}\n   * @see https://stately.ai/docs/persistence\n   */\n  public getPersistedSnapshot(): Snapshot<unknown>;\n  public getPersistedSnapshot(options?: unknown): Snapshot<unknown> {\n    return this.logic.getPersistedSnapshot(this._snapshot, options);\n  }\n\n  public [symbolObservable](): InteropSubscribable<SnapshotFrom<TLogic>> {\n    return this;\n  }\n\n  /**\n   * Read an actor’s snapshot synchronously.\n   *\n   * @remarks\n   * The snapshot represent an actor's last emitted value.\n   *\n   * When an actor receives an event, its internal state may change. An actor\n   * may emit a snapshot when a state transition occurs.\n   *\n   * Note that some actors, such as callback actors generated with\n   * `fromCallback`, will not emit snapshots.\n   * @see {@link Actor.subscribe} to subscribe to an actor’s snapshot values.\n   * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).\n   */\n  public getSnapshot(): SnapshotFrom<TLogic> {\n    if (isDevelopment && !this._snapshot) {\n      throw new Error(\n        `Snapshot can't be read while the actor initializes itself`\n      );\n    }\n    return this._snapshot;\n  }\n}\n\nexport type RequiredActorOptionsKeys<TLogic extends AnyActorLogic> =\n  undefined extends InputFrom<TLogic> ? never : 'input';\n\n/**\n * Creates a new actor instance for the given actor logic with the provided\n * options, if any.\n *\n * @remarks\n * When you create an actor from actor logic via `createActor(logic)`, you\n * implicitly create an actor system where the created actor is the root actor.\n * Any actors spawned from this root actor and its descendants are part of that\n * actor system.\n * @example\n *\n * ```ts\n * import { createActor } from 'xstate';\n * import { someActorLogic } from './someActorLogic.ts';\n *\n * // Creating the actor, which implicitly creates an actor system with itself as the root actor\n * const actor = createActor(someActorLogic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n *\n * // Actors must be started by calling `actor.start()`, which will also start the actor system.\n * actor.start();\n *\n * // Actors can receive events\n * actor.send({ type: 'someEvent' });\n *\n * // You can stop root actors by calling `actor.stop()`, which will also stop the actor system and all actors in that system.\n * actor.stop();\n * ```\n *\n * @param logic - The actor logic to create an actor from. For a state machine\n *   actor logic creator, see {@link createMachine}. Other actor logic creators\n *   include {@link fromCallback}, {@link fromEventObservable},\n *   {@link fromObservable}, {@link fromPromise}, and {@link fromTransition}.\n * @param options - Actor options\n */\nexport function createActor<TLogic extends AnyActorLogic>(\n  logic: TLogic,\n  ...[options]: ConditionalRequired<\n    [\n      options?: ActorOptions<TLogic> & {\n        [K in RequiredActorOptionsKeys<TLogic>]: unknown;\n      }\n    ],\n    IsNotNever<RequiredActorOptionsKeys<TLogic>>\n  >\n): Actor<TLogic> {\n  return new Actor(logic, options);\n}\n\n/**\n * Creates a new Interpreter instance for the given machine with the provided\n * options, if any.\n *\n * @deprecated Use `createActor` instead\n * @alias\n */\nexport const interpret = createActor;\n\n/**\n * @deprecated Use `Actor` instead.\n * @alias\n */\nexport type Interpreter = typeof Actor;\n","import isDevelopment from '#is-development';\nimport {\n  AnyActorScope,\n  AnyMachineSnapshot,\n  EventObject,\n  MachineContext,\n  ActionArgs,\n  ParameterizedObject,\n  BuiltinActionResolution\n} from '../types.ts';\n\ntype ResolvableSendId<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n> =\n  | string\n  | ((\n      args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n      params: TParams\n    ) => string);\n\nfunction resolveCancel(\n  _: AnyActorScope,\n  snapshot: AnyMachineSnapshot,\n  actionArgs: ActionArgs<any, any, any>,\n  actionParams: ParameterizedObject['params'] | undefined,\n  { sendId }: { sendId: ResolvableSendId<any, any, any, any> }\n): BuiltinActionResolution {\n  const resolvedSendId =\n    typeof sendId === 'function' ? sendId(actionArgs, actionParams) : sendId;\n  return [snapshot, { sendId: resolvedSendId }, undefined];\n}\n\nfunction executeCancel(actorScope: AnyActorScope, params: { sendId: string }) {\n  actorScope.defer(() => {\n    actorScope.system.scheduler.cancel(actorScope.self, params.sendId);\n  });\n}\n\nexport interface CancelAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n> {\n  (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams): void;\n}\n\n/**\n * Cancels a delayed `sendTo(...)` action that is waiting to be executed. The\n * canceled `sendTo(...)` action will not send its event or execute, unless the\n * `delay` has already elapsed before `cancel(...)` is called.\n *\n * @example\n *\n * ```ts\n * import { createMachine, sendTo, cancel } from 'xstate';\n *\n * const machine = createMachine({\n *   // ...\n *   on: {\n *     sendEvent: {\n *       actions: sendTo(\n *         'some-actor',\n *         { type: 'someEvent' },\n *         {\n *           id: 'some-id',\n *           delay: 1000\n *         }\n *       )\n *     },\n *     cancelEvent: {\n *       actions: cancel('some-id')\n *     }\n *   }\n * });\n * ```\n *\n * @param sendId The `id` of the `sendTo(...)` action to cancel.\n */\nexport function cancel<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n>(\n  sendId: ResolvableSendId<TContext, TExpressionEvent, TParams, TEvent>\n): CancelAction<TContext, TExpressionEvent, TParams, TEvent> {\n  function cancel(\n    _args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n    _params: TParams\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  cancel.type = 'xstate.cancel';\n  cancel.sendId = sendId;\n\n  cancel.resolve = resolveCancel;\n  cancel.execute = executeCancel;\n\n  return cancel;\n}\n","import isDevelopment from '#is-development';\nimport { cloneMachineSnapshot } from '../State.ts';\nimport { ProcessingStatus, createActor } from '../createActor.ts';\nimport {\n  ActionArgs,\n  ActionFunction,\n  AnyActorLogic,\n  AnyActorRef,\n  AnyActorScope,\n  AnyMachineSnapshot,\n  ConditionalRequired,\n  EventObject,\n  InputFrom,\n  IsLiteralString,\n  IsNotNever,\n  MachineContext,\n  Mapper,\n  ParameterizedObject,\n  ProvidedActor,\n  RequiredActorOptions,\n  BuiltinActionResolution,\n  UnifiedArg\n} from '../types.ts';\nimport { resolveReferencedActor } from '../utils.ts';\n\ntype ResolvableActorId<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TId extends string | undefined\n> = TId | ((args: UnifiedArg<TContext, TExpressionEvent, TEvent>) => TId);\n\nfunction resolveSpawn(\n  actorScope: AnyActorScope,\n  snapshot: AnyMachineSnapshot,\n  actionArgs: ActionArgs<any, any, any>,\n  _actionParams: ParameterizedObject['params'] | undefined,\n  {\n    id,\n    systemId,\n    src,\n    input,\n    syncSnapshot\n  }: {\n    id: ResolvableActorId<MachineContext, EventObject, EventObject, string>;\n    systemId: string | undefined;\n    src: AnyActorLogic | string;\n    input?: unknown;\n    syncSnapshot: boolean;\n  }\n): BuiltinActionResolution {\n  const logic =\n    typeof src === 'string'\n      ? resolveReferencedActor(snapshot.machine, src)\n      : src;\n  const resolvedId = typeof id === 'function' ? id(actionArgs) : id;\n  let actorRef: AnyActorRef | undefined;\n  let resolvedInput: unknown | undefined = undefined;\n\n  if (logic) {\n    resolvedInput =\n      typeof input === 'function'\n        ? input({\n            context: snapshot.context,\n            event: actionArgs.event,\n            self: actorScope.self\n          })\n        : input;\n    actorRef = createActor(logic, {\n      id: resolvedId,\n      src,\n      parent: actorScope.self,\n      syncSnapshot,\n      systemId,\n      input: resolvedInput\n    });\n  }\n\n  if (isDevelopment && !actorRef) {\n    console.warn(\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions,@typescript-eslint/no-base-to-string\n      `Actor type '${src}' not found in machine '${actorScope.id}'.`\n    );\n  }\n  return [\n    cloneMachineSnapshot(snapshot, {\n      children: {\n        ...snapshot.children,\n        [resolvedId]: actorRef!\n      }\n    }),\n    {\n      id,\n      systemId,\n      actorRef,\n      src,\n      input: resolvedInput\n    },\n    undefined\n  ];\n}\n\nfunction executeSpawn(\n  actorScope: AnyActorScope,\n  { actorRef }: { id: string; actorRef: AnyActorRef }\n) {\n  if (!actorRef) {\n    return;\n  }\n\n  actorScope.defer(() => {\n    if (actorRef._processingStatus === ProcessingStatus.Stopped) {\n      return;\n    }\n    actorRef.start();\n  });\n}\n\nexport interface SpawnAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> {\n  (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams): void;\n  _out_TActor?: TActor;\n}\n\ninterface SpawnActionOptions<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> {\n  id?: ResolvableActorId<TContext, TExpressionEvent, TEvent, TActor['id']>;\n  systemId?: string;\n  input?:\n    | Mapper<TContext, TEvent, InputFrom<TActor['logic']>, TEvent>\n    | InputFrom<TActor['logic']>;\n  syncSnapshot?: boolean;\n}\n\ntype DistributeActors<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> =\n  | (TActor extends any\n      ? ConditionalRequired<\n          [\n            src: TActor['src'],\n            options?: SpawnActionOptions<\n              TContext,\n              TExpressionEvent,\n              TEvent,\n              TActor\n            > & {\n              [K in RequiredActorOptions<TActor>]: unknown;\n            }\n          ],\n          IsNotNever<RequiredActorOptions<TActor>>\n        >\n      : never)\n  | [\n      src: AnyActorLogic,\n      options?: SpawnActionOptions<\n        TContext,\n        TExpressionEvent,\n        TEvent,\n        ProvidedActor\n      > & { id?: never }\n    ];\n\ntype SpawnArguments<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> =\n  IsLiteralString<TActor['src']> extends true\n    ? DistributeActors<TContext, TExpressionEvent, TEvent, TActor>\n    : [\n        src: string | AnyActorLogic,\n        options?: {\n          id?: ResolvableActorId<TContext, TExpressionEvent, TEvent, string>;\n          systemId?: string;\n          input?: unknown;\n          syncSnapshot?: boolean;\n        }\n      ];\n\nexport function spawnChild<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n>(\n  ...[\n    src,\n    { id, systemId, input, syncSnapshot = false } = {} as any\n  ]: SpawnArguments<TContext, TExpressionEvent, TEvent, TActor>\n): ActionFunction<\n  TContext,\n  TExpressionEvent,\n  TEvent,\n  TParams,\n  TActor,\n  never,\n  never,\n  never,\n  never\n> {\n  function spawnChild(\n    _args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n    _params: TParams\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  spawnChild.type = 'xstate.spawnChild';\n  spawnChild.id = id;\n  spawnChild.systemId = systemId;\n  spawnChild.src = src;\n  spawnChild.input = input;\n  spawnChild.syncSnapshot = syncSnapshot;\n\n  spawnChild.resolve = resolveSpawn;\n  spawnChild.execute = executeSpawn;\n\n  return spawnChild;\n}\n","import isDevelopment from '#is-development';\nimport { cloneMachineSnapshot } from '../State.ts';\nimport { ProcessingStatus } from '../createActor.ts';\nimport {\n  ActionArgs,\n  AnyActorRef,\n  AnyActorScope,\n  AnyMachineSnapshot,\n  EventObject,\n  MachineContext,\n  ParameterizedObject,\n  BuiltinActionResolution\n} from '../types.ts';\n\ntype ResolvableActorRef<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n> =\n  | string\n  | AnyActorRef\n  | ((\n      args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n      params: TParams\n    ) => AnyActorRef | string);\n\nfunction resolveStop(\n  _: AnyActorScope,\n  snapshot: AnyMachineSnapshot,\n  args: ActionArgs<any, any, any>,\n  actionParams: ParameterizedObject['params'] | undefined,\n  { actorRef }: { actorRef: ResolvableActorRef<any, any, any, any> }\n): BuiltinActionResolution {\n  const actorRefOrString =\n    typeof actorRef === 'function' ? actorRef(args, actionParams) : actorRef;\n  const resolvedActorRef: AnyActorRef | undefined =\n    typeof actorRefOrString === 'string'\n      ? snapshot.children[actorRefOrString]\n      : actorRefOrString;\n\n  let children = snapshot.children;\n  if (resolvedActorRef) {\n    children = { ...children };\n    delete children[resolvedActorRef.id];\n  }\n  return [\n    cloneMachineSnapshot(snapshot, {\n      children\n    }),\n    resolvedActorRef,\n    undefined\n  ];\n}\nfunction executeStop(\n  actorScope: AnyActorScope,\n  actorRef: AnyActorRef | undefined\n) {\n  if (!actorRef) {\n    return;\n  }\n\n  // we need to eagerly unregister it here so a new actor with the same systemId can be registered immediately\n  // since we defer actual stopping of the actor but we don't defer actor creations (and we can't do that)\n  // this could throw on `systemId` collision, for example, when dealing with reentering transitions\n  actorScope.system._unregister(actorRef);\n\n  // this allows us to prevent an actor from being started if it gets stopped within the same macrostep\n  // this can happen, for example, when the invoking state is being exited immediately by an always transition\n  if (actorRef._processingStatus !== ProcessingStatus.Running) {\n    actorScope.stopChild(actorRef);\n    return;\n  }\n  // stopping a child enqueues a stop event in the child actor's mailbox\n  // we need for all of the already enqueued events to be processed before we stop the child\n  // the parent itself might want to send some events to a child (for example from exit actions on the invoking state)\n  // and we don't want to ignore those events\n  actorScope.defer(() => {\n    actorScope.stopChild(actorRef);\n  });\n}\n\nexport interface StopAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n> {\n  (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams): void;\n}\n\n/**\n * Stops a child actor.\n *\n * @param actorRef The actor to stop.\n */\nexport function stopChild<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n>(\n  actorRef: ResolvableActorRef<TContext, TExpressionEvent, TParams, TEvent>\n): StopAction<TContext, TExpressionEvent, TParams, TEvent> {\n  function stop(\n    _args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n    _params: TParams\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  stop.type = 'xstate.stopChild';\n  stop.actorRef = actorRef;\n\n  stop.resolve = resolveStop;\n  stop.execute = executeStop;\n\n  return stop;\n}\n\n/**\n * Stops a child actor.\n *\n * @deprecated Use `stopChild(...)` instead\n * @alias\n */\nexport const stop = stopChild;\n","import isDevelopment from '#is-development';\nimport type {\n  EventObject,\n  StateValue,\n  MachineContext,\n  ParameterizedObject,\n  AnyMachineSnapshot,\n  NoRequiredParams,\n  WithDynamicParams,\n  Identity,\n  Elements,\n  DoNotInfer\n} from './types.ts';\nimport { isStateId } from './stateUtils.ts';\n\ntype SingleGuardArg<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TGuardArg\n> = [TGuardArg] extends [{ type: string }]\n  ? Identity<TGuardArg>\n  : [TGuardArg] extends [string]\n    ? TGuardArg\n    : GuardPredicate<TContext, TExpressionEvent, TParams, ParameterizedObject>;\n\ntype NormalizeGuardArg<TGuardArg> = TGuardArg extends { type: string }\n  ? Identity<TGuardArg> & { params: unknown }\n  : TGuardArg extends string\n    ? { type: TGuardArg; params: undefined }\n    : '_out_TGuard' extends keyof TGuardArg\n      ? TGuardArg['_out_TGuard'] & ParameterizedObject\n      : never;\n\ntype NormalizeGuardArgArray<TArg extends unknown[]> = Elements<{\n  [K in keyof TArg]: NormalizeGuardArg<TArg[K]>;\n}>;\n\nexport type GuardPredicate<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TGuard extends ParameterizedObject\n> = {\n  (args: GuardArgs<TContext, TExpressionEvent>, params: TParams): boolean;\n  _out_TGuard?: TGuard;\n};\n\nexport interface GuardArgs<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject\n> {\n  context: TContext;\n  event: TExpressionEvent;\n}\n\nexport type Guard<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TGuard extends ParameterizedObject\n> =\n  | NoRequiredParams<TGuard>\n  | WithDynamicParams<TContext, TExpressionEvent, TGuard>\n  | GuardPredicate<TContext, TExpressionEvent, TParams, TGuard>;\n\nexport type UnknownGuard = UnknownReferencedGuard | UnknownInlineGuard;\n\ntype UnknownReferencedGuard = Guard<\n  MachineContext,\n  EventObject,\n  ParameterizedObject['params'],\n  ParameterizedObject\n>;\n\ntype UnknownInlineGuard = Guard<\n  MachineContext,\n  EventObject,\n  undefined,\n  ParameterizedObject\n>;\n\ninterface BuiltinGuard {\n  (): boolean;\n  check: (\n    snapshot: AnyMachineSnapshot,\n    guardArgs: GuardArgs<any, any>,\n    params: unknown\n  ) => boolean;\n}\n\nfunction checkStateIn(\n  snapshot: AnyMachineSnapshot,\n  _: GuardArgs<any, any>,\n  { stateValue }: { stateValue: StateValue }\n) {\n  if (typeof stateValue === 'string' && isStateId(stateValue)) {\n    const target = snapshot.machine.getStateNodeById(stateValue);\n    return snapshot._nodes.some((sn) => sn === target);\n  }\n\n  return snapshot.matches(stateValue);\n}\n\nexport function stateIn<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined\n>(\n  stateValue: StateValue\n): GuardPredicate<\n  TContext,\n  TExpressionEvent,\n  TParams,\n  any // TODO: recheck if we could replace this with something better here\n> {\n  function stateIn() {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n    return false;\n  }\n\n  stateIn.check = checkStateIn;\n  stateIn.stateValue = stateValue;\n\n  return stateIn;\n}\n\nfunction checkNot(\n  snapshot: AnyMachineSnapshot,\n  { context, event }: GuardArgs<any, any>,\n  { guards }: { guards: readonly UnknownGuard[] }\n) {\n  return !evaluateGuard(guards[0], context, event, snapshot);\n}\n\n/**\n * Higher-order guard that evaluates to `true` if the `guard` passed to it\n * evaluates to `false`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, not } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => false\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: not('someNamedGuard'),\n *       actions: () => {\n *         // will be executed if guard in `not(...)`\n *         // evaluates to `false`\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard\n */\nexport function not<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TArg\n>(\n  guard: SingleGuardArg<TContext, TExpressionEvent, unknown, TArg>\n): GuardPredicate<\n  TContext,\n  TExpressionEvent,\n  unknown,\n  NormalizeGuardArg<DoNotInfer<TArg>>\n> {\n  function not(_args: GuardArgs<TContext, TExpressionEvent>, _params: unknown) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n    return false;\n  }\n\n  not.check = checkNot;\n  not.guards = [guard];\n\n  return not;\n}\n\nfunction checkAnd(\n  snapshot: AnyMachineSnapshot,\n  { context, event }: GuardArgs<any, any>,\n  { guards }: { guards: readonly UnknownGuard[] }\n) {\n  return guards.every((guard) =>\n    evaluateGuard(guard, context, event, snapshot)\n  );\n}\n\n/**\n * Higher-order guard that evaluates to `true` if all `guards` passed to it\n * evaluate to `true`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, and } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => true\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: and([({ context }) => context.value > 0, 'someNamedGuard']),\n *       actions: () => {\n *         // will be executed if all guards in `and(...)`\n *         // evaluate to true\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard action object\n */\nexport function and<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TArg extends unknown[]\n>(\n  guards: readonly [\n    ...{\n      [K in keyof TArg]: SingleGuardArg<\n        TContext,\n        TExpressionEvent,\n        unknown,\n        TArg[K]\n      >;\n    }\n  ]\n): GuardPredicate<\n  TContext,\n  TExpressionEvent,\n  unknown,\n  NormalizeGuardArgArray<DoNotInfer<TArg>>\n> {\n  function and(_args: GuardArgs<TContext, TExpressionEvent>, _params: unknown) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n    return false;\n  }\n\n  and.check = checkAnd;\n  and.guards = guards;\n\n  return and;\n}\n\nfunction checkOr(\n  snapshot: AnyMachineSnapshot,\n  { context, event }: GuardArgs<any, any>,\n  { guards }: { guards: readonly UnknownGuard[] }\n) {\n  return guards.some((guard) => evaluateGuard(guard, context, event, snapshot));\n}\n\n/**\n * Higher-order guard that evaluates to `true` if any of the `guards` passed to\n * it evaluate to `true`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, or } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => true\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: or([({ context }) => context.value > 0, 'someNamedGuard']),\n *       actions: () => {\n *         // will be executed if any of the guards in `or(...)`\n *         // evaluate to true\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard action object\n */\nexport function or<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TArg extends unknown[]\n>(\n  guards: readonly [\n    ...{\n      [K in keyof TArg]: SingleGuardArg<\n        TContext,\n        TExpressionEvent,\n        unknown,\n        TArg[K]\n      >;\n    }\n  ]\n): GuardPredicate<\n  TContext,\n  TExpressionEvent,\n  unknown,\n  NormalizeGuardArgArray<DoNotInfer<TArg>>\n> {\n  function or(_args: GuardArgs<TContext, TExpressionEvent>, _params: unknown) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n    return false;\n  }\n\n  or.check = checkOr;\n  or.guards = guards;\n\n  return or;\n}\n\n// TODO: throw on cycles (depth check should be enough)\nexport function evaluateGuard<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject\n>(\n  guard: UnknownGuard | UnknownInlineGuard,\n  context: TContext,\n  event: TExpressionEvent,\n  snapshot: AnyMachineSnapshot\n): boolean {\n  const { machine } = snapshot;\n  const isInline = typeof guard === 'function';\n\n  const resolved = isInline\n    ? guard\n    : machine.implementations.guards[\n        typeof guard === 'string' ? guard : guard.type\n      ];\n\n  if (!isInline && !resolved) {\n    throw new Error(\n      `Guard '${\n        typeof guard === 'string' ? guard : guard.type\n      }' is not implemented.'.`\n    );\n  }\n\n  if (typeof resolved !== 'function') {\n    return evaluateGuard(resolved!, context, event, snapshot);\n  }\n\n  const guardArgs = {\n    context,\n    event\n  };\n\n  const guardParams =\n    isInline || typeof guard === 'string'\n      ? undefined\n      : 'params' in guard\n        ? typeof guard.params === 'function'\n          ? guard.params({ context, event })\n          : guard.params\n        : undefined;\n\n  if (!('check' in resolved)) {\n    // the existing type of `.guards` assumes non-nullable `TExpressionGuard`\n    // inline guards expect `TExpressionGuard` to be set to `undefined`\n    // it's fine to cast this here, our logic makes sure that we call those 2 \"variants\" correctly\n    return resolved(guardArgs, guardParams as never);\n  }\n\n  const builtinGuard = resolved as unknown as BuiltinGuard;\n\n  return builtinGuard.check(\n    snapshot,\n    guardArgs,\n    resolved // this holds all params\n  );\n}\n","import isDevelopment from '#is-development';\nimport { MachineSnapshot, cloneMachineSnapshot } from './State.ts';\nimport type { StateNode } from './StateNode.ts';\nimport { raise } from './actions.ts';\nimport { createAfterEvent, createDoneStateEvent } from './eventUtils.ts';\nimport { cancel } from './actions/cancel.ts';\nimport { spawnChild } from './actions/spawnChild.ts';\nimport { stopChild } from './actions/stopChild.ts';\nimport {\n  XSTATE_INIT,\n  NULL_EVENT,\n  STATE_DELIMITER,\n  STATE_IDENTIFIER,\n  XSTATE_STOP,\n  WILDCARD\n} from './constants.ts';\nimport { evaluateGuard } from './guards.ts';\nimport {\n  ActionArgs,\n  AnyEventObject,\n  AnyHistoryValue,\n  AnyMachineSnapshot,\n  AnyStateNode,\n  AnyTransitionDefinition,\n  DelayedTransitionDefinition,\n  EventObject,\n  HistoryValue,\n  InitialTransitionConfig,\n  InitialTransitionDefinition,\n  MachineContext,\n  StateValue,\n  StateValueMap,\n  TransitionDefinition,\n  TODO,\n  UnknownAction,\n  ParameterizedObject,\n  AnyTransitionConfig,\n  AnyActorScope,\n  ActionExecutor,\n  AnyStateMachine\n} from './types.ts';\nimport {\n  resolveOutput,\n  normalizeTarget,\n  toArray,\n  toStatePath,\n  toTransitionConfigArray,\n  isErrorActorEvent\n} from './utils.ts';\n\ntype StateNodeIterable<\n  TContext extends MachineContext,\n  TE extends EventObject\n> = Iterable<StateNode<TContext, TE>>;\ntype AnyStateNodeIterable = StateNodeIterable<any, any>;\n\ntype AdjList = Map<AnyStateNode, Array<AnyStateNode>>;\n\nconst isAtomicStateNode = (stateNode: StateNode<any, any>) =>\n  stateNode.type === 'atomic' || stateNode.type === 'final';\n\nfunction getChildren<TContext extends MachineContext, TE extends EventObject>(\n  stateNode: StateNode<TContext, TE>\n): Array<StateNode<TContext, TE>> {\n  return Object.values(stateNode.states).filter((sn) => sn.type !== 'history');\n}\n\nfunction getProperAncestors(\n  stateNode: AnyStateNode,\n  toStateNode: AnyStateNode | undefined\n): Array<typeof stateNode> {\n  const ancestors: Array<typeof stateNode> = [];\n\n  if (toStateNode === stateNode) {\n    return ancestors;\n  }\n\n  // add all ancestors\n  let m = stateNode.parent;\n  while (m && m !== toStateNode) {\n    ancestors.push(m);\n    m = m.parent;\n  }\n\n  return ancestors;\n}\n\nexport function getAllStateNodes(\n  stateNodes: Iterable<AnyStateNode>\n): Set<AnyStateNode> {\n  const nodeSet = new Set(stateNodes);\n\n  const adjList = getAdjList(nodeSet);\n\n  // add descendants\n  for (const s of nodeSet) {\n    // if previously active, add existing child nodes\n    if (s.type === 'compound' && (!adjList.get(s) || !adjList.get(s)!.length)) {\n      getInitialStateNodesWithTheirAncestors(s).forEach((sn) =>\n        nodeSet.add(sn)\n      );\n    } else {\n      if (s.type === 'parallel') {\n        for (const child of getChildren(s)) {\n          if (child.type === 'history') {\n            continue;\n          }\n\n          if (!nodeSet.has(child)) {\n            const initialStates = getInitialStateNodesWithTheirAncestors(child);\n            for (const initialStateNode of initialStates) {\n              nodeSet.add(initialStateNode);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // add all ancestors\n  for (const s of nodeSet) {\n    let m = s.parent;\n\n    while (m) {\n      nodeSet.add(m);\n      m = m.parent;\n    }\n  }\n\n  return nodeSet;\n}\n\nfunction getValueFromAdj(baseNode: AnyStateNode, adjList: AdjList): StateValue {\n  const childStateNodes = adjList.get(baseNode);\n\n  if (!childStateNodes) {\n    return {}; // todo: fix?\n  }\n\n  if (baseNode.type === 'compound') {\n    const childStateNode = childStateNodes[0];\n    if (childStateNode) {\n      if (isAtomicStateNode(childStateNode)) {\n        return childStateNode.key;\n      }\n    } else {\n      return {};\n    }\n  }\n\n  const stateValue: StateValue = {};\n  for (const childStateNode of childStateNodes) {\n    stateValue[childStateNode.key] = getValueFromAdj(childStateNode, adjList);\n  }\n\n  return stateValue;\n}\n\nfunction getAdjList<TContext extends MachineContext, TE extends EventObject>(\n  stateNodes: StateNodeIterable<TContext, TE>\n): AdjList {\n  const adjList: AdjList = new Map();\n\n  for (const s of stateNodes) {\n    if (!adjList.has(s)) {\n      adjList.set(s, []);\n    }\n\n    if (s.parent) {\n      if (!adjList.has(s.parent)) {\n        adjList.set(s.parent, []);\n      }\n\n      adjList.get(s.parent)!.push(s);\n    }\n  }\n\n  return adjList;\n}\n\nexport function getStateValue(\n  rootNode: AnyStateNode,\n  stateNodes: AnyStateNodeIterable\n): StateValue {\n  const config = getAllStateNodes(stateNodes);\n  return getValueFromAdj(rootNode, getAdjList(config));\n}\n\nexport function isInFinalState(\n  stateNodeSet: Set<AnyStateNode>,\n  stateNode: AnyStateNode\n): boolean {\n  if (stateNode.type === 'compound') {\n    return getChildren(stateNode).some(\n      (s) => s.type === 'final' && stateNodeSet.has(s)\n    );\n  }\n  if (stateNode.type === 'parallel') {\n    return getChildren(stateNode).every((sn) =>\n      isInFinalState(stateNodeSet, sn)\n    );\n  }\n\n  return stateNode.type === 'final';\n}\n\nexport const isStateId = (str: string) => str[0] === STATE_IDENTIFIER;\n\nexport function getCandidates<TEvent extends EventObject>(\n  stateNode: StateNode<any, TEvent>,\n  receivedEventType: TEvent['type']\n): Array<TransitionDefinition<any, TEvent>> {\n  const candidates =\n    stateNode.transitions.get(receivedEventType) ||\n    [...stateNode.transitions.keys()]\n      .filter((eventDescriptor) => {\n        // check if transition is a wildcard transition,\n        // which matches any non-transient events\n        if (eventDescriptor === WILDCARD) {\n          return true;\n        }\n\n        if (!eventDescriptor.endsWith('.*')) {\n          return false;\n        }\n\n        if (isDevelopment && /.*\\*.+/.test(eventDescriptor)) {\n          console.warn(\n            `Wildcards can only be the last token of an event descriptor (e.g., \"event.*\") or the entire event descriptor (\"*\"). Check the \"${eventDescriptor}\" event.`\n          );\n        }\n\n        const partialEventTokens = eventDescriptor.split('.');\n        const eventTokens = receivedEventType.split('.');\n\n        for (\n          let tokenIndex = 0;\n          tokenIndex < partialEventTokens.length;\n          tokenIndex++\n        ) {\n          const partialEventToken = partialEventTokens[tokenIndex];\n          const eventToken = eventTokens[tokenIndex];\n\n          if (partialEventToken === '*') {\n            const isLastToken = tokenIndex === partialEventTokens.length - 1;\n\n            if (isDevelopment && !isLastToken) {\n              console.warn(\n                `Infix wildcards in transition events are not allowed. Check the \"${eventDescriptor}\" transition.`\n              );\n            }\n\n            return isLastToken;\n          }\n\n          if (partialEventToken !== eventToken) {\n            return false;\n          }\n        }\n\n        return true;\n      })\n      .sort((a, b) => b.length - a.length)\n      .flatMap((key) => stateNode.transitions.get(key)!);\n\n  return candidates;\n}\n\n/** All delayed transitions from the config. */\nexport function getDelayedTransitions(\n  stateNode: AnyStateNode\n): Array<DelayedTransitionDefinition<MachineContext, EventObject>> {\n  const afterConfig = stateNode.config.after;\n  if (!afterConfig) {\n    return [];\n  }\n\n  const mutateEntryExit = (delay: string | number) => {\n    const afterEvent = createAfterEvent(delay, stateNode.id);\n    const eventType = afterEvent.type;\n\n    stateNode.entry.push(\n      raise(afterEvent, {\n        id: eventType,\n        delay\n      })\n    );\n    stateNode.exit.push(cancel(eventType));\n    return eventType;\n  };\n\n  const delayedTransitions = Object.keys(afterConfig).flatMap((delay) => {\n    const configTransition = afterConfig[delay];\n    const resolvedTransition =\n      typeof configTransition === 'string'\n        ? { target: configTransition }\n        : configTransition;\n    const resolvedDelay = Number.isNaN(+delay) ? delay : +delay;\n    const eventType = mutateEntryExit(resolvedDelay);\n    return toArray(resolvedTransition).map((transition) => ({\n      ...transition,\n      event: eventType,\n      delay: resolvedDelay\n    }));\n  });\n  return delayedTransitions.map((delayedTransition) => {\n    const { delay } = delayedTransition;\n    return {\n      ...formatTransition(\n        stateNode,\n        delayedTransition.event,\n        delayedTransition\n      ),\n      delay\n    };\n  });\n}\n\nexport function formatTransition(\n  stateNode: AnyStateNode,\n  descriptor: string,\n  transitionConfig: AnyTransitionConfig\n): AnyTransitionDefinition {\n  const normalizedTarget = normalizeTarget(transitionConfig.target);\n  const reenter = transitionConfig.reenter ?? false;\n  const target = resolveTarget(stateNode, normalizedTarget);\n\n  // TODO: should this be part of a lint rule instead?\n  if (isDevelopment && (transitionConfig as any).cond) {\n    throw new Error(\n      `State \"${stateNode.id}\" has declared \\`cond\\` for one of its transitions. This property has been renamed to \\`guard\\`. Please update your code.`\n    );\n  }\n\n  const transition = {\n    ...transitionConfig,\n    actions: toArray(transitionConfig.actions),\n    guard: transitionConfig.guard as never,\n    target,\n    source: stateNode,\n    reenter,\n    eventType: descriptor,\n    toJSON: () => ({\n      ...transition,\n      source: `#${stateNode.id}`,\n      target: target ? target.map((t) => `#${t.id}`) : undefined\n    })\n  };\n\n  return transition;\n}\n\nexport function formatTransitions<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode\n): Map<string, TransitionDefinition<TContext, TEvent>[]> {\n  const transitions = new Map<\n    string,\n    TransitionDefinition<TContext, AnyEventObject>[]\n  >();\n  if (stateNode.config.on) {\n    for (const descriptor of Object.keys(stateNode.config.on)) {\n      if (descriptor === NULL_EVENT) {\n        throw new Error(\n          'Null events (\"\") cannot be specified as a transition key. Use `always: { ... }` instead.'\n        );\n      }\n      const transitionsConfig = stateNode.config.on[descriptor];\n      transitions.set(\n        descriptor,\n        toTransitionConfigArray(transitionsConfig).map((t) =>\n          formatTransition(stateNode, descriptor, t)\n        )\n      );\n    }\n  }\n  if (stateNode.config.onDone) {\n    const descriptor = `xstate.done.state.${stateNode.id}`;\n    transitions.set(\n      descriptor,\n      toTransitionConfigArray(stateNode.config.onDone).map((t) =>\n        formatTransition(stateNode, descriptor, t)\n      )\n    );\n  }\n  for (const invokeDef of stateNode.invoke) {\n    if (invokeDef.onDone) {\n      const descriptor = `xstate.done.actor.${invokeDef.id}`;\n      transitions.set(\n        descriptor,\n        toTransitionConfigArray(invokeDef.onDone).map((t) =>\n          formatTransition(stateNode, descriptor, t)\n        )\n      );\n    }\n    if (invokeDef.onError) {\n      const descriptor = `xstate.error.actor.${invokeDef.id}`;\n      transitions.set(\n        descriptor,\n        toTransitionConfigArray(invokeDef.onError).map((t) =>\n          formatTransition(stateNode, descriptor, t)\n        )\n      );\n    }\n    if (invokeDef.onSnapshot) {\n      const descriptor = `xstate.snapshot.${invokeDef.id}`;\n      transitions.set(\n        descriptor,\n        toTransitionConfigArray(invokeDef.onSnapshot).map((t) =>\n          formatTransition(stateNode, descriptor, t)\n        )\n      );\n    }\n  }\n  for (const delayedTransition of stateNode.after) {\n    let existing = transitions.get(delayedTransition.eventType);\n    if (!existing) {\n      existing = [];\n      transitions.set(delayedTransition.eventType, existing);\n    }\n    existing.push(delayedTransition);\n  }\n  return transitions as Map<string, TransitionDefinition<TContext, any>[]>;\n}\n\nexport function formatInitialTransition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  _target:\n    | string\n    | undefined\n    | InitialTransitionConfig<TContext, TEvent, TODO, TODO, TODO, TODO>\n): InitialTransitionDefinition<TContext, TEvent> {\n  const resolvedTarget =\n    typeof _target === 'string'\n      ? stateNode.states[_target]\n      : _target\n        ? stateNode.states[_target.target]\n        : undefined;\n  if (!resolvedTarget && _target) {\n    throw new Error(\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-base-to-string\n      `Initial state node \"${_target}\" not found on parent state node #${stateNode.id}`\n    );\n  }\n  const transition: InitialTransitionDefinition<TContext, TEvent> = {\n    source: stateNode,\n    actions:\n      !_target || typeof _target === 'string' ? [] : toArray(_target.actions),\n    eventType: null as any,\n    reenter: false,\n    target: resolvedTarget ? [resolvedTarget] : [],\n    toJSON: () => ({\n      ...transition,\n      source: `#${stateNode.id}`,\n      target: resolvedTarget ? [`#${resolvedTarget.id}`] : []\n    })\n  };\n\n  return transition;\n}\n\nfunction resolveTarget(\n  stateNode: AnyStateNode,\n  targets: ReadonlyArray<string | AnyStateNode> | undefined\n): ReadonlyArray<AnyStateNode> | undefined {\n  if (targets === undefined) {\n    // an undefined target signals that the state node should not transition from that state when receiving that event\n    return undefined;\n  }\n  return targets.map((target) => {\n    if (typeof target !== 'string') {\n      return target;\n    }\n    if (isStateId(target)) {\n      return stateNode.machine.getStateNodeById(target);\n    }\n\n    const isInternalTarget = target[0] === STATE_DELIMITER;\n    // If internal target is defined on machine,\n    // do not include machine key on target\n    if (isInternalTarget && !stateNode.parent) {\n      return getStateNodeByPath(stateNode, target.slice(1));\n    }\n    const resolvedTarget = isInternalTarget ? stateNode.key + target : target;\n    if (stateNode.parent) {\n      try {\n        const targetStateNode = getStateNodeByPath(\n          stateNode.parent,\n          resolvedTarget\n        );\n        return targetStateNode;\n      } catch (err: any) {\n        throw new Error(\n          `Invalid transition definition for state node '${stateNode.id}':\\n${err.message}`\n        );\n      }\n    } else {\n      throw new Error(\n        `Invalid target: \"${target}\" is not a valid target from the root node. Did you mean \".${target}\"?`\n      );\n    }\n  });\n}\n\nfunction resolveHistoryDefaultTransition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(stateNode: AnyStateNode & { type: 'history' }) {\n  const normalizedTarget = normalizeTarget<TContext, TEvent>(\n    stateNode.config.target\n  );\n  if (!normalizedTarget) {\n    return stateNode.parent!.initial;\n  }\n  return {\n    target: normalizedTarget.map((t) =>\n      typeof t === 'string' ? getStateNodeByPath(stateNode.parent!, t) : t\n    )\n  };\n}\n\nfunction isHistoryNode(\n  stateNode: AnyStateNode\n): stateNode is AnyStateNode & { type: 'history' } {\n  return stateNode.type === 'history';\n}\n\nfunction getInitialStateNodesWithTheirAncestors(stateNode: AnyStateNode) {\n  const states = getInitialStateNodes(stateNode);\n  for (const initialState of states) {\n    for (const ancestor of getProperAncestors(initialState, stateNode)) {\n      states.add(ancestor);\n    }\n  }\n  return states;\n}\n\nexport function getInitialStateNodes(stateNode: AnyStateNode) {\n  const set = new Set<AnyStateNode>();\n\n  function iter(descStateNode: AnyStateNode): void {\n    if (set.has(descStateNode)) {\n      return;\n    }\n    set.add(descStateNode);\n    if (descStateNode.type === 'compound') {\n      iter(descStateNode.initial.target[0]);\n    } else if (descStateNode.type === 'parallel') {\n      for (const child of getChildren(descStateNode)) {\n        iter(child);\n      }\n    }\n  }\n\n  iter(stateNode);\n\n  return set;\n}\n/** Returns the child state node from its relative `stateKey`, or throws. */\nfunction getStateNode(stateNode: AnyStateNode, stateKey: string): AnyStateNode {\n  if (isStateId(stateKey)) {\n    return stateNode.machine.getStateNodeById(stateKey);\n  }\n  if (!stateNode.states) {\n    throw new Error(\n      `Unable to retrieve child state '${stateKey}' from '${stateNode.id}'; no child states exist.`\n    );\n  }\n  const result = stateNode.states[stateKey];\n  if (!result) {\n    throw new Error(\n      `Child state '${stateKey}' does not exist on '${stateNode.id}'`\n    );\n  }\n  return result;\n}\n\n/**\n * Returns the relative state node from the given `statePath`, or throws.\n *\n * @param statePath The string or string array relative path to the state node.\n */\nexport function getStateNodeByPath(\n  stateNode: AnyStateNode,\n  statePath: string | string[]\n): AnyStateNode {\n  if (typeof statePath === 'string' && isStateId(statePath)) {\n    try {\n      return stateNode.machine.getStateNodeById(statePath);\n    } catch {\n      // try individual paths\n      // throw e;\n    }\n  }\n  const arrayStatePath = toStatePath(statePath).slice();\n  let currentStateNode: AnyStateNode = stateNode;\n  while (arrayStatePath.length) {\n    const key = arrayStatePath.shift()!;\n    if (!key.length) {\n      break;\n    }\n    currentStateNode = getStateNode(currentStateNode, key);\n  }\n  return currentStateNode;\n}\n\n/**\n * Returns the state nodes represented by the current state value.\n *\n * @param stateValue The state value or State instance\n */\nexport function getStateNodes(\n  stateNode: AnyStateNode,\n  stateValue: StateValue\n): Array<AnyStateNode> {\n  if (typeof stateValue === 'string') {\n    const childStateNode = stateNode.states[stateValue];\n    if (!childStateNode) {\n      throw new Error(\n        `State '${stateValue}' does not exist on '${stateNode.id}'`\n      );\n    }\n    return [stateNode, childStateNode];\n  }\n\n  const childStateKeys = Object.keys(stateValue);\n  const childStateNodes: Array<AnyStateNode> = childStateKeys\n    .map((subStateKey) => getStateNode(stateNode, subStateKey))\n    .filter(Boolean);\n\n  return [stateNode.machine.root, stateNode].concat(\n    childStateNodes,\n    childStateKeys.reduce((allSubStateNodes, subStateKey) => {\n      const subStateNode = getStateNode(stateNode, subStateKey);\n      if (!subStateNode) {\n        return allSubStateNodes;\n      }\n      const subStateNodes = getStateNodes(\n        subStateNode,\n        stateValue[subStateKey]!\n      );\n\n      return allSubStateNodes.concat(subStateNodes);\n    }, [] as Array<AnyStateNode>)\n  );\n}\n\nfunction transitionAtomicNode<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  stateValue: string,\n  snapshot: MachineSnapshot<\n    TContext,\n    TEvent,\n    any,\n    any,\n    any,\n    any,\n    any, // TMeta\n    any // TStateSchema\n  >,\n  event: TEvent\n): Array<TransitionDefinition<TContext, TEvent>> | undefined {\n  const childStateNode = getStateNode(stateNode, stateValue);\n  const next = childStateNode.next(snapshot, event);\n\n  if (!next || !next.length) {\n    return stateNode.next(snapshot, event);\n  }\n\n  return next;\n}\n\nfunction transitionCompoundNode<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  stateValue: StateValueMap,\n  snapshot: MachineSnapshot<\n    TContext,\n    TEvent,\n    any,\n    any,\n    any,\n    any,\n    any, // TMeta\n    any // TStateSchema\n  >,\n  event: TEvent\n): Array<TransitionDefinition<TContext, TEvent>> | undefined {\n  const subStateKeys = Object.keys(stateValue);\n\n  const childStateNode = getStateNode(stateNode, subStateKeys[0]);\n  const next = transitionNode(\n    childStateNode,\n    stateValue[subStateKeys[0]]!,\n    snapshot,\n    event\n  );\n\n  if (!next || !next.length) {\n    return stateNode.next(snapshot, event);\n  }\n\n  return next;\n}\n\nfunction transitionParallelNode<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  stateValue: StateValueMap,\n  snapshot: MachineSnapshot<\n    TContext,\n    TEvent,\n    any,\n    any,\n    any,\n    any,\n    any, // TMeta\n    any // TStateSchema\n  >,\n  event: TEvent\n): Array<TransitionDefinition<TContext, TEvent>> | undefined {\n  const allInnerTransitions: Array<TransitionDefinition<TContext, TEvent>> = [];\n\n  for (const subStateKey of Object.keys(stateValue)) {\n    const subStateValue = stateValue[subStateKey];\n\n    if (!subStateValue) {\n      continue;\n    }\n\n    const subStateNode = getStateNode(stateNode, subStateKey);\n    const innerTransitions = transitionNode(\n      subStateNode,\n      subStateValue,\n      snapshot,\n      event\n    );\n    if (innerTransitions) {\n      allInnerTransitions.push(...innerTransitions);\n    }\n  }\n  if (!allInnerTransitions.length) {\n    return stateNode.next(snapshot, event);\n  }\n\n  return allInnerTransitions;\n}\n\nexport function transitionNode<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  stateValue: StateValue,\n  snapshot: MachineSnapshot<\n    TContext,\n    TEvent,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any // TStateSchema\n  >,\n  event: TEvent\n): Array<TransitionDefinition<TContext, TEvent>> | undefined {\n  // leaf node\n  if (typeof stateValue === 'string') {\n    return transitionAtomicNode(stateNode, stateValue, snapshot, event);\n  }\n\n  // compound node\n  if (Object.keys(stateValue).length === 1) {\n    return transitionCompoundNode(stateNode, stateValue, snapshot, event);\n  }\n\n  // parallel node\n  return transitionParallelNode(stateNode, stateValue, snapshot, event);\n}\n\nfunction getHistoryNodes(stateNode: AnyStateNode): Array<AnyStateNode> {\n  return Object.keys(stateNode.states)\n    .map((key) => stateNode.states[key])\n    .filter((sn) => sn.type === 'history');\n}\n\nfunction isDescendant(\n  childStateNode: AnyStateNode,\n  parentStateNode: AnyStateNode\n): boolean {\n  let marker = childStateNode;\n  while (marker.parent && marker.parent !== parentStateNode) {\n    marker = marker.parent;\n  }\n\n  return marker.parent === parentStateNode;\n}\n\nfunction hasIntersection<T>(s1: Iterable<T>, s2: Iterable<T>): boolean {\n  const set1 = new Set(s1);\n  const set2 = new Set(s2);\n\n  for (const item of set1) {\n    if (set2.has(item)) {\n      return true;\n    }\n  }\n  for (const item of set2) {\n    if (set1.has(item)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction removeConflictingTransitions(\n  enabledTransitions: Array<AnyTransitionDefinition>,\n  stateNodeSet: Set<AnyStateNode>,\n  historyValue: AnyHistoryValue\n): Array<AnyTransitionDefinition> {\n  const filteredTransitions = new Set<AnyTransitionDefinition>();\n\n  for (const t1 of enabledTransitions) {\n    let t1Preempted = false;\n    const transitionsToRemove = new Set<AnyTransitionDefinition>();\n    for (const t2 of filteredTransitions) {\n      if (\n        hasIntersection(\n          computeExitSet([t1], stateNodeSet, historyValue),\n          computeExitSet([t2], stateNodeSet, historyValue)\n        )\n      ) {\n        if (isDescendant(t1.source, t2.source)) {\n          transitionsToRemove.add(t2);\n        } else {\n          t1Preempted = true;\n          break;\n        }\n      }\n    }\n    if (!t1Preempted) {\n      for (const t3 of transitionsToRemove) {\n        filteredTransitions.delete(t3);\n      }\n      filteredTransitions.add(t1);\n    }\n  }\n\n  return Array.from(filteredTransitions);\n}\n\nfunction findLeastCommonAncestor(\n  stateNodes: Array<AnyStateNode>\n): AnyStateNode | undefined {\n  const [head, ...tail] = stateNodes;\n  for (const ancestor of getProperAncestors(head, undefined)) {\n    if (tail.every((sn) => isDescendant(sn, ancestor))) {\n      return ancestor;\n    }\n  }\n}\n\nfunction getEffectiveTargetStates(\n  transition: Pick<AnyTransitionDefinition, 'target'>,\n  historyValue: AnyHistoryValue\n): Array<AnyStateNode> {\n  if (!transition.target) {\n    return [];\n  }\n\n  const targets = new Set<AnyStateNode>();\n\n  for (const targetNode of transition.target) {\n    if (isHistoryNode(targetNode)) {\n      if (historyValue[targetNode.id]) {\n        for (const node of historyValue[targetNode.id]) {\n          targets.add(node);\n        }\n      } else {\n        for (const node of getEffectiveTargetStates(\n          resolveHistoryDefaultTransition(targetNode),\n          historyValue\n        )) {\n          targets.add(node);\n        }\n      }\n    } else {\n      targets.add(targetNode);\n    }\n  }\n\n  return [...targets];\n}\n\nfunction getTransitionDomain(\n  transition: AnyTransitionDefinition,\n  historyValue: AnyHistoryValue\n): AnyStateNode | undefined {\n  const targetStates = getEffectiveTargetStates(transition, historyValue);\n\n  if (!targetStates) {\n    return;\n  }\n\n  if (\n    !transition.reenter &&\n    targetStates.every(\n      (target) =>\n        target === transition.source || isDescendant(target, transition.source)\n    )\n  ) {\n    return transition.source;\n  }\n\n  const lca = findLeastCommonAncestor(targetStates.concat(transition.source));\n\n  if (lca) {\n    return lca;\n  }\n\n  // at this point we know that it's a root transition since LCA couldn't be found\n  if (transition.reenter) {\n    return;\n  }\n\n  return transition.source.machine.root;\n}\n\nfunction computeExitSet(\n  transitions: AnyTransitionDefinition[],\n  stateNodeSet: Set<AnyStateNode>,\n  historyValue: AnyHistoryValue\n): Array<AnyStateNode> {\n  const statesToExit = new Set<AnyStateNode>();\n\n  for (const t of transitions) {\n    if (t.target?.length) {\n      const domain = getTransitionDomain(t, historyValue);\n\n      if (t.reenter && t.source === domain) {\n        statesToExit.add(domain);\n      }\n\n      for (const stateNode of stateNodeSet) {\n        if (isDescendant(stateNode, domain!)) {\n          statesToExit.add(stateNode);\n        }\n      }\n    }\n  }\n\n  return [...statesToExit];\n}\n\nfunction areStateNodeCollectionsEqual(\n  prevStateNodes: StateNode[],\n  nextStateNodeSet: Set<StateNode>\n) {\n  if (prevStateNodes.length !== nextStateNodeSet.size) {\n    return false;\n  }\n  for (const node of prevStateNodes) {\n    if (!nextStateNodeSet.has(node)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/** https://www.w3.org/TR/scxml/#microstepProcedure */\nexport function microstep(\n  transitions: Array<AnyTransitionDefinition>,\n  currentSnapshot: AnyMachineSnapshot,\n  actorScope: AnyActorScope,\n  event: AnyEventObject,\n  isInitial: boolean,\n  internalQueue: Array<AnyEventObject>\n): AnyMachineSnapshot {\n  if (!transitions.length) {\n    return currentSnapshot;\n  }\n  const mutStateNodeSet = new Set(currentSnapshot._nodes);\n  let historyValue = currentSnapshot.historyValue;\n\n  const filteredTransitions = removeConflictingTransitions(\n    transitions,\n    mutStateNodeSet,\n    historyValue\n  );\n\n  let nextState = currentSnapshot;\n\n  // Exit states\n  if (!isInitial) {\n    [nextState, historyValue] = exitStates(\n      nextState,\n      event,\n      actorScope,\n      filteredTransitions,\n      mutStateNodeSet,\n      historyValue,\n      internalQueue,\n      actorScope.actionExecutor\n    );\n  }\n\n  // Execute transition content\n  nextState = resolveActionsAndContext(\n    nextState,\n    event,\n    actorScope,\n    filteredTransitions.flatMap((t) => t.actions),\n    internalQueue,\n    undefined\n  );\n\n  // Enter states\n  nextState = enterStates(\n    nextState,\n    event,\n    actorScope,\n    filteredTransitions,\n    mutStateNodeSet,\n    internalQueue,\n    historyValue,\n    isInitial\n  );\n\n  const nextStateNodes = [...mutStateNodeSet];\n\n  if (nextState.status === 'done') {\n    nextState = resolveActionsAndContext(\n      nextState,\n      event,\n      actorScope,\n      nextStateNodes\n        .sort((a, b) => b.order - a.order)\n        .flatMap((state) => state.exit),\n      internalQueue,\n      undefined\n    );\n  }\n\n  // eslint-disable-next-line no-useless-catch\n  try {\n    if (\n      historyValue === currentSnapshot.historyValue &&\n      areStateNodeCollectionsEqual(currentSnapshot._nodes, mutStateNodeSet)\n    ) {\n      return nextState;\n    }\n    return cloneMachineSnapshot(nextState, {\n      _nodes: nextStateNodes,\n      historyValue\n    });\n  } catch (e) {\n    // TODO: Refactor this once proper error handling is implemented.\n    // See https://github.com/statelyai/rfcs/pull/4\n    throw e;\n  }\n}\n\nfunction getMachineOutput(\n  snapshot: AnyMachineSnapshot,\n  event: AnyEventObject,\n  actorScope: AnyActorScope,\n  rootNode: AnyStateNode,\n  rootCompletionNode: AnyStateNode\n) {\n  if (rootNode.output === undefined) {\n    return;\n  }\n  const doneStateEvent = createDoneStateEvent(\n    rootCompletionNode.id,\n    rootCompletionNode.output !== undefined && rootCompletionNode.parent\n      ? resolveOutput(\n          rootCompletionNode.output,\n          snapshot.context,\n          event,\n          actorScope.self\n        )\n      : undefined\n  );\n  return resolveOutput(\n    rootNode.output,\n    snapshot.context,\n    doneStateEvent,\n    actorScope.self\n  );\n}\n\nfunction enterStates(\n  currentSnapshot: AnyMachineSnapshot,\n  event: AnyEventObject,\n  actorScope: AnyActorScope,\n  filteredTransitions: AnyTransitionDefinition[],\n  mutStateNodeSet: Set<AnyStateNode>,\n  internalQueue: AnyEventObject[],\n  historyValue: HistoryValue<any, any>,\n  isInitial: boolean\n) {\n  let nextSnapshot = currentSnapshot;\n  const statesToEnter = new Set<AnyStateNode>();\n  // those are states that were directly targeted or indirectly targeted by the explicit target\n  // in other words, those are states for which initial actions should be executed\n  // when we target `#deep_child` initial actions of its ancestors shouldn't be executed\n  const statesForDefaultEntry = new Set<AnyStateNode>();\n  computeEntrySet(\n    filteredTransitions,\n    historyValue,\n    statesForDefaultEntry,\n    statesToEnter\n  );\n\n  // In the initial state, the root state node is \"entered\".\n  if (isInitial) {\n    statesForDefaultEntry.add(currentSnapshot.machine.root);\n  }\n\n  const completedNodes = new Set();\n\n  for (const stateNodeToEnter of [...statesToEnter].sort(\n    (a, b) => a.order - b.order\n  )) {\n    mutStateNodeSet.add(stateNodeToEnter);\n    const actions: UnknownAction[] = [];\n\n    // Add entry actions\n    actions.push(...stateNodeToEnter.entry);\n\n    for (const invokeDef of stateNodeToEnter.invoke) {\n      actions.push(\n        spawnChild(invokeDef.src, {\n          ...invokeDef,\n          syncSnapshot: !!invokeDef.onSnapshot\n        })\n      );\n    }\n\n    if (statesForDefaultEntry.has(stateNodeToEnter)) {\n      const initialActions = stateNodeToEnter.initial.actions;\n      actions.push(...initialActions);\n    }\n\n    nextSnapshot = resolveActionsAndContext(\n      nextSnapshot,\n      event,\n      actorScope,\n      actions,\n      internalQueue,\n      stateNodeToEnter.invoke.map((invokeDef) => invokeDef.id)\n    );\n\n    if (stateNodeToEnter.type === 'final') {\n      const parent = stateNodeToEnter.parent;\n\n      let ancestorMarker =\n        parent?.type === 'parallel' ? parent : parent?.parent;\n      let rootCompletionNode = ancestorMarker || stateNodeToEnter;\n\n      if (parent?.type === 'compound') {\n        internalQueue.push(\n          createDoneStateEvent(\n            parent.id,\n            stateNodeToEnter.output !== undefined\n              ? resolveOutput(\n                  stateNodeToEnter.output,\n                  nextSnapshot.context,\n                  event,\n                  actorScope.self\n                )\n              : undefined\n          )\n        );\n      }\n      while (\n        ancestorMarker?.type === 'parallel' &&\n        !completedNodes.has(ancestorMarker) &&\n        isInFinalState(mutStateNodeSet, ancestorMarker)\n      ) {\n        completedNodes.add(ancestorMarker);\n        internalQueue.push(createDoneStateEvent(ancestorMarker.id));\n        rootCompletionNode = ancestorMarker;\n        ancestorMarker = ancestorMarker.parent;\n      }\n      if (ancestorMarker) {\n        continue;\n      }\n\n      nextSnapshot = cloneMachineSnapshot(nextSnapshot, {\n        status: 'done',\n        output: getMachineOutput(\n          nextSnapshot,\n          event,\n          actorScope,\n          nextSnapshot.machine.root,\n          rootCompletionNode\n        )\n      });\n    }\n  }\n\n  return nextSnapshot;\n}\n\nfunction computeEntrySet(\n  transitions: Array<AnyTransitionDefinition>,\n  historyValue: HistoryValue<any, any>,\n  statesForDefaultEntry: Set<AnyStateNode>,\n  statesToEnter: Set<AnyStateNode>\n) {\n  for (const t of transitions) {\n    const domain = getTransitionDomain(t, historyValue);\n\n    for (const s of t.target || []) {\n      if (\n        !isHistoryNode(s) &&\n        // if the target is different than the source then it will *definitely* be entered\n        (t.source !== s ||\n          // we know that the domain can't lie within the source\n          // if it's different than the source then it's outside of it and it means that the target has to be entered as well\n          t.source !== domain ||\n          // reentering transitions always enter the target, even if it's the source itself\n          t.reenter)\n      ) {\n        statesToEnter.add(s);\n        statesForDefaultEntry.add(s);\n      }\n      addDescendantStatesToEnter(\n        s,\n        historyValue,\n        statesForDefaultEntry,\n        statesToEnter\n      );\n    }\n    const targetStates = getEffectiveTargetStates(t, historyValue);\n    for (const s of targetStates) {\n      const ancestors = getProperAncestors(s, domain);\n      if (domain?.type === 'parallel') {\n        ancestors.push(domain);\n      }\n      addAncestorStatesToEnter(\n        statesToEnter,\n        historyValue,\n        statesForDefaultEntry,\n        ancestors,\n        !t.source.parent && t.reenter ? undefined : domain\n      );\n    }\n  }\n}\n\nfunction addDescendantStatesToEnter<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  historyValue: HistoryValue<any, any>,\n  statesForDefaultEntry: Set<AnyStateNode>,\n  statesToEnter: Set<AnyStateNode>\n) {\n  if (isHistoryNode(stateNode)) {\n    if (historyValue[stateNode.id]) {\n      const historyStateNodes = historyValue[stateNode.id];\n      for (const s of historyStateNodes) {\n        statesToEnter.add(s);\n\n        addDescendantStatesToEnter(\n          s,\n          historyValue,\n          statesForDefaultEntry,\n          statesToEnter\n        );\n      }\n      for (const s of historyStateNodes) {\n        addProperAncestorStatesToEnter(\n          s,\n          stateNode.parent,\n          statesToEnter,\n          historyValue,\n          statesForDefaultEntry\n        );\n      }\n    } else {\n      const historyDefaultTransition = resolveHistoryDefaultTransition<\n        TContext,\n        TEvent\n      >(stateNode);\n      for (const s of historyDefaultTransition.target) {\n        statesToEnter.add(s);\n\n        if (historyDefaultTransition === stateNode.parent?.initial) {\n          statesForDefaultEntry.add(stateNode.parent);\n        }\n\n        addDescendantStatesToEnter(\n          s,\n          historyValue,\n          statesForDefaultEntry,\n          statesToEnter\n        );\n      }\n\n      for (const s of historyDefaultTransition.target) {\n        addProperAncestorStatesToEnter(\n          s,\n          stateNode.parent,\n          statesToEnter,\n          historyValue,\n          statesForDefaultEntry\n        );\n      }\n    }\n  } else {\n    if (stateNode.type === 'compound') {\n      const [initialState] = stateNode.initial.target;\n\n      if (!isHistoryNode(initialState)) {\n        statesToEnter.add(initialState);\n        statesForDefaultEntry.add(initialState);\n      }\n      addDescendantStatesToEnter(\n        initialState,\n        historyValue,\n        statesForDefaultEntry,\n        statesToEnter\n      );\n\n      addProperAncestorStatesToEnter(\n        initialState,\n        stateNode,\n        statesToEnter,\n        historyValue,\n        statesForDefaultEntry\n      );\n    } else {\n      if (stateNode.type === 'parallel') {\n        for (const child of getChildren(stateNode).filter(\n          (sn) => !isHistoryNode(sn)\n        )) {\n          if (![...statesToEnter].some((s) => isDescendant(s, child))) {\n            if (!isHistoryNode(child)) {\n              statesToEnter.add(child);\n              statesForDefaultEntry.add(child);\n            }\n            addDescendantStatesToEnter(\n              child,\n              historyValue,\n              statesForDefaultEntry,\n              statesToEnter\n            );\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction addAncestorStatesToEnter(\n  statesToEnter: Set<AnyStateNode>,\n  historyValue: HistoryValue<any, any>,\n  statesForDefaultEntry: Set<AnyStateNode>,\n  ancestors: AnyStateNode[],\n  reentrancyDomain?: AnyStateNode\n) {\n  for (const anc of ancestors) {\n    if (!reentrancyDomain || isDescendant(anc, reentrancyDomain)) {\n      statesToEnter.add(anc);\n    }\n    if (anc.type === 'parallel') {\n      for (const child of getChildren(anc).filter((sn) => !isHistoryNode(sn))) {\n        if (![...statesToEnter].some((s) => isDescendant(s, child))) {\n          statesToEnter.add(child);\n          addDescendantStatesToEnter(\n            child,\n            historyValue,\n            statesForDefaultEntry,\n            statesToEnter\n          );\n        }\n      }\n    }\n  }\n}\n\nfunction addProperAncestorStatesToEnter(\n  stateNode: AnyStateNode,\n  toStateNode: AnyStateNode | undefined,\n  statesToEnter: Set<AnyStateNode>,\n  historyValue: HistoryValue<any, any>,\n  statesForDefaultEntry: Set<AnyStateNode>\n) {\n  addAncestorStatesToEnter(\n    statesToEnter,\n    historyValue,\n    statesForDefaultEntry,\n    getProperAncestors(stateNode, toStateNode)\n  );\n}\n\nfunction exitStates(\n  currentSnapshot: AnyMachineSnapshot,\n  event: AnyEventObject,\n  actorScope: AnyActorScope,\n  transitions: AnyTransitionDefinition[],\n  mutStateNodeSet: Set<AnyStateNode>,\n  historyValue: HistoryValue<any, any>,\n  internalQueue: AnyEventObject[],\n  _actionExecutor: ActionExecutor\n) {\n  let nextSnapshot = currentSnapshot;\n  const statesToExit = computeExitSet(\n    transitions,\n    mutStateNodeSet,\n    historyValue\n  );\n\n  statesToExit.sort((a, b) => b.order - a.order);\n\n  let changedHistory: typeof historyValue | undefined;\n\n  // From SCXML algorithm: https://www.w3.org/TR/scxml/#exitStates\n  for (const exitStateNode of statesToExit) {\n    for (const historyNode of getHistoryNodes(exitStateNode)) {\n      let predicate: (sn: AnyStateNode) => boolean;\n      if (historyNode.history === 'deep') {\n        predicate = (sn) =>\n          isAtomicStateNode(sn) && isDescendant(sn, exitStateNode);\n      } else {\n        predicate = (sn) => {\n          return sn.parent === exitStateNode;\n        };\n      }\n      changedHistory ??= { ...historyValue };\n      changedHistory[historyNode.id] =\n        Array.from(mutStateNodeSet).filter(predicate);\n    }\n  }\n\n  for (const s of statesToExit) {\n    nextSnapshot = resolveActionsAndContext(\n      nextSnapshot,\n      event,\n      actorScope,\n      [...s.exit, ...s.invoke.map((def) => stopChild(def.id))],\n      internalQueue,\n      undefined\n    );\n    mutStateNodeSet.delete(s);\n  }\n  return [nextSnapshot, changedHistory || historyValue] as const;\n}\n\nexport interface BuiltinAction {\n  (): void;\n  type: `xstate.${string}`;\n  resolve: (\n    actorScope: AnyActorScope,\n    snapshot: AnyMachineSnapshot,\n    actionArgs: ActionArgs<any, any, any>,\n    actionParams: ParameterizedObject['params'] | undefined,\n    action: unknown,\n    extra: unknown\n  ) => [\n    newState: AnyMachineSnapshot,\n    params: unknown,\n    actions?: UnknownAction[]\n  ];\n  retryResolve: (\n    actorScope: AnyActorScope,\n    snapshot: AnyMachineSnapshot,\n    params: unknown\n  ) => void;\n  execute: (actorScope: AnyActorScope, params: unknown) => void;\n}\n\nfunction getAction(machine: AnyStateMachine, actionType: string) {\n  return machine.implementations.actions[actionType];\n}\n\nfunction resolveAndExecuteActionsWithContext(\n  currentSnapshot: AnyMachineSnapshot,\n  event: AnyEventObject,\n  actorScope: AnyActorScope,\n  actions: UnknownAction[],\n  extra: {\n    internalQueue: AnyEventObject[];\n    deferredActorIds: string[] | undefined;\n  },\n  retries: (readonly [BuiltinAction, unknown])[] | undefined\n): AnyMachineSnapshot {\n  const { machine } = currentSnapshot;\n  let intermediateSnapshot = currentSnapshot;\n\n  for (const action of actions) {\n    const isInline = typeof action === 'function';\n    const resolvedAction = isInline\n      ? action\n      : // the existing type of `.actions` assumes non-nullable `TExpressionAction`\n        // it's fine to cast this here to get a common type and lack of errors in the rest of the code\n        // our logic below makes sure that we call those 2 \"variants\" correctly\n\n        getAction(machine, typeof action === 'string' ? action : action.type);\n    const actionArgs = {\n      context: intermediateSnapshot.context,\n      event,\n      self: actorScope.self,\n      system: actorScope.system\n    };\n\n    const actionParams =\n      isInline || typeof action === 'string'\n        ? undefined\n        : 'params' in action\n          ? typeof action.params === 'function'\n            ? action.params({ context: intermediateSnapshot.context, event })\n            : action.params\n          : undefined;\n\n    if (!resolvedAction || !('resolve' in resolvedAction)) {\n      actorScope.actionExecutor({\n        type:\n          typeof action === 'string'\n            ? action\n            : typeof action === 'object'\n              ? action.type\n              : action.name || '(anonymous)',\n        info: actionArgs,\n        params: actionParams,\n        exec: resolvedAction\n      });\n      continue;\n    }\n\n    const builtinAction = resolvedAction as BuiltinAction;\n\n    const [nextState, params, actions] = builtinAction.resolve(\n      actorScope,\n      intermediateSnapshot,\n      actionArgs,\n      actionParams,\n      resolvedAction, // this holds all params\n      extra\n    );\n    intermediateSnapshot = nextState;\n\n    if ('retryResolve' in builtinAction) {\n      retries?.push([builtinAction, params]);\n    }\n\n    if ('execute' in builtinAction) {\n      actorScope.actionExecutor({\n        type: builtinAction.type,\n        info: actionArgs,\n        params,\n        exec: builtinAction.execute.bind(null, actorScope, params)\n      });\n    }\n\n    if (actions) {\n      intermediateSnapshot = resolveAndExecuteActionsWithContext(\n        intermediateSnapshot,\n        event,\n        actorScope,\n        actions,\n        extra,\n        retries\n      );\n    }\n  }\n\n  return intermediateSnapshot;\n}\n\nexport function resolveActionsAndContext(\n  currentSnapshot: AnyMachineSnapshot,\n  event: AnyEventObject,\n  actorScope: AnyActorScope,\n  actions: UnknownAction[],\n  internalQueue: AnyEventObject[],\n  deferredActorIds: string[] | undefined\n): AnyMachineSnapshot {\n  const retries: (readonly [BuiltinAction, unknown])[] | undefined =\n    deferredActorIds ? [] : undefined;\n  const nextState = resolveAndExecuteActionsWithContext(\n    currentSnapshot,\n    event,\n    actorScope,\n    actions,\n    { internalQueue, deferredActorIds },\n    retries\n  );\n  retries?.forEach(([builtinAction, params]) => {\n    builtinAction.retryResolve(actorScope, nextState, params);\n  });\n  return nextState;\n}\n\nexport function macrostep(\n  snapshot: AnyMachineSnapshot,\n  event: EventObject,\n  actorScope: AnyActorScope,\n  internalQueue: AnyEventObject[]\n): {\n  snapshot: typeof snapshot;\n  microstates: Array<typeof snapshot>;\n} {\n  if (isDevelopment && event.type === WILDCARD) {\n    throw new Error(`An event cannot have the wildcard type ('${WILDCARD}')`);\n  }\n\n  let nextSnapshot = snapshot;\n  const microstates: AnyMachineSnapshot[] = [];\n\n  function addMicrostate(\n    microstate: AnyMachineSnapshot,\n    event: AnyEventObject,\n    transitions: AnyTransitionDefinition[]\n  ) {\n    actorScope.system._sendInspectionEvent({\n      type: '@xstate.microstep',\n      actorRef: actorScope.self,\n      event,\n      snapshot: microstate,\n      _transitions: transitions\n    });\n    microstates.push(microstate);\n  }\n\n  // Handle stop event\n  if (event.type === XSTATE_STOP) {\n    nextSnapshot = cloneMachineSnapshot(\n      stopChildren(nextSnapshot, event, actorScope),\n      {\n        status: 'stopped'\n      }\n    );\n    addMicrostate(nextSnapshot, event, []);\n\n    return {\n      snapshot: nextSnapshot,\n      microstates\n    };\n  }\n\n  let nextEvent = event;\n\n  // Assume the state is at rest (no raised events)\n  // Determine the next state based on the next microstep\n  if (nextEvent.type !== XSTATE_INIT) {\n    const currentEvent = nextEvent;\n    const isErr = isErrorActorEvent(currentEvent);\n\n    const transitions = selectTransitions(currentEvent, nextSnapshot);\n\n    if (isErr && !transitions.length) {\n      // TODO: we should likely only allow transitions selected by very explicit descriptors\n      // `*` shouldn't be matched, likely `xstate.error.*` shouldn't be either\n      // similarly `xstate.error.actor.*` and `xstate.error.actor.todo.*` have to be considered too\n      nextSnapshot = cloneMachineSnapshot<typeof snapshot>(snapshot, {\n        status: 'error',\n        error: currentEvent.error\n      });\n      addMicrostate(nextSnapshot, currentEvent, []);\n      return {\n        snapshot: nextSnapshot,\n        microstates\n      };\n    }\n    nextSnapshot = microstep(\n      transitions,\n      snapshot,\n      actorScope,\n      nextEvent,\n      false, // isInitial\n      internalQueue\n    );\n    addMicrostate(nextSnapshot, currentEvent, transitions);\n  }\n\n  let shouldSelectEventlessTransitions = true;\n\n  while (nextSnapshot.status === 'active') {\n    let enabledTransitions: AnyTransitionDefinition[] =\n      shouldSelectEventlessTransitions\n        ? selectEventlessTransitions(nextSnapshot, nextEvent)\n        : [];\n\n    // eventless transitions should always be selected after selecting *regular* transitions\n    // by assigning `undefined` to `previousState` we ensure that `shouldSelectEventlessTransitions` gets always computed to true in such a case\n    const previousState = enabledTransitions.length ? nextSnapshot : undefined;\n\n    if (!enabledTransitions.length) {\n      if (!internalQueue.length) {\n        break;\n      }\n      nextEvent = internalQueue.shift()!;\n      enabledTransitions = selectTransitions(nextEvent, nextSnapshot);\n    }\n\n    nextSnapshot = microstep(\n      enabledTransitions,\n      nextSnapshot,\n      actorScope,\n      nextEvent,\n      false,\n      internalQueue\n    );\n    shouldSelectEventlessTransitions = nextSnapshot !== previousState;\n    addMicrostate(nextSnapshot, nextEvent, enabledTransitions);\n  }\n\n  if (nextSnapshot.status !== 'active') {\n    stopChildren(nextSnapshot, nextEvent, actorScope);\n  }\n\n  return {\n    snapshot: nextSnapshot,\n    microstates\n  };\n}\n\nfunction stopChildren(\n  nextState: AnyMachineSnapshot,\n  event: AnyEventObject,\n  actorScope: AnyActorScope\n) {\n  return resolveActionsAndContext(\n    nextState,\n    event,\n    actorScope,\n    Object.values(nextState.children).map((child: any) => stopChild(child)),\n    [],\n    undefined\n  );\n}\n\nfunction selectTransitions(\n  event: AnyEventObject,\n  nextState: AnyMachineSnapshot\n): AnyTransitionDefinition[] {\n  return nextState.machine.getTransitionData(nextState as any, event);\n}\n\nfunction selectEventlessTransitions(\n  nextState: AnyMachineSnapshot,\n  event: AnyEventObject\n): AnyTransitionDefinition[] {\n  const enabledTransitionSet: Set<AnyTransitionDefinition> = new Set();\n  const atomicStates = nextState._nodes.filter(isAtomicStateNode);\n\n  for (const stateNode of atomicStates) {\n    loop: for (const s of [stateNode].concat(\n      getProperAncestors(stateNode, undefined)\n    )) {\n      if (!s.always) {\n        continue;\n      }\n      for (const transition of s.always) {\n        if (\n          transition.guard === undefined ||\n          evaluateGuard(transition.guard, nextState.context, event, nextState)\n        ) {\n          enabledTransitionSet.add(transition);\n          break loop;\n        }\n      }\n    }\n  }\n\n  return removeConflictingTransitions(\n    Array.from(enabledTransitionSet),\n    new Set(nextState._nodes),\n    nextState.historyValue\n  );\n}\n\n/**\n * Resolves a partial state value with its full representation in the state\n * node's machine.\n *\n * @param stateValue The partial state value to resolve.\n */\nexport function resolveStateValue(\n  rootNode: AnyStateNode,\n  stateValue: StateValue\n): StateValue {\n  const allStateNodes = getAllStateNodes(getStateNodes(rootNode, stateValue));\n  return getStateValue(rootNode, [...allStateNodes]);\n}\n","import isDevelopment from '#is-development';\nimport { executingCustomAction } from '../createActor.ts';\nimport {\n  ActionArgs,\n  ActionFunction,\n  AnyActorScope,\n  AnyEventObject,\n  AnyMachineSnapshot,\n  DelayExpr,\n  DoNotInfer,\n  EventObject,\n  ExecutableActionObject,\n  MachineContext,\n  ParameterizedObject,\n  RaiseActionOptions,\n  SendExpr,\n  BuiltinActionResolution\n} from '../types.ts';\n\nfunction resolveRaise(\n  _: AnyActorScope,\n  snapshot: AnyMachineSnapshot,\n  args: ActionArgs<any, any, any>,\n  actionParams: ParameterizedObject['params'] | undefined,\n  {\n    event: eventOrExpr,\n    id,\n    delay\n  }: {\n    event:\n      | EventObject\n      | SendExpr<\n          MachineContext,\n          EventObject,\n          ParameterizedObject['params'] | undefined,\n          EventObject,\n          EventObject\n        >;\n    id: string | undefined;\n    delay:\n      | string\n      | number\n      | DelayExpr<\n          MachineContext,\n          EventObject,\n          ParameterizedObject['params'] | undefined,\n          EventObject\n        >\n      | undefined;\n  },\n  { internalQueue }: { internalQueue: AnyEventObject[] }\n): BuiltinActionResolution {\n  const delaysMap = snapshot.machine.implementations.delays;\n\n  if (typeof eventOrExpr === 'string') {\n    throw new Error(\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      `Only event objects may be used with raise; use raise({ type: \"${eventOrExpr}\" }) instead`\n    );\n  }\n  const resolvedEvent =\n    typeof eventOrExpr === 'function'\n      ? eventOrExpr(args, actionParams)\n      : eventOrExpr;\n\n  let resolvedDelay: number | undefined;\n  if (typeof delay === 'string') {\n    const configDelay = delaysMap && delaysMap[delay];\n    resolvedDelay =\n      typeof configDelay === 'function'\n        ? configDelay(args, actionParams)\n        : configDelay;\n  } else {\n    resolvedDelay =\n      typeof delay === 'function' ? delay(args, actionParams) : delay;\n  }\n  if (typeof resolvedDelay !== 'number') {\n    internalQueue.push(resolvedEvent);\n  }\n  return [\n    snapshot,\n    {\n      event: resolvedEvent,\n      id,\n      delay: resolvedDelay\n    },\n    undefined\n  ];\n}\n\nfunction executeRaise(\n  actorScope: AnyActorScope,\n  params: {\n    event: EventObject;\n    id: string | undefined;\n    delay: number | undefined;\n  }\n) {\n  const { event, delay, id } = params;\n  if (typeof delay === 'number') {\n    actorScope.defer(() => {\n      const self = actorScope.self;\n      actorScope.system.scheduler.schedule(self, self, event, delay, id);\n    });\n    return;\n  }\n}\n\nexport interface RaiseAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TDelay extends string\n> {\n  (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams): void;\n  _out_TEvent?: TEvent;\n  _out_TDelay?: TDelay;\n}\n\n/**\n * Raises an event. This places the event in the internal event queue, so that\n * the event is immediately consumed by the machine in the current step.\n *\n * @param eventType The event to raise.\n */\nexport function raise<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TDelay extends string = never,\n  TUsedDelay extends TDelay = never\n>(\n  eventOrExpr:\n    | DoNotInfer<TEvent>\n    | SendExpr<TContext, TExpressionEvent, TParams, DoNotInfer<TEvent>, TEvent>,\n  options?: RaiseActionOptions<\n    TContext,\n    TExpressionEvent,\n    TParams,\n    DoNotInfer<TEvent>,\n    TUsedDelay\n  >\n): ActionFunction<\n  TContext,\n  TExpressionEvent,\n  TEvent,\n  TParams,\n  never,\n  never,\n  never,\n  TDelay,\n  never\n> {\n  if (isDevelopment && executingCustomAction) {\n    console.warn(\n      'Custom actions should not call `raise()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.'\n    );\n  }\n\n  function raise(\n    _args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n    _params: TParams\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  raise.type = 'xstate.raise';\n  raise.event = eventOrExpr;\n  raise.id = options?.id;\n  raise.delay = options?.delay;\n\n  raise.resolve = resolveRaise;\n  raise.execute = executeRaise;\n\n  return raise;\n}\n\nexport interface ExecutableRaiseAction extends ExecutableActionObject {\n  type: 'xstate.raise';\n  params: {\n    event: EventObject;\n    id: string | undefined;\n    delay: number | undefined;\n  };\n}\n","import isDevelopment from '#is-development';\nimport { $$ACTOR_TYPE } from './createActor.ts';\nimport type { StateNode } from './StateNode.ts';\nimport type { StateMachine } from './StateMachine.ts';\nimport { getStateValue } from './stateUtils.ts';\nimport type {\n  ProvidedActor,\n  AnyMachineSnapshot,\n  AnyStateMachine,\n  EventObject,\n  HistoryValue,\n  MachineContext,\n  StateConfig,\n  StateValue,\n  AnyActorRef,\n  Snapshot,\n  ParameterizedObject,\n  IsNever,\n  MetaObject,\n  StateSchema,\n  StateId,\n  SnapshotStatus,\n  PersistedHistoryValue\n} from './types.ts';\nimport { matchesState } from './utils.ts';\n\ntype ToTestStateValue<TStateValue extends StateValue> =\n  TStateValue extends string\n    ? TStateValue\n    : IsNever<keyof TStateValue> extends true\n      ? never\n      :\n          | keyof TStateValue\n          | {\n              [K in keyof TStateValue]?: ToTestStateValue<\n                NonNullable<TStateValue[K]>\n              >;\n            };\n\nexport function isMachineSnapshot(value: unknown): value is AnyMachineSnapshot {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    'machine' in value &&\n    'value' in value\n  );\n}\n\ninterface MachineSnapshotBase<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TOutput,\n  TMeta,\n  TStateSchema extends StateSchema = StateSchema\n> {\n  /** The state machine that produced this state snapshot. */\n  machine: StateMachine<\n    TContext,\n    TEvent,\n    TChildren,\n    ProvidedActor,\n    ParameterizedObject,\n    ParameterizedObject,\n    string,\n    TStateValue,\n    TTag,\n    unknown,\n    TOutput,\n    EventObject, // TEmitted\n    any, // TMeta\n    TStateSchema\n  >;\n  /** The tags of the active state nodes that represent the current state value. */\n  tags: Set<string>;\n  /**\n   * The current state value.\n   *\n   * This represents the active state nodes in the state machine.\n   *\n   * - For atomic state nodes, it is a string.\n   * - For compound parent state nodes, it is an object where:\n   *\n   *   - The key is the parent state node's key\n   *   - The value is the current state value of the active child state node(s)\n   *\n   * @example\n   *\n   * ```ts\n   * // single-level state node\n   * snapshot.value; // => 'yellow'\n   *\n   * // nested state nodes\n   * snapshot.value; // => { red: 'wait' }\n   * ```\n   */\n  value: TStateValue;\n  /** The current status of this snapshot. */\n  status: SnapshotStatus;\n  error: unknown;\n  context: TContext;\n\n  historyValue: Readonly<HistoryValue<TContext, TEvent>>;\n  /** The enabled state nodes representative of the state value. */\n  _nodes: Array<StateNode<TContext, TEvent>>;\n  /** An object mapping actor names to spawned/invoked actors. */\n  children: TChildren;\n\n  /**\n   * Whether the current state value is a subset of the given partial state\n   * value.\n   *\n   * @param partialStateValue\n   */\n  matches: (partialStateValue: ToTestStateValue<TStateValue>) => boolean;\n\n  /**\n   * Whether the current state nodes has a state node with the specified `tag`.\n   *\n   * @param tag\n   */\n  hasTag: (tag: TTag) => boolean;\n\n  /**\n   * Determines whether sending the `event` will cause a non-forbidden\n   * transition to be selected, even if the transitions have no actions nor\n   * change the state value.\n   *\n   * @param event The event to test\n   * @returns Whether the event will cause a transition\n   */\n  can: (event: TEvent) => boolean;\n\n  getMeta: () => Record<\n    StateId<TStateSchema> & string,\n    TMeta | undefined // States might not have meta defined\n  >;\n\n  toJSON: () => unknown;\n}\n\ninterface ActiveMachineSnapshot<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TOutput,\n  TMeta extends MetaObject,\n  TConfig extends StateSchema\n> extends MachineSnapshotBase<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TConfig\n  > {\n  status: 'active';\n  output: undefined;\n  error: undefined;\n}\n\ninterface DoneMachineSnapshot<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TOutput,\n  TMeta extends MetaObject,\n  TConfig extends StateSchema\n> extends MachineSnapshotBase<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TConfig\n  > {\n  status: 'done';\n  output: TOutput;\n  error: undefined;\n}\n\ninterface ErrorMachineSnapshot<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TOutput,\n  TMeta extends MetaObject,\n  TConfig extends StateSchema\n> extends MachineSnapshotBase<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TConfig\n  > {\n  status: 'error';\n  output: undefined;\n  error: unknown;\n}\n\ninterface StoppedMachineSnapshot<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TOutput,\n  TMeta extends MetaObject,\n  TConfig extends StateSchema\n> extends MachineSnapshotBase<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TConfig\n  > {\n  status: 'stopped';\n  output: undefined;\n  error: undefined;\n}\n\nexport type MachineSnapshot<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TOutput,\n  TMeta extends MetaObject,\n  TConfig extends StateSchema\n> =\n  | ActiveMachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TConfig\n    >\n  | DoneMachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TConfig\n    >\n  | ErrorMachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TConfig\n    >\n  | StoppedMachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TConfig\n    >;\n\nconst machineSnapshotMatches = function matches(\n  this: AnyMachineSnapshot,\n  testValue: StateValue\n) {\n  return matchesState(testValue, this.value);\n};\n\nconst machineSnapshotHasTag = function hasTag(\n  this: AnyMachineSnapshot,\n  tag: string\n) {\n  return this.tags.has(tag);\n};\n\nconst machineSnapshotCan = function can(\n  this: AnyMachineSnapshot,\n  event: EventObject\n) {\n  if (isDevelopment && !this.machine) {\n    console.warn(\n      `state.can(...) used outside of a machine-created State object; this will always return false.`\n    );\n  }\n\n  const transitionData = this.machine.getTransitionData(this, event);\n\n  return (\n    !!transitionData?.length &&\n    // Check that at least one transition is not forbidden\n    transitionData.some((t) => t.target !== undefined || t.actions.length)\n  );\n};\n\nconst machineSnapshotToJSON = function toJSON(this: AnyMachineSnapshot) {\n  const {\n    _nodes: nodes,\n    tags,\n    machine,\n    getMeta,\n    toJSON,\n    can,\n    hasTag,\n    matches,\n    ...jsonValues\n  } = this;\n  return { ...jsonValues, tags: Array.from(tags) };\n};\n\nconst machineSnapshotGetMeta = function getMeta(this: AnyMachineSnapshot) {\n  return this._nodes.reduce(\n    (acc, stateNode) => {\n      if (stateNode.meta !== undefined) {\n        acc[stateNode.id] = stateNode.meta;\n      }\n      return acc;\n    },\n    {} as Record<string, any>\n  );\n};\n\nexport function createMachineSnapshot<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TMeta extends MetaObject,\n  TStateSchema extends StateSchema\n>(\n  config: StateConfig<TContext, TEvent>,\n  machine: AnyStateMachine\n): MachineSnapshot<\n  TContext,\n  TEvent,\n  TChildren,\n  TStateValue,\n  TTag,\n  undefined,\n  TMeta,\n  TStateSchema\n> {\n  return {\n    status: config.status as never,\n    output: config.output,\n    error: config.error,\n    machine,\n    context: config.context,\n    _nodes: config._nodes,\n    value: getStateValue(machine.root, config._nodes) as never,\n    tags: new Set(config._nodes.flatMap((sn) => sn.tags)),\n    children: config.children as any,\n    historyValue: config.historyValue || {},\n    matches: machineSnapshotMatches as never,\n    hasTag: machineSnapshotHasTag,\n    can: machineSnapshotCan,\n    getMeta: machineSnapshotGetMeta,\n    toJSON: machineSnapshotToJSON\n  };\n}\n\nexport function cloneMachineSnapshot<TState extends AnyMachineSnapshot>(\n  snapshot: TState,\n  config: Partial<StateConfig<any, any>> = {}\n): TState {\n  return createMachineSnapshot(\n    { ...snapshot, ...config } as StateConfig<any, any>,\n    snapshot.machine\n  ) as TState;\n}\n\nfunction serializeHistoryValue<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(historyValue: HistoryValue<TContext, TEvent>): PersistedHistoryValue {\n  if (typeof historyValue !== 'object' || historyValue === null) {\n    return {};\n  }\n  const result: PersistedHistoryValue = {};\n\n  for (const key in historyValue) {\n    const value = historyValue[key];\n    if (Array.isArray(value)) {\n      result[key] = value.map((item) => ({ id: item.id }));\n    }\n  }\n\n  return result;\n}\n\nexport function getPersistedSnapshot<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TOutput,\n  TMeta extends MetaObject\n>(\n  snapshot: MachineSnapshot<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    any // state schema\n  >,\n  options?: unknown\n): Snapshot<unknown> {\n  const {\n    _nodes: nodes,\n    tags,\n    machine,\n    children,\n    context,\n    can,\n    hasTag,\n    matches,\n    getMeta,\n    toJSON,\n    ...jsonValues\n  } = snapshot;\n\n  const childrenJson: Record<string, unknown> = {};\n\n  for (const id in children) {\n    const child = children[id] as any;\n    if (\n      isDevelopment &&\n      typeof child.src !== 'string' &&\n      (!options || !('__unsafeAllowInlineActors' in (options as object)))\n    ) {\n      throw new Error('An inline child actor cannot be persisted.');\n    }\n    childrenJson[id as keyof typeof childrenJson] = {\n      snapshot: child.getPersistedSnapshot(options),\n      src: child.src,\n      systemId: child._systemId,\n      syncSnapshot: child._syncSnapshot\n    };\n  }\n\n  const persisted = {\n    ...jsonValues,\n    context: persistContext(context) as any,\n    children: childrenJson,\n    historyValue: serializeHistoryValue<TContext, TEvent>(\n      jsonValues.historyValue\n    )\n  };\n\n  return persisted;\n}\n\nfunction persistContext(contextPart: Record<string, unknown>) {\n  let copy: typeof contextPart | undefined;\n  for (const key in contextPart) {\n    const value = contextPart[key];\n    if (value && typeof value === 'object') {\n      if ('sessionId' in value && 'send' in value && 'ref' in value) {\n        copy ??= Array.isArray(contextPart)\n          ? (contextPart.slice() as typeof contextPart)\n          : { ...contextPart };\n        copy[key] = {\n          xstate$$type: $$ACTOR_TYPE,\n          id: (value as any as AnyActorRef).id\n        };\n      } else {\n        const result = persistContext(value as typeof contextPart);\n        if (result !== value) {\n          copy ??= Array.isArray(contextPart)\n            ? (contextPart.slice() as typeof contextPart)\n            : { ...contextPart };\n          copy[key] = result;\n        }\n      }\n    }\n  }\n  return copy ?? contextPart;\n}\n","import { ProcessingStatus, createActor } from './createActor.ts';\nimport {\n  ActorRefFromLogic,\n  AnyActorLogic,\n  AnyActorRef,\n  AnyActorScope,\n  AnyEventObject,\n  AnyMachineSnapshot,\n  ConditionalRequired,\n  GetConcreteByKey,\n  InputFrom,\n  IsLiteralString,\n  IsNotNever,\n  ProvidedActor,\n  RequiredActorOptions,\n  TODO,\n  type RequiredLogicInput\n} from './types.ts';\nimport { resolveReferencedActor } from './utils.ts';\n\ntype SpawnOptions<\n  TActor extends ProvidedActor,\n  TSrc extends TActor['src']\n> = TActor extends {\n  src: TSrc;\n}\n  ? ConditionalRequired<\n      [\n        options?: {\n          id?: TActor['id'];\n          systemId?: string;\n          input?: InputFrom<TActor['logic']>;\n          syncSnapshot?: boolean;\n        } & { [K in RequiredActorOptions<TActor>]: unknown }\n      ],\n      IsNotNever<RequiredActorOptions<TActor>>\n    >\n  : never;\n\nexport type Spawner<TActor extends ProvidedActor> =\n  IsLiteralString<TActor['src']> extends true\n    ? {\n        <TSrc extends TActor['src']>(\n          logic: TSrc,\n          ...[options]: SpawnOptions<TActor, TSrc>\n        ): ActorRefFromLogic<GetConcreteByKey<TActor, 'src', TSrc>['logic']>;\n        <TLogic extends AnyActorLogic>(\n          src: TLogic,\n          ...[options]: ConditionalRequired<\n            [\n              options?: {\n                id?: never;\n                systemId?: string;\n                input?: InputFrom<TLogic>;\n                syncSnapshot?: boolean;\n              } & { [K in RequiredLogicInput<TLogic>]: unknown }\n            ],\n            IsNotNever<RequiredLogicInput<TLogic>>\n          >\n        ): ActorRefFromLogic<TLogic>;\n      }\n    : <TLogic extends AnyActorLogic | string>(\n        src: TLogic,\n        ...[options]: ConditionalRequired<\n          [\n            options?: {\n              id?: string;\n              systemId?: string;\n              input?: TLogic extends string ? unknown : InputFrom<TLogic>;\n              syncSnapshot?: boolean;\n            } & (TLogic extends AnyActorLogic\n              ? { [K in RequiredLogicInput<TLogic>]: unknown }\n              : {})\n          ],\n          IsNotNever<\n            TLogic extends AnyActorLogic ? RequiredLogicInput<TLogic> : never\n          >\n        >\n      ) => TLogic extends AnyActorLogic\n        ? ActorRefFromLogic<TLogic>\n        : AnyActorRef;\n\nexport function createSpawner(\n  actorScope: AnyActorScope,\n  { machine, context }: AnyMachineSnapshot,\n  event: AnyEventObject,\n  spawnedChildren: Record<string, AnyActorRef>\n): Spawner<any> {\n  const spawn: Spawner<any> = ((src, options) => {\n    if (typeof src === 'string') {\n      const logic = resolveReferencedActor(machine, src);\n\n      if (!logic) {\n        throw new Error(\n          `Actor logic '${src}' not implemented in machine '${machine.id}'`\n        );\n      }\n\n      const actorRef = createActor(logic, {\n        id: options?.id,\n        parent: actorScope.self,\n        syncSnapshot: options?.syncSnapshot,\n        input:\n          typeof options?.input === 'function'\n            ? options.input({\n                context,\n                event,\n                self: actorScope.self\n              })\n            : options?.input,\n        src,\n        systemId: options?.systemId\n      }) as any;\n\n      spawnedChildren[actorRef.id] = actorRef;\n\n      return actorRef;\n    } else {\n      const actorRef = createActor(src, {\n        id: options?.id,\n        parent: actorScope.self,\n        syncSnapshot: options?.syncSnapshot,\n        input: options?.input,\n        src,\n        systemId: options?.systemId\n      });\n\n      return actorRef;\n    }\n  }) as Spawner<any>;\n  return ((src, options) => {\n    const actorRef = spawn(src, options) as TODO; // TODO: fix types\n    spawnedChildren[actorRef.id] = actorRef;\n    actorScope.defer(() => {\n      if (actorRef._processingStatus === ProcessingStatus.Stopped) {\n        return;\n      }\n      actorRef.start();\n    });\n    return actorRef;\n  }) as Spawner<any>;\n}\n","import isDevelopment from '#is-development';\nimport { cloneMachineSnapshot } from '../State.ts';\nimport { executingCustomAction } from '../createActor.ts';\nimport { Spawner, createSpawner } from '../spawn.ts';\nimport type {\n  ActionArgs,\n  AnyActorScope,\n  AnyActorRef,\n  AnyEventObject,\n  AnyMachineSnapshot,\n  Assigner,\n  EventObject,\n  LowInfer,\n  MachineContext,\n  ParameterizedObject,\n  PropertyAssigner,\n  ProvidedActor,\n  ActionFunction,\n  BuiltinActionResolution\n} from '../types.ts';\n\nexport interface AssignArgs<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> extends ActionArgs<TContext, TExpressionEvent, TEvent> {\n  spawn: Spawner<TActor>;\n}\n\nfunction resolveAssign(\n  actorScope: AnyActorScope,\n  snapshot: AnyMachineSnapshot,\n  actionArgs: ActionArgs<any, any, any>,\n  actionParams: ParameterizedObject['params'] | undefined,\n  {\n    assignment\n  }: {\n    assignment:\n      | Assigner<any, any, any, any, any>\n      | PropertyAssigner<any, any, any, any, any>;\n  }\n): BuiltinActionResolution {\n  if (!snapshot.context) {\n    throw new Error(\n      'Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.'\n    );\n  }\n  const spawnedChildren: Record<string, AnyActorRef> = {};\n\n  const assignArgs: AssignArgs<any, any, any, any> = {\n    context: snapshot.context,\n    event: actionArgs.event,\n    spawn: createSpawner(\n      actorScope,\n      snapshot,\n      actionArgs.event,\n      spawnedChildren\n    ),\n    self: actorScope.self,\n    system: actorScope.system\n  };\n  let partialUpdate: Record<string, unknown> = {};\n  if (typeof assignment === 'function') {\n    partialUpdate = assignment(assignArgs, actionParams);\n  } else {\n    for (const key of Object.keys(assignment)) {\n      const propAssignment = assignment[key];\n      partialUpdate[key] =\n        typeof propAssignment === 'function'\n          ? propAssignment(assignArgs, actionParams)\n          : propAssignment;\n    }\n  }\n\n  const updatedContext = Object.assign({}, snapshot.context, partialUpdate);\n\n  return [\n    cloneMachineSnapshot(snapshot, {\n      context: updatedContext,\n      children: Object.keys(spawnedChildren).length\n        ? {\n            ...snapshot.children,\n            ...spawnedChildren\n          }\n        : snapshot.children\n    }),\n    undefined,\n    undefined\n  ];\n}\n\nexport interface AssignAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> {\n  (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams): void;\n  _out_TActor?: TActor;\n}\n\n/**\n * Updates the current context of the machine.\n *\n * @example\n *\n * ```ts\n * import { createMachine, assign } from 'xstate';\n *\n * const countMachine = createMachine({\n *   context: {\n *     count: 0,\n *     message: ''\n *   },\n *   on: {\n *     inc: {\n *       actions: assign({\n *         count: ({ context }) => context.count + 1\n *       })\n *     },\n *     updateMessage: {\n *       actions: assign(({ context, event }) => {\n *         return {\n *           message: event.message.trim()\n *         };\n *       })\n *     }\n *   }\n * });\n * ```\n *\n * @param assignment An object that represents the partial context to update, or\n *   a function that returns an object that represents the partial context to\n *   update.\n */\nexport function assign<\n  TContext extends MachineContext,\n  TExpressionEvent extends AnyEventObject, // TODO: consider using a stricter `EventObject` here\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n>(\n  assignment:\n    | Assigner<LowInfer<TContext>, TExpressionEvent, TParams, TEvent, TActor>\n    | PropertyAssigner<\n        LowInfer<TContext>,\n        TExpressionEvent,\n        TParams,\n        TEvent,\n        TActor\n      >\n): ActionFunction<\n  TContext,\n  TExpressionEvent,\n  TEvent,\n  TParams,\n  TActor,\n  never,\n  never,\n  never,\n  never\n> {\n  if (isDevelopment && executingCustomAction) {\n    console.warn(\n      'Custom actions should not call `assign()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.'\n    );\n  }\n\n  function assign(\n    _args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n    _params: TParams\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  assign.type = 'xstate.assign';\n  assign.assignment = assignment;\n\n  assign.resolve = resolveAssign;\n\n  return assign;\n}\n","import { createActor } from '../createActor.ts';\nimport type { ActorRef, AnyEventObject, Snapshot } from '../types.ts';\nimport { fromTransition } from './transition.ts';\nexport {\n  fromCallback,\n  type CallbackActorLogic,\n  type CallbackActorRef,\n  type CallbackSnapshot,\n  type CallbackLogicFunction\n} from './callback.ts';\nexport {\n  fromEventObservable,\n  fromObservable,\n  type ObservableActorLogic,\n  type ObservableActorRef,\n  type ObservableSnapshot\n} from './observable.ts';\nexport {\n  fromPromise,\n  type PromiseActorLogic,\n  type PromiseActorRef,\n  type PromiseSnapshot\n} from './promise.ts';\nexport {\n  fromTransition,\n  type TransitionActorLogic,\n  type TransitionActorRef,\n  type TransitionSnapshot\n} from './transition.ts';\n\nconst emptyLogic = fromTransition((_) => undefined, undefined);\n\nexport function createEmptyActor(): ActorRef<\n  Snapshot<undefined>,\n  AnyEventObject,\n  AnyEventObject\n> {\n  return createActor(emptyLogic);\n}\n","import { AnyActorSystem } from '../system.ts';\nimport {\n  ActorLogic,\n  ActorRefFromLogic,\n  ActorScope,\n  EventObject,\n  NonReducibleUnknown,\n  Snapshot\n} from '../types.ts';\n\nexport type TransitionSnapshot<TContext> = Snapshot<undefined> & {\n  context: TContext;\n};\n\nexport type TransitionActorLogic<\n  TContext,\n  TEvent extends EventObject,\n  TInput extends NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n> = ActorLogic<\n  TransitionSnapshot<TContext>,\n  TEvent,\n  TInput,\n  AnyActorSystem,\n  TEmitted\n>;\n\n/**\n * Represents an actor created by `fromTransition`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import {\n *   fromTransition,\n *   createActor,\n *   type AnyActorSystem\n * } from 'xstate';\n *\n * //* The actor's stored context.\n * type Context = {\n *   // The current count.\n *   count: number;\n *   // The amount to increase `count` by.\n *   step: number;\n * };\n * // The events the actor receives.\n * type Event = { type: 'increment' };\n * // The actor's input.\n * type Input = { step?: number };\n *\n * // Actor logic that increments `count` by `step` when it receives an event of\n * // type `increment`.\n * const logic = fromTransition<Context, Event, AnyActorSystem, Input>(\n *   (state, event, actorScope) => {\n *     actorScope.self;\n *     //         ^? TransitionActorRef<Context, Event>\n *\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + state.step\n *       };\n *     }\n *     return state;\n *   },\n *   ({ input, self }) => {\n *     self;\n *     // ^? TransitionActorRef<Context, Event>\n *\n *     return {\n *       count: 0,\n *       step: input.step ?? 1\n *     };\n *   }\n * );\n *\n * const actor = createActor(logic, { input: { step: 10 } });\n * //    ^? TransitionActorRef<Context, Event>\n * ```\n *\n * @see {@link fromTransition}\n */\nexport type TransitionActorRef<\n  TContext,\n  TEvent extends EventObject\n> = ActorRefFromLogic<\n  TransitionActorLogic<TransitionSnapshot<TContext>, TEvent, unknown>\n>;\n\n/**\n * Returns actor logic given a transition function and its initial state.\n *\n * A “transition function” is a function that takes the current `state` and\n * received `event` object as arguments, and returns the next state, similar to\n * a reducer.\n *\n * Actors created from transition logic (“transition actors”) can:\n *\n * - Receive events\n * - Emit snapshots of its state\n *\n * The transition function’s `state` is used as its transition actor’s\n * `context`.\n *\n * Note that the \"state\" for a transition function is provided by the initial\n * state argument, and is not the same as the State object of an actor or a\n * state within a machine configuration.\n *\n * @example\n *\n * ```ts\n * const transitionLogic = fromTransition(\n *   (state, event) => {\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + 1\n *       };\n *     }\n *     return state;\n *   },\n *   { count: 0 }\n * );\n *\n * const transitionActor = createActor(transitionLogic);\n * transitionActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * transitionActor.start();\n * // => {\n * //   status: 'active',\n * //   context: { count: 0 },\n * //   ...\n * // }\n *\n * transitionActor.send({ type: 'increment' });\n * // => {\n * //   status: 'active',\n * //   context: { count: 1 },\n * //   ...\n * // }\n * ```\n *\n * @param transition The transition function used to describe the transition\n *   logic. It should return the next state given the current state and event.\n *   It receives the following arguments:\n *\n *   - `state` - the current state.\n *   - `event` - the received event.\n *   - `actorScope` - the actor scope object, with properties like `self` and\n *       `system`.\n *\n * @param initialContext The initial state of the transition function, either an\n *   object representing the state, or a function which returns a state object.\n *   If a function, it will receive as its only argument an object with the\n *   following properties:\n *\n *   - `input` - the `input` provided to its parent transition actor.\n *   - `self` - a reference to its parent transition actor.\n *\n * @returns Actor logic\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */\nexport function fromTransition<\n  TContext,\n  TEvent extends EventObject,\n  TSystem extends AnyActorSystem,\n  TInput extends NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n>(\n  transition: (\n    snapshot: TContext,\n    event: TEvent,\n    actorScope: ActorScope<\n      TransitionSnapshot<TContext>,\n      TEvent,\n      TSystem,\n      TEmitted\n    >\n  ) => TContext,\n  initialContext:\n    | TContext\n    | (({\n        input,\n        self\n      }: {\n        input: TInput;\n        self: TransitionActorRef<TContext, TEvent>;\n      }) => TContext) // TODO: type\n): TransitionActorLogic<TContext, TEvent, TInput, TEmitted> {\n  return {\n    config: transition,\n    transition: (snapshot, event, actorScope) => {\n      return {\n        ...snapshot,\n        context: transition(snapshot.context, event, actorScope as any)\n      };\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context:\n          typeof initialContext === 'function'\n            ? (initialContext as any)({ input })\n            : initialContext\n      };\n    },\n    getPersistedSnapshot: (snapshot) => snapshot,\n    restoreSnapshot: (snapshot: any) => snapshot\n  };\n}\n","const cache = new WeakMap<any, any>();\n\nexport function memo<T>(object: any, key: string, fn: () => T): T {\n  let memoizedData = cache.get(object);\n\n  if (!memoizedData) {\n    memoizedData = { [key]: fn() };\n    cache.set(object, memoizedData);\n  } else if (!(key in memoizedData)) {\n    memoizedData[key] = fn();\n  }\n\n  return memoizedData[key];\n}\n","import { MachineSnapshot } from './State.ts';\nimport type { StateMachine } from './StateMachine.ts';\nimport { NULL_EVENT, STATE_DELIMITER } from './constants.ts';\nimport { evaluateGuard } from './guards.ts';\nimport { memo } from './memo.ts';\nimport {\n  BuiltinAction,\n  formatInitialTransition,\n  formatTransition,\n  formatTransitions,\n  getCandidates,\n  getDelayedTransitions\n} from './stateUtils.ts';\nimport type {\n  DelayedTransitionDefinition,\n  EventObject,\n  InitialTransitionDefinition,\n  InvokeDefinition,\n  MachineContext,\n  Mapper,\n  StateNodeConfig,\n  StateNodeDefinition,\n  StateNodesConfig,\n  StatesDefinition,\n  TransitionDefinition,\n  TransitionDefinitionMap,\n  TODO,\n  UnknownAction,\n  ParameterizedObject,\n  AnyStateMachine,\n  AnyStateNodeConfig,\n  ProvidedActor,\n  NonReducibleUnknown,\n  EventDescriptor\n} from './types.ts';\nimport {\n  createInvokeId,\n  mapValues,\n  toArray,\n  toTransitionConfigArray\n} from './utils.ts';\n\nconst EMPTY_OBJECT = {};\n\nconst toSerializableAction = (action: UnknownAction) => {\n  if (typeof action === 'string') {\n    return { type: action };\n  }\n  if (typeof action === 'function') {\n    if ('resolve' in action) {\n      return { type: (action as BuiltinAction).type };\n    }\n    return {\n      type: action.name\n    };\n  }\n  return action;\n};\n\ninterface StateNodeOptions<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> {\n  _key: string;\n  _parent?: StateNode<TContext, TEvent>;\n  _machine: AnyStateMachine;\n}\n\nexport class StateNode<\n  TContext extends MachineContext = MachineContext,\n  TEvent extends EventObject = EventObject\n> {\n  /**\n   * The relative key of the state node, which represents its location in the\n   * overall state value.\n   */\n  public key: string;\n  /** The unique ID of the state node. */\n  public id: string;\n  /**\n   * The type of this state node:\n   *\n   * - `'atomic'` - no child state nodes\n   * - `'compound'` - nested child state nodes (XOR)\n   * - `'parallel'` - orthogonal nested child state nodes (AND)\n   * - `'history'` - history state node\n   * - `'final'` - final state node\n   */\n  public type: 'atomic' | 'compound' | 'parallel' | 'final' | 'history';\n  /** The string path from the root machine node to this node. */\n  public path: string[];\n  /** The child state nodes. */\n  public states: StateNodesConfig<TContext, TEvent>;\n  /**\n   * The type of history on this state node. Can be:\n   *\n   * - `'shallow'` - recalls only top-level historical state value\n   * - `'deep'` - recalls historical state value at all levels\n   */\n  public history: false | 'shallow' | 'deep';\n  /** The action(s) to be executed upon entering the state node. */\n  public entry: UnknownAction[];\n  /** The action(s) to be executed upon exiting the state node. */\n  public exit: UnknownAction[];\n  /** The parent state node. */\n  public parent?: StateNode<TContext, TEvent>;\n  /** The root machine node. */\n  public machine: StateMachine<\n    TContext,\n    TEvent,\n    any, // children\n    any, // actor\n    any, // action\n    any, // guard\n    any, // delay\n    any, // state value\n    any, // tag\n    any, // input\n    any, // output\n    any, // emitted\n    any, // meta\n    any // state schema\n  >;\n  /**\n   * The meta data associated with this state node, which will be returned in\n   * State instances.\n   */\n  public meta?: any;\n  /**\n   * The output data sent with the \"xstate.done.state._id_\" event if this is a\n   * final state node.\n   */\n  public output?:\n    | Mapper<MachineContext, EventObject, unknown, EventObject>\n    | NonReducibleUnknown;\n\n  /**\n   * The order this state node appears. Corresponds to the implicit document\n   * order.\n   */\n  public order: number = -1;\n\n  public description?: string;\n\n  public tags: string[] = [];\n  public transitions!: Map<string, TransitionDefinition<TContext, TEvent>[]>;\n  public always?: Array<TransitionDefinition<TContext, TEvent>>;\n\n  constructor(\n    /** The raw config used to create the machine. */\n    public config: StateNodeConfig<\n      TContext,\n      TEvent,\n      TODO, // actors\n      TODO, // actions\n      TODO, // guards\n      TODO, // delays\n      TODO, // tags\n      TODO, // output\n      TODO, // emitted\n      TODO // meta\n    >,\n    options: StateNodeOptions<TContext, TEvent>\n  ) {\n    this.parent = options._parent;\n    this.key = options._key;\n    this.machine = options._machine;\n    this.path = this.parent ? this.parent.path.concat(this.key) : [];\n    this.id =\n      this.config.id || [this.machine.id, ...this.path].join(STATE_DELIMITER);\n    this.type =\n      this.config.type ||\n      (this.config.states && Object.keys(this.config.states).length\n        ? 'compound'\n        : this.config.history\n          ? 'history'\n          : 'atomic');\n    this.description = this.config.description;\n\n    this.order = this.machine.idMap.size;\n    this.machine.idMap.set(this.id, this);\n\n    this.states = (\n      this.config.states\n        ? mapValues(\n            this.config.states,\n            (stateConfig: AnyStateNodeConfig, key) => {\n              const stateNode = new StateNode(stateConfig, {\n                _parent: this,\n                _key: key,\n                _machine: this.machine\n              });\n              return stateNode;\n            }\n          )\n        : EMPTY_OBJECT\n    ) as StateNodesConfig<TContext, TEvent>;\n\n    if (this.type === 'compound' && !this.config.initial) {\n      throw new Error(\n        `No initial state specified for compound state node \"#${\n          this.id\n        }\". Try adding { initial: \"${\n          Object.keys(this.states)[0]\n        }\" } to the state config.`\n      );\n    }\n\n    // History config\n    this.history =\n      this.config.history === true ? 'shallow' : this.config.history || false;\n\n    this.entry = toArray(this.config.entry).slice();\n    this.exit = toArray(this.config.exit).slice();\n\n    this.meta = this.config.meta;\n    this.output =\n      this.type === 'final' || !this.parent ? this.config.output : undefined;\n    this.tags = toArray(config.tags).slice();\n  }\n\n  /** @internal */\n  public _initialize() {\n    this.transitions = formatTransitions(this);\n    if (this.config.always) {\n      this.always = toTransitionConfigArray(this.config.always).map((t) =>\n        formatTransition(this, NULL_EVENT, t)\n      );\n    }\n\n    Object.keys(this.states).forEach((key) => {\n      this.states[key]._initialize();\n    });\n  }\n\n  /** The well-structured state node definition. */\n  public get definition(): StateNodeDefinition<TContext, TEvent> {\n    return {\n      id: this.id,\n      key: this.key,\n      version: this.machine.version,\n      type: this.type,\n      initial: this.initial\n        ? {\n            target: this.initial.target,\n            source: this,\n            actions: this.initial.actions.map(toSerializableAction),\n            eventType: null as any,\n            reenter: false,\n            toJSON: () => ({\n              target: this.initial.target.map((t) => `#${t.id}`),\n              source: `#${this.id}`,\n              actions: this.initial.actions.map(toSerializableAction),\n              eventType: null as any\n            })\n          }\n        : undefined,\n      history: this.history,\n      states: mapValues(this.states, (state: StateNode<TContext, TEvent>) => {\n        return state.definition;\n      }) as StatesDefinition<TContext, TEvent>,\n      on: this.on,\n      transitions: [...this.transitions.values()].flat().map((t) => ({\n        ...t,\n        actions: t.actions.map(toSerializableAction)\n      })),\n      entry: this.entry.map(toSerializableAction),\n      exit: this.exit.map(toSerializableAction),\n      meta: this.meta,\n      order: this.order || -1,\n      output: this.output,\n      invoke: this.invoke,\n      description: this.description,\n      tags: this.tags\n    };\n  }\n\n  /** @internal */\n  public toJSON() {\n    return this.definition;\n  }\n\n  /** The logic invoked as actors by this state node. */\n  public get invoke(): Array<\n    InvokeDefinition<\n      TContext,\n      TEvent,\n      ProvidedActor,\n      ParameterizedObject,\n      ParameterizedObject,\n      string,\n      TODO, // TEmitted\n      TODO // TMeta\n    >\n  > {\n    return memo(this, 'invoke', () =>\n      toArray(this.config.invoke).map((invokeConfig, i) => {\n        const { src, systemId } = invokeConfig;\n        const resolvedId = invokeConfig.id ?? createInvokeId(this.id, i);\n        const sourceName =\n          typeof src === 'string'\n            ? src\n            : `xstate.invoke.${createInvokeId(this.id, i)}`;\n\n        return {\n          ...invokeConfig,\n          src: sourceName,\n          id: resolvedId,\n          systemId: systemId,\n          toJSON() {\n            const { onDone, onError, ...invokeDefValues } = invokeConfig;\n            return {\n              ...invokeDefValues,\n              type: 'xstate.invoke',\n              src: sourceName,\n              id: resolvedId\n            };\n          }\n        } as InvokeDefinition<\n          TContext,\n          TEvent,\n          ProvidedActor,\n          ParameterizedObject,\n          ParameterizedObject,\n          string,\n          TODO, // TEmitted\n          TODO // TMeta\n        >;\n      })\n    );\n  }\n\n  /** The mapping of events to transitions. */\n  public get on(): TransitionDefinitionMap<TContext, TEvent> {\n    return memo(this, 'on', () => {\n      const transitions = this.transitions;\n\n      return [...transitions]\n        .flatMap(([descriptor, t]) => t.map((t) => [descriptor, t] as const))\n        .reduce(\n          (map: any, [descriptor, transition]) => {\n            map[descriptor] = map[descriptor] || [];\n            map[descriptor].push(transition);\n            return map;\n          },\n          {} as TransitionDefinitionMap<TContext, TEvent>\n        );\n    });\n  }\n\n  public get after(): Array<DelayedTransitionDefinition<TContext, TEvent>> {\n    return memo(\n      this,\n      'delayedTransitions',\n      () => getDelayedTransitions(this) as any\n    );\n  }\n\n  public get initial(): InitialTransitionDefinition<TContext, TEvent> {\n    return memo(this, 'initial', () =>\n      formatInitialTransition(this, this.config.initial)\n    );\n  }\n\n  /** @internal */\n  public next(\n    snapshot: MachineSnapshot<\n      TContext,\n      TEvent,\n      any,\n      any,\n      any,\n      any,\n      any, // TMeta\n      any // TStateSchema\n    >,\n    event: TEvent\n  ): TransitionDefinition<TContext, TEvent>[] | undefined {\n    const eventType = event.type;\n    const actions: UnknownAction[] = [];\n\n    let selectedTransition: TransitionDefinition<TContext, TEvent> | undefined;\n\n    const candidates: Array<TransitionDefinition<TContext, TEvent>> = memo(\n      this,\n      `candidates-${eventType}`,\n      () => getCandidates(this, eventType)\n    );\n\n    for (const candidate of candidates) {\n      const { guard } = candidate;\n      const resolvedContext = snapshot.context;\n\n      let guardPassed = false;\n\n      try {\n        guardPassed =\n          !guard ||\n          evaluateGuard<TContext, TEvent>(\n            guard,\n            resolvedContext,\n            event,\n            snapshot\n          );\n      } catch (err: any) {\n        const guardType =\n          typeof guard === 'string'\n            ? guard\n            : typeof guard === 'object'\n              ? guard.type\n              : undefined;\n        throw new Error(\n          `Unable to evaluate guard ${\n            guardType ? `'${guardType}' ` : ''\n          }in transition for event '${eventType}' in state node '${\n            this.id\n          }':\\n${err.message}`\n        );\n      }\n\n      if (guardPassed) {\n        actions.push(...candidate.actions);\n        selectedTransition = candidate;\n        break;\n      }\n    }\n\n    return selectedTransition ? [selectedTransition] : undefined;\n  }\n\n  /** All the event types accepted by this state node and its descendants. */\n  public get events(): Array<EventDescriptor<TEvent>> {\n    return memo(this, 'events', () => {\n      const { states } = this;\n      const events = new Set(this.ownEvents);\n\n      if (states) {\n        for (const stateId of Object.keys(states)) {\n          const state = states[stateId];\n          if (state.states) {\n            for (const event of state.events) {\n              events.add(`${event}`);\n            }\n          }\n        }\n      }\n\n      return Array.from(events);\n    });\n  }\n\n  /**\n   * All the events that have transitions directly from this state node.\n   *\n   * Excludes any inert events.\n   */\n  public get ownEvents(): Array<EventDescriptor<TEvent>> {\n    const events = new Set(\n      [...this.transitions.keys()].filter((descriptor) => {\n        return this.transitions\n          .get(descriptor)!\n          .some(\n            (transition) =>\n              !(\n                !transition.target &&\n                !transition.actions.length &&\n                !transition.reenter\n              )\n          );\n      })\n    );\n\n    return Array.from(events);\n  }\n}\n","import isDevelopment from '#is-development';\nimport { assign } from './actions.ts';\nimport { $$ACTOR_TYPE, createActor } from './createActor.ts';\nimport { createInitEvent } from './eventUtils.ts';\nimport {\n  createMachineSnapshot,\n  getPersistedSnapshot,\n  MachineSnapshot\n} from './State.ts';\nimport { StateNode } from './StateNode.ts';\nimport {\n  getAllStateNodes,\n  getInitialStateNodes,\n  getStateNodeByPath,\n  getStateNodes,\n  isInFinalState,\n  isStateId,\n  macrostep,\n  microstep,\n  resolveActionsAndContext,\n  resolveStateValue,\n  transitionNode\n} from './stateUtils.ts';\nimport { AnyActorSystem } from './system.ts';\nimport type {\n  ActorLogic,\n  ActorScope,\n  AnyActorLogic,\n  AnyActorRef,\n  AnyActorScope,\n  AnyEventObject,\n  DoNotInfer,\n  Equals,\n  EventDescriptor,\n  EventObject,\n  HistoryValue,\n  InternalMachineImplementations,\n  MachineConfig,\n  MachineContext,\n  MachineImplementationsSimplified,\n  MetaObject,\n  ParameterizedObject,\n  ProvidedActor,\n  Snapshot,\n  SnapshotFrom,\n  StateMachineDefinition,\n  StateValue,\n  TransitionDefinition,\n  ResolvedStateMachineTypes,\n  StateSchema,\n  SnapshotStatus\n} from './types.ts';\nimport { resolveReferencedActor, toStatePath } from './utils.ts';\n\nconst STATE_IDENTIFIER = '#';\n\nexport class StateMachine<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TInput,\n  TOutput,\n  TEmitted extends EventObject,\n  TMeta extends MetaObject,\n  TConfig extends StateSchema\n> implements\n    ActorLogic<\n      MachineSnapshot<\n        TContext,\n        TEvent,\n        TChildren,\n        TStateValue,\n        TTag,\n        TOutput,\n        TMeta,\n        TConfig\n      >,\n      TEvent,\n      TInput,\n      AnyActorSystem,\n      TEmitted\n    >\n{\n  /** The machine's own version. */\n  public version?: string;\n\n  public schemas: unknown;\n\n  public implementations: MachineImplementationsSimplified<TContext, TEvent>;\n\n  /** @internal */\n  public __xstatenode = true as const;\n\n  /** @internal */\n  public idMap: Map<string, StateNode<TContext, TEvent>> = new Map();\n\n  public root: StateNode<TContext, TEvent>;\n\n  public id: string;\n\n  public states: StateNode<TContext, TEvent>['states'];\n  public events: Array<EventDescriptor<TEvent>>;\n\n  constructor(\n    /** The raw config used to create the machine. */\n    public config: MachineConfig<\n      TContext,\n      TEvent,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      TOutput,\n      any, // TEmitted\n      any // TMeta\n    > & {\n      schemas?: unknown;\n    },\n    implementations?: MachineImplementationsSimplified<TContext, TEvent>\n  ) {\n    this.id = config.id || '(machine)';\n    this.implementations = {\n      actors: implementations?.actors ?? {},\n      actions: implementations?.actions ?? {},\n      delays: implementations?.delays ?? {},\n      guards: implementations?.guards ?? {}\n    };\n    this.version = this.config.version;\n    this.schemas = this.config.schemas;\n\n    this.transition = this.transition.bind(this);\n    this.getInitialSnapshot = this.getInitialSnapshot.bind(this);\n    this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this);\n    this.restoreSnapshot = this.restoreSnapshot.bind(this);\n    this.start = this.start.bind(this);\n\n    this.root = new StateNode(config, {\n      _key: this.id,\n      _machine: this as any\n    });\n\n    this.root._initialize();\n\n    this.states = this.root.states; // TODO: remove!\n    this.events = this.root.events;\n\n    if (\n      isDevelopment &&\n      !('output' in this.root) &&\n      Object.values(this.states).some(\n        (state) => state.type === 'final' && 'output' in state\n      )\n    ) {\n      console.warn(\n        'Missing `machine.output` declaration (top-level final state with output detected)'\n      );\n    }\n  }\n\n  /**\n   * Clones this state machine with the provided implementations.\n   *\n   * @param implementations Options (`actions`, `guards`, `actors`, `delays`) to\n   *   recursively merge with the existing options.\n   * @returns A new `StateMachine` instance with the provided implementations.\n   */\n  public provide(\n    implementations: InternalMachineImplementations<\n      ResolvedStateMachineTypes<\n        TContext,\n        DoNotInfer<TEvent>,\n        TActor,\n        TAction,\n        TGuard,\n        TDelay,\n        TTag,\n        TEmitted\n      >\n    >\n  ): StateMachine<\n    TContext,\n    TEvent,\n    TChildren,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay,\n    TStateValue,\n    TTag,\n    TInput,\n    TOutput,\n    TEmitted,\n    TMeta,\n    TConfig\n  > {\n    const { actions, guards, actors, delays } = this.implementations;\n\n    return new StateMachine(this.config, {\n      actions: { ...actions, ...implementations.actions },\n      guards: { ...guards, ...implementations.guards },\n      actors: { ...actors, ...implementations.actors },\n      delays: { ...delays, ...implementations.delays }\n    });\n  }\n\n  public resolveState(\n    config: {\n      value: StateValue;\n      context?: TContext;\n      historyValue?: HistoryValue<TContext, TEvent>;\n      status?: SnapshotStatus;\n      output?: TOutput;\n      error?: unknown;\n    } & (Equals<TContext, MachineContext> extends false\n      ? { context: unknown }\n      : {})\n  ): MachineSnapshot<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TConfig\n  > {\n    const resolvedStateValue = resolveStateValue(this.root, config.value);\n    const nodeSet = getAllStateNodes(\n      getStateNodes(this.root, resolvedStateValue)\n    );\n\n    return createMachineSnapshot(\n      {\n        _nodes: [...nodeSet],\n        context: config.context || ({} as TContext),\n        children: {},\n        status: isInFinalState(nodeSet, this.root)\n          ? 'done'\n          : config.status || 'active',\n        output: config.output,\n        error: config.error,\n        historyValue: config.historyValue\n      },\n      this\n    ) as MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TConfig\n    >;\n  }\n\n  /**\n   * Determines the next snapshot given the current `snapshot` and received\n   * `event`. Calculates a full macrostep from all microsteps.\n   *\n   * @param snapshot The current snapshot\n   * @param event The received event\n   */\n  public transition(\n    snapshot: MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TConfig\n    >,\n    event: TEvent,\n    actorScope: ActorScope<typeof snapshot, TEvent, AnyActorSystem, TEmitted>\n  ): MachineSnapshot<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TConfig\n  > {\n    return macrostep(snapshot, event, actorScope, [])\n      .snapshot as typeof snapshot;\n  }\n\n  /**\n   * Determines the next state given the current `state` and `event`. Calculates\n   * a microstep.\n   *\n   * @param state The current state\n   * @param event The received event\n   */\n  public microstep(\n    snapshot: MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TConfig\n    >,\n    event: TEvent,\n    actorScope: AnyActorScope\n  ): Array<\n    MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TConfig\n    >\n  > {\n    return macrostep(snapshot, event, actorScope, []).microstates;\n  }\n\n  public getTransitionData(\n    snapshot: MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TConfig\n    >,\n    event: TEvent\n  ): Array<TransitionDefinition<TContext, TEvent>> {\n    return transitionNode(this.root, snapshot.value, snapshot, event) || [];\n  }\n\n  /**\n   * The initial state _before_ evaluating any microsteps. This \"pre-initial\"\n   * state is provided to initial actions executed in the initial state.\n   */\n  private getPreInitialState(\n    actorScope: AnyActorScope,\n    initEvent: any,\n    internalQueue: AnyEventObject[]\n  ): MachineSnapshot<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TConfig\n  > {\n    const { context } = this.config;\n\n    const preInitial = createMachineSnapshot(\n      {\n        context:\n          typeof context !== 'function' && context ? context : ({} as TContext),\n        _nodes: [this.root],\n        children: {},\n        status: 'active'\n      },\n      this\n    );\n\n    if (typeof context === 'function') {\n      const assignment = ({ spawn, event, self }: any) =>\n        context({ spawn, input: event.input, self });\n      return resolveActionsAndContext(\n        preInitial,\n        initEvent,\n        actorScope,\n        [assign(assignment)],\n        internalQueue,\n        undefined\n      ) as SnapshotFrom<this>;\n    }\n\n    return preInitial as SnapshotFrom<this>;\n  }\n\n  /**\n   * Returns the initial `State` instance, with reference to `self` as an\n   * `ActorRef`.\n   */\n  public getInitialSnapshot(\n    actorScope: ActorScope<\n      MachineSnapshot<\n        TContext,\n        TEvent,\n        TChildren,\n        TStateValue,\n        TTag,\n        TOutput,\n        TMeta,\n        TConfig\n      >,\n      TEvent,\n      AnyActorSystem,\n      TEmitted\n    >,\n    input?: TInput\n  ): MachineSnapshot<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TConfig\n  > {\n    const initEvent = createInitEvent(input) as unknown as TEvent; // TODO: fix;\n    const internalQueue: AnyEventObject[] = [];\n    const preInitialState = this.getPreInitialState(\n      actorScope,\n      initEvent,\n      internalQueue\n    );\n    const nextState = microstep(\n      [\n        {\n          target: [...getInitialStateNodes(this.root)],\n          source: this.root,\n          reenter: true,\n          actions: [],\n          eventType: null as any,\n          toJSON: null as any // TODO: fix\n        }\n      ],\n      preInitialState,\n      actorScope,\n      initEvent,\n      true,\n      internalQueue\n    );\n\n    const { snapshot: macroState } = macrostep(\n      nextState,\n      initEvent as AnyEventObject,\n      actorScope,\n      internalQueue\n    );\n\n    return macroState as SnapshotFrom<this>;\n  }\n\n  public start(\n    snapshot: MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TConfig\n    >\n  ): void {\n    Object.values(snapshot.children as Record<string, AnyActorRef>).forEach(\n      (child: any) => {\n        if (child.getSnapshot().status === 'active') {\n          child.start();\n        }\n      }\n    );\n  }\n\n  public getStateNodeById(stateId: string): StateNode<TContext, TEvent> {\n    const fullPath = toStatePath(stateId);\n    const relativePath = fullPath.slice(1);\n    const resolvedStateId = isStateId(fullPath[0])\n      ? fullPath[0].slice(STATE_IDENTIFIER.length)\n      : fullPath[0];\n\n    const stateNode = this.idMap.get(resolvedStateId);\n    if (!stateNode) {\n      throw new Error(\n        `Child state node '#${resolvedStateId}' does not exist on machine '${this.id}'`\n      );\n    }\n    return getStateNodeByPath(stateNode, relativePath);\n  }\n\n  public get definition(): StateMachineDefinition<TContext, TEvent> {\n    return this.root.definition;\n  }\n\n  public toJSON() {\n    return this.definition;\n  }\n\n  public getPersistedSnapshot(\n    snapshot: MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TConfig\n    >,\n    options?: unknown\n  ) {\n    return getPersistedSnapshot(snapshot, options);\n  }\n\n  public restoreSnapshot(\n    snapshot: Snapshot<unknown>,\n    _actorScope: ActorScope<\n      MachineSnapshot<\n        TContext,\n        TEvent,\n        TChildren,\n        TStateValue,\n        TTag,\n        TOutput,\n        TMeta,\n        TConfig\n      >,\n      TEvent,\n      AnyActorSystem,\n      TEmitted\n    >\n  ): MachineSnapshot<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TConfig\n  > {\n    const children: Record<string, AnyActorRef> = {};\n    const snapshotChildren: Record<\n      string,\n      {\n        src: string | AnyActorLogic;\n        snapshot: Snapshot<unknown>;\n        syncSnapshot?: boolean;\n        systemId?: string;\n      }\n    > = (snapshot as any).children;\n\n    Object.keys(snapshotChildren).forEach((actorId) => {\n      const actorData = snapshotChildren[actorId];\n      const childState = actorData.snapshot;\n      const src = actorData.src;\n\n      const logic =\n        typeof src === 'string' ? resolveReferencedActor(this, src) : src;\n\n      if (!logic) {\n        return;\n      }\n\n      const actorRef = createActor(logic, {\n        id: actorId,\n        parent: _actorScope.self,\n        syncSnapshot: actorData.syncSnapshot,\n        snapshot: childState,\n        src,\n        systemId: actorData.systemId\n      });\n\n      children[actorId] = actorRef;\n    });\n\n    function resolveHistoryReferencedState(\n      root: StateNode<TContext, TEvent>,\n      referenced: { id: string } | StateNode<TContext, TEvent>\n    ) {\n      if (referenced instanceof StateNode) {\n        return referenced;\n      }\n      try {\n        return root.machine.getStateNodeById(referenced.id);\n      } catch {\n        if (isDevelopment) {\n          console.warn(`Could not resolve StateNode for id: ${referenced.id}`);\n        }\n      }\n    }\n\n    function reviveHistoryValue(\n      root: StateNode<TContext, TEvent>,\n      historyValue: Record<\n        string,\n        ({ id: string } | StateNode<TContext, TEvent>)[]\n      >\n    ): HistoryValue<TContext, TEvent> {\n      if (!historyValue || typeof historyValue !== 'object') {\n        return {};\n      }\n      const revived: HistoryValue<TContext, TEvent> = {};\n      for (const key in historyValue) {\n        const arr = historyValue[key];\n\n        for (const item of arr) {\n          const resolved = resolveHistoryReferencedState(root, item);\n\n          if (!resolved) {\n            continue;\n          }\n\n          revived[key] ??= [];\n          revived[key].push(resolved);\n        }\n      }\n      return revived;\n    }\n\n    const revivedHistoryValue = reviveHistoryValue(\n      this.root,\n      (snapshot as any).historyValue\n    );\n\n    const restoredSnapshot = createMachineSnapshot(\n      {\n        ...(snapshot as any),\n        children,\n        _nodes: Array.from(\n          getAllStateNodes(getStateNodes(this.root, (snapshot as any).value))\n        ),\n        historyValue: revivedHistoryValue\n      },\n      this\n    ) as MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TConfig\n    >;\n\n    const seen = new Set();\n\n    function reviveContext(\n      contextPart: Record<string, unknown>,\n      children: Record<string, AnyActorRef>\n    ) {\n      if (seen.has(contextPart)) {\n        return;\n      }\n      seen.add(contextPart);\n      for (const key in contextPart) {\n        const value: unknown = contextPart[key];\n\n        if (value && typeof value === 'object') {\n          if ('xstate$$type' in value && value.xstate$$type === $$ACTOR_TYPE) {\n            contextPart[key] = children[(value as any).id];\n            continue;\n          }\n          reviveContext(value as typeof contextPart, children);\n        }\n      }\n    }\n\n    reviveContext(restoredSnapshot.context, children);\n\n    return restoredSnapshot;\n  }\n}\n","import {\n  SerializationConfig,\n  StatePath,\n  TestMeta,\n  TestPathResult\n} from './types.ts';\nimport { AnyMachineSnapshot, MachineContext } from '../index.ts';\n\ninterface TestResultStringOptions extends SerializationConfig<any, any> {\n  formatColor: (color: string, string: string) => string;\n}\n\nexport function simpleStringify(value: any): string {\n  return JSON.stringify(value);\n}\n\nexport function formatPathTestResult(\n  path: StatePath<any, any>,\n  testPathResult: TestPathResult,\n  options?: Partial<TestResultStringOptions>\n): string {\n  const resolvedOptions: TestResultStringOptions = {\n    formatColor: (_color, string) => string,\n    serializeState: simpleStringify,\n    serializeEvent: simpleStringify,\n    ...options\n  };\n\n  const { formatColor, serializeState, serializeEvent } = resolvedOptions;\n\n  const { state } = path;\n\n  const targetStateString = serializeState(\n    state,\n    path.steps.length ? path.steps[path.steps.length - 1].event : undefined\n  );\n\n  let errMessage = '';\n  let hasFailed = false;\n  errMessage +=\n    '\\nPath:\\n' +\n    testPathResult.steps\n      .map((s, i, steps) => {\n        const stateString = serializeState(\n          s.step.state,\n          i > 0 ? steps[i - 1].step.event : undefined\n        );\n        const eventString = serializeEvent(s.step.event);\n\n        const stateResult = `\\tState: ${\n          hasFailed\n            ? formatColor('gray', stateString)\n            : s.state.error\n              ? ((hasFailed = true), formatColor('redBright', stateString))\n              : formatColor('greenBright', stateString)\n        }`;\n        const eventResult = `\\tEvent: ${\n          hasFailed\n            ? formatColor('gray', eventString)\n            : s.event.error\n              ? ((hasFailed = true), formatColor('red', eventString))\n              : formatColor('green', eventString)\n        }`;\n\n        return [stateResult, eventResult].join('\\n');\n      })\n      .concat(\n        `\\tState: ${\n          hasFailed\n            ? formatColor('gray', targetStateString)\n            : testPathResult.state.error\n              ? formatColor('red', targetStateString)\n              : formatColor('green', targetStateString)\n        }`\n      )\n      .join('\\n\\n');\n\n  return errMessage;\n}\n\nexport function getDescription<T, TContext extends MachineContext>(\n  snapshot: AnyMachineSnapshot\n): string {\n  const contextString = !Object.keys(snapshot.context).length\n    ? ''\n    : `(${JSON.stringify(snapshot.context)})`;\n\n  const stateStrings = snapshot._nodes\n    .filter((sn) => sn.type === 'atomic' || sn.type === 'final')\n    .map(({ id, path }) => {\n      const meta = snapshot.getMeta()[id] as TestMeta<T, TContext>;\n      if (!meta) {\n        return `\"${path.join('.')}\"`;\n      }\n\n      const { description } = meta;\n\n      if (typeof description === 'function') {\n        return description(snapshot);\n      }\n\n      return description ? `\"${description}\"` : JSON.stringify(snapshot.value);\n    });\n\n  return (\n    `state${stateStrings.length === 1 ? '' : 's'} ` +\n    stateStrings.join(', ') +\n    ` ${contextString}`.trim()\n  );\n}\n","import { StatePath } from './index.ts';\nimport { EventObject, Snapshot } from '../index.ts';\nimport { simpleStringify } from './utils.ts';\n\n/**\n * Deduplicates your paths so that A -> B is not executed separately to A -> B\n * -> C\n */\nexport const deduplicatePaths = <\n  TSnapshot extends Snapshot<unknown>,\n  TEvent extends EventObject\n>(\n  paths: StatePath<TSnapshot, TEvent>[],\n  serializeEvent: (event: TEvent) => string = simpleStringify\n): StatePath<TSnapshot, TEvent>[] => {\n  /** Put all paths on the same level so we can dedup them */\n  const allPathsWithEventSequence: Array<{\n    path: StatePath<TSnapshot, TEvent>;\n    eventSequence: string[];\n  }> = [];\n\n  paths.forEach((path) => {\n    allPathsWithEventSequence.push({\n      path,\n      eventSequence: path.steps.map((step) => serializeEvent(step.event))\n    });\n  });\n\n  // Sort by path length, descending\n  allPathsWithEventSequence.sort(\n    (a, z) => z.path.steps.length - a.path.steps.length\n  );\n\n  const superpathsWithEventSequence: typeof allPathsWithEventSequence = [];\n\n  /** Filter out the paths that are subpaths of superpaths */\n  pathLoop: for (const pathWithEventSequence of allPathsWithEventSequence) {\n    // Check each existing superpath to see if the path is a subpath of it\n    superpathLoop: for (const superpathWithEventSequence of superpathsWithEventSequence) {\n      // eslint-disable-next-line @typescript-eslint/no-for-in-array\n      for (const i in pathWithEventSequence.eventSequence) {\n        // Check event sequence to determine if path is subpath, e.g.:\n        //\n        // This will short-circuit the check\n        // ['a', 'b', 'c', 'd'] (superpath)\n        // ['a', 'b', 'x']      (path)\n        //\n        // This will not short-circuit; path is subpath\n        // ['a', 'b', 'c', 'd'] (superpath)\n        // ['a', 'b', 'c']      (path)\n        if (\n          pathWithEventSequence.eventSequence[i] !==\n          superpathWithEventSequence.eventSequence[i]\n        ) {\n          // If the path is different from the superpath,\n          // continue to the next superpath\n          continue superpathLoop;\n        }\n      }\n\n      // If we reached here, path is subpath of superpath\n      // Continue & do not add path to superpaths\n      continue pathLoop;\n    }\n\n    // If we reached here, path is not a subpath of any existing superpaths\n    // So add it to the superpaths\n    superpathsWithEventSequence.push(pathWithEventSequence);\n  }\n\n  return superpathsWithEventSequence.map((path) => path.path);\n};\n","import { getShortestPaths, getSimplePaths } from './index.ts';\nimport { EventObject, Snapshot } from '../index.ts';\nimport { PathGenerator } from './types.ts';\n\nexport const createShortestPathsGen =\n  <\n    TSnapshot extends Snapshot<unknown>,\n    TEvent extends EventObject,\n    TInput\n  >(): PathGenerator<TSnapshot, TEvent, TInput> =>\n  (logic, defaultOptions) => {\n    const paths = getShortestPaths(logic, defaultOptions);\n\n    return paths;\n  };\n\nexport const createSimplePathsGen =\n  <\n    TSnapshot extends Snapshot<unknown>,\n    TEvent extends EventObject,\n    TInput\n  >(): PathGenerator<TSnapshot, TEvent, TInput> =>\n  (logic, defaultOptions) => {\n    const paths = getSimplePaths(logic, defaultOptions);\n\n    return paths;\n  };\n","import { AnyStateMachine, AnyStateNode } from '../index.ts';\n\nconst validateState = (state: AnyStateNode) => {\n  if (state.invoke.length > 0) {\n    throw new Error('Invocations on test machines are not supported');\n  }\n  if (state.after.length > 0) {\n    throw new Error('After events on test machines are not supported');\n  }\n  // TODO: this doesn't account for always transitions\n  [\n    ...state.entry,\n    ...state.exit,\n    ...[...state.transitions.values()].flatMap((t) =>\n      t.flatMap((t) => t.actions)\n    )\n  ].forEach((action) => {\n    // TODO: this doesn't check referenced actions, only the inline ones\n    if (\n      typeof action === 'function' &&\n      'resolve' in action &&\n      typeof (action as any).delay === 'number'\n    ) {\n      throw new Error('Delayed actions on test machines are not supported');\n    }\n  });\n\n  for (const child of Object.values(state.states)) {\n    validateState(child);\n  }\n};\n\nexport const validateMachine = (machine: AnyStateMachine) => {\n  validateState(machine.root);\n};\n","import {\n  getPathsFromEvents,\n  getAdjacencyMap,\n  joinPaths,\n  serializeSnapshot\n} from './index.ts';\nimport type {\n  AdjacencyMap,\n  SerializedEvent,\n  SerializedSnapshot,\n  StatePath,\n  Step,\n  TraversalOptions,\n  EventExecutor,\n  PathGenerator,\n  TestModelOptions,\n  TestParam,\n  TestPath,\n  TestPathResult,\n  TestStepResult\n} from './types.ts';\nimport {\n  EventObject,\n  ActorLogic,\n  Snapshot,\n  isMachineSnapshot,\n  __unsafe_getAllOwnEventDescriptors,\n  AnyActorRef,\n  AnyEventObject,\n  AnyStateMachine,\n  EventFromLogic,\n  MachineContext,\n  MachineSnapshot,\n  SnapshotFrom,\n  StateValue,\n  TODO,\n  InputFrom\n} from '../index.ts';\nimport { deduplicatePaths } from './deduplicatePaths.ts';\nimport {\n  createShortestPathsGen,\n  createSimplePathsGen\n} from './pathGenerators.ts';\nimport {\n  formatPathTestResult,\n  getDescription,\n  simpleStringify\n} from './utils.ts';\nimport { validateMachine } from './validateMachine.ts';\n\ntype GetPathOptions<\n  TSnapshot extends Snapshot<unknown>,\n  TEvent extends EventObject,\n  TInput\n> = Partial<TraversalOptions<TSnapshot, TEvent, TInput>> & {\n  /**\n   * Whether to allow deduplicate paths so that paths that are contained by\n   * longer paths are included.\n   *\n   * @default false\n   */\n  allowDuplicatePaths?: boolean;\n};\n\n/**\n * Creates a test model that represents an abstract model of a system under test\n * (SUT).\n *\n * The test model is used to generate test paths, which are used to verify that\n * states in the model are reachable in the SUT.\n */\nexport class TestModel<\n  TSnapshot extends Snapshot<unknown>,\n  TEvent extends EventObject,\n  TInput\n> {\n  public options: TestModelOptions<TSnapshot, TEvent, TInput>;\n  public defaultTraversalOptions?: TraversalOptions<TSnapshot, TEvent, TInput>;\n  public getDefaultOptions(): TestModelOptions<TSnapshot, TEvent, TInput> {\n    return {\n      serializeState: (state) => simpleStringify(state) as SerializedSnapshot,\n      serializeEvent: (event) => simpleStringify(event) as SerializedEvent,\n      // For non-state-machine test models, we cannot identify\n      // separate transitions, so just use event type\n      serializeTransition: (state, event) =>\n        `${simpleStringify(state)}|${event?.type}`,\n      events: [],\n      stateMatcher: (_, stateKey) => stateKey === '*',\n      logger: {\n        log: console.log.bind(console),\n        error: console.error.bind(console)\n      }\n    };\n  }\n\n  constructor(\n    public testLogic: ActorLogic<TSnapshot, TEvent, TInput>,\n    options?: Partial<TestModelOptions<TSnapshot, TEvent, TInput>>\n  ) {\n    this.options = {\n      ...this.getDefaultOptions(),\n      ...options\n    };\n  }\n\n  public getPaths(\n    pathGenerator: PathGenerator<TSnapshot, TEvent, TInput>,\n    options?: GetPathOptions<TSnapshot, TEvent, TInput>\n  ): Array<TestPath<TSnapshot, TEvent>> {\n    const allowDuplicatePaths = options?.allowDuplicatePaths ?? false;\n    const paths = pathGenerator(this.testLogic, this._resolveOptions(options));\n    return (allowDuplicatePaths ? paths : deduplicatePaths(paths)).map(\n      this._toTestPath\n    );\n  }\n\n  public getShortestPaths(\n    options?: GetPathOptions<TSnapshot, TEvent, TInput>\n  ): Array<TestPath<TSnapshot, TEvent>> {\n    return this.getPaths(createShortestPathsGen(), options);\n  }\n\n  public getShortestPathsFrom(\n    paths: Array<TestPath<TSnapshot, TEvent>>,\n    options?: GetPathOptions<TSnapshot, TEvent, TInput>\n  ): Array<TestPath<TSnapshot, TEvent>> {\n    const resultPaths: TestPath<TSnapshot, TEvent>[] = [];\n\n    for (const path of paths) {\n      const shortestPaths = this.getShortestPaths({\n        ...options,\n        fromState: path.state\n      });\n      for (const shortestPath of shortestPaths) {\n        resultPaths.push(this._toTestPath(joinPaths(path, shortestPath)));\n      }\n    }\n\n    return resultPaths;\n  }\n\n  public getSimplePaths(\n    options?: GetPathOptions<TSnapshot, TEvent, TInput>\n  ): Array<TestPath<TSnapshot, TEvent>> {\n    return this.getPaths(createSimplePathsGen(), options);\n  }\n\n  public getSimplePathsFrom(\n    paths: Array<TestPath<TSnapshot, TEvent>>,\n    options?: GetPathOptions<TSnapshot, TEvent, TInput>\n  ): Array<TestPath<TSnapshot, TEvent>> {\n    const resultPaths: TestPath<TSnapshot, TEvent>[] = [];\n\n    for (const path of paths) {\n      const shortestPaths = this.getSimplePaths({\n        ...options,\n        fromState: path.state\n      });\n      for (const shortestPath of shortestPaths) {\n        resultPaths.push(this._toTestPath(joinPaths(path, shortestPath)));\n      }\n    }\n\n    return resultPaths;\n  }\n\n  private _toTestPath = (\n    statePath: StatePath<TSnapshot, TEvent>\n  ): TestPath<TSnapshot, TEvent> => {\n    function formatEvent(event: EventObject): string {\n      const { type, ...other } = event;\n\n      const propertyString = Object.keys(other).length\n        ? ` (${JSON.stringify(other)})`\n        : '';\n\n      return `${type}${propertyString}`;\n    }\n\n    const eventsString = statePath.steps\n      .map((s) => formatEvent(s.event))\n      .join(' → ');\n    return {\n      ...statePath,\n      test: (params: TestParam<TSnapshot, TEvent>) =>\n        this.testPath(statePath, params),\n      description: isMachineSnapshot(statePath.state)\n        ? `Reaches ${getDescription(\n            statePath.state as any\n          ).trim()}: ${eventsString}`\n        : JSON.stringify(statePath.state)\n    };\n  };\n\n  public getPathsFromEvents(\n    events: TEvent[],\n    options?: GetPathOptions<TSnapshot, TEvent, TInput>\n  ): Array<TestPath<TSnapshot, TEvent>> {\n    const paths = getPathsFromEvents(this.testLogic, events, options);\n\n    return paths.map(this._toTestPath);\n  }\n\n  /**\n   * An array of adjacencies, which are objects that represent each `state` with\n   * the `nextState` given the `event`.\n   */\n  public getAdjacencyMap(): AdjacencyMap<TSnapshot, TEvent> {\n    const adjMap = getAdjacencyMap(this.testLogic, this.options);\n    return adjMap;\n  }\n\n  public async testPath(\n    path: StatePath<TSnapshot, TEvent>,\n    params: TestParam<TSnapshot, TEvent>,\n    options?: Partial<TestModelOptions<TSnapshot, TEvent, TInput>>\n  ): Promise<TestPathResult> {\n    const testPathResult: TestPathResult = {\n      steps: [],\n      state: {\n        error: null\n      }\n    };\n\n    try {\n      for (const step of path.steps) {\n        const testStepResult: TestStepResult = {\n          step,\n          state: { error: null },\n          event: { error: null }\n        };\n\n        testPathResult.steps.push(testStepResult);\n\n        try {\n          await this.testTransition(params, step);\n        } catch (err: any) {\n          testStepResult.event.error = err;\n\n          throw err;\n        }\n\n        try {\n          await this.testState(params, step.state, options);\n        } catch (err: any) {\n          testStepResult.state.error = err;\n\n          throw err;\n        }\n      }\n    } catch (err: any) {\n      // TODO: make option\n      err.message += formatPathTestResult(path, testPathResult, this.options);\n      throw err;\n    }\n\n    return testPathResult;\n  }\n\n  public async testState(\n    params: TestParam<TSnapshot, TEvent>,\n    state: TSnapshot,\n    options?: Partial<TestModelOptions<TSnapshot, TEvent, TInput>>\n  ): Promise<void> {\n    const resolvedOptions = this._resolveOptions(options);\n\n    const stateTestKeys = this._getStateTestKeys(\n      params,\n      state,\n      resolvedOptions\n    );\n\n    for (const stateTestKey of stateTestKeys) {\n      await params.states?.[stateTestKey](state);\n    }\n  }\n\n  private _getStateTestKeys(\n    params: TestParam<TSnapshot, TEvent>,\n    state: TSnapshot,\n    resolvedOptions: TestModelOptions<TSnapshot, TEvent, TInput>\n  ) {\n    const states = params.states || {};\n    const stateTestKeys = Object.keys(states).filter((stateKey) => {\n      return resolvedOptions.stateMatcher(state, stateKey);\n    });\n\n    // Fallthrough state tests\n    if (!stateTestKeys.length && '*' in states) {\n      stateTestKeys.push('*');\n    }\n\n    return stateTestKeys;\n  }\n\n  private _getEventExec(\n    params: TestParam<TSnapshot, TEvent>,\n    step: Step<TSnapshot, TEvent>\n  ) {\n    const eventExec =\n      params.events?.[(step.event as any).type as TEvent['type']];\n\n    return eventExec;\n  }\n\n  public async testTransition(\n    params: TestParam<TSnapshot, TEvent>,\n    step: Step<TSnapshot, TEvent>\n  ): Promise<void> {\n    const eventExec = this._getEventExec(params, step);\n    await (eventExec as EventExecutor<TSnapshot, TEvent>)?.(step);\n  }\n\n  private _resolveOptions(\n    options?: Partial<TestModelOptions<TSnapshot, TEvent, TInput>>\n  ): TestModelOptions<TSnapshot, TEvent, TInput> {\n    return { ...this.defaultTraversalOptions, ...this.options, ...options };\n  }\n}\n\nfunction stateValuesEqual(\n  a: StateValue | undefined,\n  b: StateValue | undefined\n): boolean {\n  if (a === b) {\n    return true;\n  }\n\n  if (a === undefined || b === undefined) {\n    return false;\n  }\n\n  if (typeof a === 'string' || typeof b === 'string') {\n    return a === b;\n  }\n\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n\n  return (\n    aKeys.length === bKeys.length &&\n    aKeys.every((key) => stateValuesEqual(a[key], b[key]))\n  );\n}\n\nfunction serializeMachineTransition(\n  snapshot: MachineSnapshot<\n    MachineContext,\n    EventObject,\n    Record<string, AnyActorRef | undefined>,\n    StateValue,\n    string,\n    unknown,\n    TODO, // TMeta\n    TODO // TStateSchema\n  >,\n  event: AnyEventObject | undefined,\n  previousSnapshot:\n    | MachineSnapshot<\n        MachineContext,\n        EventObject,\n        Record<string, AnyActorRef | undefined>,\n        StateValue,\n        string,\n        unknown,\n        TODO, // TMeta\n        TODO // TStateSchema\n      >\n    | undefined,\n  { serializeEvent }: { serializeEvent: (event: AnyEventObject) => string }\n): string {\n  // TODO: the stateValuesEqual check here is very likely not exactly correct\n  // but I'm not sure what the correct check is and what this is trying to do\n  if (\n    !event ||\n    (previousSnapshot &&\n      stateValuesEqual(previousSnapshot.value, snapshot.value))\n  ) {\n    return '';\n  }\n\n  const prevStateString = previousSnapshot\n    ? ` from ${simpleStringify(previousSnapshot.value)}`\n    : '';\n\n  return ` via ${serializeEvent(event)}${prevStateString}`;\n}\n\n/**\n * Creates a test model that represents an abstract model of a system under test\n * (SUT).\n *\n * The test model is used to generate test paths, which are used to verify that\n * states in the `machine` are reachable in the SUT.\n *\n * @example\n *\n * ```js\n * const toggleModel = createModel(toggleMachine).withEvents({\n *   TOGGLE: {\n *     exec: async (page) => {\n *       await page.click('input');\n *     }\n *   }\n * });\n * ```\n *\n * @param machine The state machine used to represent the abstract model.\n * @param options Options for the created test model:\n *\n *   - `events`: an object mapping string event types (e.g., `SUBMIT`) to an event\n *       test config (e.g., `{exec: () => {...}, cases: [...]}`)\n */\nexport function createTestModel<TMachine extends AnyStateMachine>(\n  machine: TMachine,\n  options?: Partial<\n    TestModelOptions<\n      SnapshotFrom<TMachine>,\n      EventFromLogic<TMachine>,\n      InputFrom<TMachine>\n    >\n  >\n): TestModel<SnapshotFrom<TMachine>, EventFromLogic<TMachine>, unknown> {\n  validateMachine(machine);\n\n  const serializeEvent = (options?.serializeEvent ?? simpleStringify) as (\n    event: AnyEventObject\n  ) => string;\n  const serializeTransition =\n    options?.serializeTransition ?? serializeMachineTransition;\n  const { events: getEvents, ...otherOptions } = options ?? {};\n\n  const testModel = new TestModel<\n    SnapshotFrom<TMachine>,\n    EventFromLogic<TMachine>,\n    unknown\n  >(machine as any, {\n    serializeState: (state, event, prevState) => {\n      // Only consider the `state` if `serializeTransition()` is opted out (empty string)\n      return `${serializeSnapshot(state)}${serializeTransition(\n        state,\n        event,\n        prevState,\n        {\n          serializeEvent\n        }\n      )}` as SerializedSnapshot;\n    },\n    stateMatcher: (state, key) => {\n      return key.startsWith('#')\n        ? (state as any)._nodes.includes(machine.getStateNodeById(key))\n        : (state as any).matches(key);\n    },\n    events: (state) => {\n      const events =\n        typeof getEvents === 'function' ? getEvents(state) : (getEvents ?? []);\n\n      return __unsafe_getAllOwnEventDescriptors(state).flatMap(\n        (eventType: string) => {\n          if (events.some((e) => (e as EventObject).type === eventType)) {\n            return events.filter((e) => (e as EventObject).type === eventType);\n          }\n\n          return [{ type: eventType } as any]; // TODO: fix types\n        }\n      );\n    },\n    ...otherOptions\n  });\n\n  return testModel;\n}\n","import { AnyActorScope, createEmptyActor } from '../index.ts';\n\nexport function createMockActorScope(): AnyActorScope {\n  const emptyActor = createEmptyActor();\n  return {\n    self: emptyActor,\n    logger: console.log,\n    id: '',\n    sessionId: Math.random().toString(32).slice(2),\n    defer: () => {},\n    system: emptyActor.system, // TODO: mock system?\n    stopChild: () => {},\n    emit: () => {},\n    actionExecutor: () => {}\n  };\n}\n","import {\n  EventObject,\n  AnyStateMachine,\n  StateMachine,\n  AnyActorLogic,\n  EventFromLogic,\n  Snapshot,\n  __unsafe_getAllOwnEventDescriptors,\n  InputFrom\n} from '../index.ts';\nimport type {\n  SerializedEvent,\n  SerializedSnapshot,\n  StatePath,\n  DirectedGraphEdge,\n  DirectedGraphNode,\n  TraversalOptions,\n  AnyStateNode,\n  TraversalConfig\n} from './types.ts';\nimport { createMockActorScope } from './actorScope.ts';\n\n/**\n * Returns all state nodes of the given `node`.\n *\n * @param stateNode State node to recursively get child state nodes from\n */\nexport function getStateNodes(\n  stateNode: AnyStateNode | AnyStateMachine\n): AnyStateNode[] {\n  const { states } = stateNode;\n  const nodes = Object.keys(states).reduce((accNodes, stateKey) => {\n    const childStateNode = states[stateKey];\n    const childStateNodes = getStateNodes(childStateNode);\n\n    accNodes.push(childStateNode, ...childStateNodes);\n    return accNodes;\n  }, [] as AnyStateNode[]);\n\n  return nodes;\n}\n\nfunction getChildren(stateNode: AnyStateNode): AnyStateNode[] {\n  if (!stateNode.states) {\n    return [];\n  }\n\n  const children = Object.keys(stateNode.states).map((key) => {\n    return stateNode.states[key];\n  });\n\n  return children;\n}\n\nexport function serializeSnapshot(snapshot: Snapshot<any>): SerializedSnapshot {\n  const { value, context } = snapshot as any;\n  return JSON.stringify({\n    value,\n    context: Object.keys(context ?? {}).length ? context : undefined\n  }) as SerializedSnapshot;\n}\n\nfunction serializeEvent<TEvent extends EventObject>(\n  event: TEvent\n): SerializedEvent {\n  return JSON.stringify(event) as SerializedEvent;\n}\n\nexport function createDefaultMachineOptions<TMachine extends AnyStateMachine>(\n  machine: TMachine,\n  options?: TraversalOptions<\n    ReturnType<TMachine['transition']>,\n    EventFromLogic<TMachine>,\n    InputFrom<TMachine>\n  >\n): TraversalOptions<\n  ReturnType<TMachine['transition']>,\n  EventFromLogic<TMachine>,\n  InputFrom<TMachine>\n> {\n  const { events: getEvents, ...otherOptions } = options ?? {};\n  const traversalOptions: TraversalOptions<\n    ReturnType<TMachine['transition']>,\n    EventFromLogic<TMachine>,\n    InputFrom<TMachine>\n  > = {\n    serializeState: serializeSnapshot,\n    serializeEvent,\n    events: (state) => {\n      const events =\n        typeof getEvents === 'function' ? getEvents(state) : (getEvents ?? []);\n      return __unsafe_getAllOwnEventDescriptors(state).flatMap((type) => {\n        const matchingEvents = events.filter((ev) => (ev as any).type === type);\n        if (matchingEvents.length) {\n          return matchingEvents;\n        }\n        return [{ type }];\n      }) as any[];\n    },\n    fromState: machine.getInitialSnapshot(\n      createMockActorScope(),\n      options?.input\n    ) as ReturnType<TMachine['transition']>,\n    ...otherOptions\n  };\n\n  return traversalOptions;\n}\n\nexport function createDefaultLogicOptions(): TraversalOptions<any, any, any> {\n  return {\n    serializeState: (state) => JSON.stringify(state),\n    serializeEvent\n  };\n}\n\nexport function toDirectedGraph(\n  stateMachine: AnyStateNode | AnyStateMachine\n): DirectedGraphNode {\n  const stateNode =\n    stateMachine instanceof StateMachine ? stateMachine.root : stateMachine; // TODO: accept only machines\n\n  const edges: DirectedGraphEdge[] = [...stateNode.transitions.values()]\n    .flat()\n    .flatMap((t, transitionIndex) => {\n      const targets = t.target ? t.target : [stateNode];\n\n      return targets.map((target, targetIndex) => {\n        const edge: DirectedGraphEdge = {\n          id: `${stateNode.id}:${transitionIndex}:${targetIndex}`,\n          source: stateNode,\n          target: target as AnyStateNode,\n          transition: t,\n          label: {\n            text: t.eventType,\n            toJSON: () => ({ text: t.eventType })\n          },\n          toJSON: () => {\n            const { label } = edge;\n\n            return { source: stateNode.id, target: target.id, label };\n          }\n        };\n\n        return edge;\n      });\n    });\n\n  const graph = {\n    id: stateNode.id,\n    stateNode: stateNode,\n    children: getChildren(stateNode).map(toDirectedGraph),\n    edges,\n    toJSON: () => {\n      const { id, children, edges: graphEdges } = graph;\n      return { id, children, edges: graphEdges };\n    }\n  };\n\n  return graph;\n}\n\nfunction isMachineLogic(logic: AnyActorLogic): logic is AnyStateMachine {\n  return 'getStateNodeById' in logic;\n}\n\nexport function resolveTraversalOptions<TLogic extends AnyActorLogic>(\n  logic: TLogic,\n  traversalOptions?: TraversalOptions<\n    ReturnType<TLogic['transition']>,\n    EventFromLogic<TLogic>,\n    InputFrom<TLogic>\n  >,\n  defaultOptions?: TraversalOptions<\n    ReturnType<TLogic['transition']>,\n    EventFromLogic<TLogic>,\n    InputFrom<TLogic>\n  >\n): TraversalConfig<ReturnType<TLogic['transition']>, EventFromLogic<TLogic>> {\n  const resolvedDefaultOptions =\n    defaultOptions ??\n    (isMachineLogic(logic)\n      ? (createDefaultMachineOptions(\n          logic,\n          traversalOptions as any\n        ) as TraversalOptions<\n          ReturnType<TLogic['transition']>,\n          EventFromLogic<TLogic>,\n          InputFrom<TLogic>\n        >)\n      : undefined);\n  const serializeState =\n    traversalOptions?.serializeState ??\n    resolvedDefaultOptions?.serializeState ??\n    ((state) => JSON.stringify(state));\n  const traversalConfig: TraversalConfig<\n    ReturnType<TLogic['transition']>,\n    EventFromLogic<TLogic>\n  > = {\n    serializeState,\n    serializeEvent,\n    events: [],\n    limit: Infinity,\n    fromState: undefined,\n    toState: undefined,\n    // Traversal should not continue past the `toState` predicate\n    // since the target state has already been reached at that point\n    stopWhen: traversalOptions?.toState,\n    ...resolvedDefaultOptions,\n    ...traversalOptions\n  };\n\n  return traversalConfig;\n}\n\nexport function joinPaths<\n  TSnapshot extends Snapshot<unknown>,\n  TEvent extends EventObject\n>(\n  headPath: StatePath<TSnapshot, TEvent>,\n  tailPath: StatePath<TSnapshot, TEvent>\n): StatePath<TSnapshot, TEvent> {\n  const secondPathSource = tailPath.steps[0].state;\n\n  if (secondPathSource !== headPath.state) {\n    throw new Error(`Paths cannot be joined`);\n  }\n\n  return {\n    state: tailPath.state,\n    // e.g. [A, B, C] + [C, D, E] = [A, B, C, D, E]\n    steps: headPath.steps.concat(tailPath.steps.slice(1)),\n    weight: headPath.weight + tailPath.weight\n  };\n}\n","import {\n  ActorScope,\n  ActorLogic,\n  ActorSystem,\n  EventObject,\n  Snapshot\n} from '../index.ts';\nimport {\n  SerializedEvent,\n  SerializedSnapshot,\n  TraversalOptions,\n  AdjacencyMap,\n  AdjacencyValue\n} from './types';\nimport { resolveTraversalOptions } from './graph.ts';\nimport { createMockActorScope } from './actorScope.ts';\n\nexport function getAdjacencyMap<\n  TSnapshot extends Snapshot<unknown>,\n  TEvent extends EventObject,\n  TInput,\n  TSystem extends ActorSystem<any> = ActorSystem<any>\n>(\n  logic: ActorLogic<TSnapshot, TEvent, TInput, TSystem>,\n  options: TraversalOptions<TSnapshot, TEvent, TInput>\n): AdjacencyMap<TSnapshot, TEvent> {\n  const { transition } = logic;\n  const {\n    serializeEvent,\n    serializeState,\n    events: getEvents,\n    limit,\n    fromState: customFromState,\n    stopWhen\n  } = resolveTraversalOptions(logic, options);\n  const actorScope = createMockActorScope() as ActorScope<\n    TSnapshot,\n    TEvent,\n    TSystem\n  >;\n  const fromState =\n    customFromState ??\n    logic.getInitialSnapshot(\n      actorScope,\n      // TODO: fix this\n      options.input as TInput\n    );\n  const adj: AdjacencyMap<TSnapshot, TEvent> = {};\n\n  let iterations = 0;\n  const queue: Array<{\n    nextState: TSnapshot;\n    event: TEvent | undefined;\n    prevState: TSnapshot | undefined;\n  }> = [{ nextState: fromState, event: undefined, prevState: undefined }];\n  const stateMap = new Map<SerializedSnapshot, TSnapshot>();\n\n  while (queue.length) {\n    const { nextState: state, event, prevState } = queue.shift()!;\n\n    if (iterations++ > limit) {\n      throw new Error('Traversal limit exceeded');\n    }\n\n    const serializedState = serializeState(\n      state,\n      event,\n      prevState\n    ) as SerializedSnapshot;\n    if (adj[serializedState]) {\n      continue;\n    }\n    stateMap.set(serializedState, state);\n\n    adj[serializedState] = {\n      state,\n      transitions: {}\n    };\n\n    if (stopWhen && stopWhen(state)) {\n      continue;\n    }\n\n    const events =\n      typeof getEvents === 'function' ? getEvents(state) : getEvents;\n\n    for (const nextEvent of events) {\n      const nextSnapshot = transition(state, nextEvent, actorScope);\n\n      adj[serializedState].transitions[\n        serializeEvent(nextEvent) as SerializedEvent\n      ] = {\n        event: nextEvent,\n        state: nextSnapshot\n      };\n      queue.push({\n        nextState: nextSnapshot,\n        event: nextEvent,\n        prevState: state\n      });\n    }\n  }\n\n  return adj;\n}\n\nexport function adjacencyMapToArray<TSnapshot, TEvent>(\n  adjMap: AdjacencyMap<TSnapshot, TEvent>\n): Array<{\n  state: TSnapshot;\n  event: TEvent;\n  nextState: TSnapshot;\n}> {\n  const adjList: Array<{\n    state: TSnapshot;\n    event: TEvent;\n    nextState: TSnapshot;\n  }> = [];\n\n  for (const adjValue of Object.values(adjMap)) {\n    for (const transition of Object.values(\n      (adjValue as AdjacencyValue<TSnapshot, TEvent>).transitions\n    )) {\n      adjList.push({\n        state: (adjValue as AdjacencyValue<TSnapshot, TEvent>).state,\n        event: transition.event,\n        nextState: transition.state\n      });\n    }\n  }\n\n  return adjList;\n}\n","import { StatePath } from './types.ts';\n\n// TODO: rewrite parts of the algorithm leading to this to make this function obsolete\nexport function alterPath<T extends StatePath<any, any>>(path: T): T {\n  let steps: T['steps'] = [];\n\n  if (!path.steps.length) {\n    steps = [\n      {\n        state: path.state,\n        event: { type: 'xstate.init' } as any\n      }\n    ];\n  } else {\n    for (let i = 0; i < path.steps.length; i++) {\n      const step = path.steps[i];\n\n      steps.push({\n        state: step.state,\n        event: i === 0 ? { type: 'xstate.init' } : path.steps[i - 1].event\n      });\n    }\n    steps.push({\n      state: path.state,\n      event: path.steps[path.steps.length - 1].event\n    });\n  }\n  return {\n    ...path,\n    steps\n  };\n}\n","import {\n  ActorScope,\n  ActorLogic,\n  ActorSystem,\n  AnyStateMachine,\n  EventObject,\n  Snapshot\n} from '../index.ts';\nimport { getAdjacencyMap } from './adjacency.ts';\nimport {\n  SerializedEvent,\n  SerializedSnapshot,\n  StatePath,\n  Steps,\n  TraversalOptions\n} from './types.ts';\nimport {\n  resolveTraversalOptions,\n  createDefaultMachineOptions,\n  createDefaultLogicOptions\n} from './graph.ts';\nimport { alterPath } from './alterPath.ts';\nimport { createMockActorScope } from './actorScope.ts';\n\nfunction isMachine(value: any): value is AnyStateMachine {\n  return !!value && '__xstatenode' in value;\n}\n\nexport function getPathsFromEvents<\n  TSnapshot extends Snapshot<unknown>,\n  TEvent extends EventObject,\n  TInput,\n  TSystem extends ActorSystem<any> = ActorSystem<any>\n>(\n  logic: ActorLogic<TSnapshot, TEvent, TInput, TSystem>,\n  events: TEvent[],\n  options?: TraversalOptions<TSnapshot, TEvent, TInput>\n): Array<StatePath<TSnapshot, TEvent>> {\n  const resolvedOptions = resolveTraversalOptions(\n    logic,\n    {\n      events,\n      ...options\n    },\n    (isMachine(logic)\n      ? createDefaultMachineOptions(logic)\n      : createDefaultLogicOptions()) as TraversalOptions<\n      TSnapshot,\n      TEvent,\n      TInput\n    >\n  );\n  const actorScope = createMockActorScope() as ActorScope<\n    TSnapshot,\n    TEvent,\n    TSystem\n  >;\n  const fromState =\n    resolvedOptions.fromState ??\n    logic.getInitialSnapshot(\n      actorScope,\n      // TODO: fix this\n      options?.input as TInput\n    );\n\n  const { serializeState, serializeEvent } = resolvedOptions;\n\n  const adjacency = getAdjacencyMap(logic, resolvedOptions);\n\n  const stateMap = new Map<SerializedSnapshot, TSnapshot>();\n  const steps: Steps<TSnapshot, TEvent> = [];\n\n  const serializedFromState = serializeState(\n    fromState,\n    undefined,\n    undefined\n  ) as SerializedSnapshot;\n  stateMap.set(serializedFromState, fromState);\n\n  let stateSerial = serializedFromState;\n  let state = fromState;\n  for (const event of events) {\n    steps.push({\n      state: stateMap.get(stateSerial)!,\n      event\n    });\n\n    const eventSerial = serializeEvent(event) as SerializedEvent;\n    const { state: nextState, event: _nextEvent } =\n      adjacency[stateSerial].transitions[eventSerial];\n\n    if (!nextState) {\n      throw new Error(\n        `Invalid transition from ${stateSerial} with ${eventSerial}`\n      );\n    }\n    const prevState = stateMap.get(stateSerial);\n    const nextStateSerial = serializeState(\n      nextState,\n      event,\n      prevState\n    ) as SerializedSnapshot;\n    stateMap.set(nextStateSerial, nextState);\n\n    stateSerial = nextStateSerial;\n    state = nextState;\n  }\n\n  // If it is expected to reach a specific state (`toState`) and that state\n  // isn't reached, there are no paths\n  if (resolvedOptions.toState && !resolvedOptions.toState(state)) {\n    return [];\n  }\n\n  return [\n    alterPath({\n      state,\n      steps,\n      weight: steps.length\n    })\n  ];\n}\n","import { AnyActorLogic, EventFromLogic, InputFrom } from '../index.ts';\nimport { getAdjacencyMap } from './adjacency.ts';\nimport { alterPath } from './alterPath.ts';\nimport { resolveTraversalOptions } from './graph.ts';\nimport {\n  SerializedEvent,\n  SerializedSnapshot,\n  StatePath,\n  StatePlanMap,\n  TraversalOptions\n} from './types.ts';\nimport { createMockActorScope } from './actorScope.ts';\n\nexport function getShortestPaths<TLogic extends AnyActorLogic>(\n  logic: TLogic,\n  options?: TraversalOptions<\n    ReturnType<TLogic['transition']>,\n    EventFromLogic<TLogic>,\n    InputFrom<TLogic>\n  >\n): Array<StatePath<ReturnType<TLogic['transition']>, EventFromLogic<TLogic>>> {\n  type TInternalState = ReturnType<TLogic['transition']>;\n  type TEvent = EventFromLogic<TLogic>;\n\n  const resolvedOptions = resolveTraversalOptions(logic, options);\n  const serializeState = resolvedOptions.serializeState as (\n    ...args: Parameters<typeof resolvedOptions.serializeState>\n  ) => SerializedSnapshot;\n  const fromState =\n    resolvedOptions.fromState ??\n    logic.getInitialSnapshot(createMockActorScope(), options?.input);\n  const adjacency = getAdjacencyMap(logic, resolvedOptions);\n\n  // weight, state, event\n  const weightMap = new Map<\n    SerializedSnapshot,\n    {\n      weight: number;\n      state: SerializedSnapshot | undefined;\n      event: TEvent | undefined;\n    }\n  >();\n  const stateMap = new Map<SerializedSnapshot, TInternalState>();\n  const serializedFromState = serializeState(fromState, undefined, undefined);\n  stateMap.set(serializedFromState, fromState);\n\n  weightMap.set(serializedFromState, {\n    weight: 0,\n    state: undefined,\n    event: undefined\n  });\n  const unvisited = new Set<SerializedSnapshot>();\n  const visited = new Set<SerializedSnapshot>();\n\n  unvisited.add(serializedFromState);\n  for (const serializedState of unvisited) {\n    const prevState = stateMap.get(serializedState);\n    const { weight } = weightMap.get(serializedState)!;\n    for (const event of Object.keys(\n      adjacency[serializedState].transitions\n    ) as SerializedEvent[]) {\n      const { state: nextState, event: eventObject } =\n        adjacency[serializedState].transitions[event];\n      const nextSerializedState = serializeState(\n        nextState,\n        eventObject,\n        prevState\n      );\n      stateMap.set(nextSerializedState, nextState);\n      if (!weightMap.has(nextSerializedState)) {\n        weightMap.set(nextSerializedState, {\n          weight: weight + 1,\n          state: serializedState,\n          event: eventObject\n        });\n      } else {\n        const { weight: nextWeight } = weightMap.get(nextSerializedState)!;\n        if (nextWeight > weight + 1) {\n          weightMap.set(nextSerializedState, {\n            weight: weight + 1,\n            state: serializedState,\n            event: eventObject\n          });\n        }\n      }\n      if (!visited.has(nextSerializedState)) {\n        unvisited.add(nextSerializedState);\n      }\n    }\n    visited.add(serializedState);\n    unvisited.delete(serializedState);\n  }\n\n  const statePlanMap: StatePlanMap<TInternalState, TEvent> = {};\n  const paths: Array<StatePath<TInternalState, TEvent>> = [];\n\n  weightMap.forEach(\n    ({ weight, state: fromState, event: fromEvent }, stateSerial) => {\n      const state = stateMap.get(stateSerial)!;\n      const steps = !fromState\n        ? []\n        : statePlanMap[fromState].paths[0].steps.concat({\n            state: stateMap.get(fromState)!,\n            event: fromEvent!\n          });\n\n      paths.push({\n        state,\n        steps,\n        weight\n      });\n      statePlanMap[stateSerial] = {\n        state,\n        paths: [\n          {\n            state,\n            steps,\n            weight\n          }\n        ]\n      };\n    }\n  );\n\n  if (resolvedOptions.toState) {\n    return paths\n      .filter((path) => resolvedOptions.toState!(path.state))\n      .map(alterPath);\n  }\n\n  return paths.map(alterPath);\n}\n","import { AnyActorLogic, EventFromLogic, InputFrom } from '../index.ts';\nimport {\n  SerializedEvent,\n  SerializedSnapshot,\n  StatePath,\n  Steps,\n  TraversalOptions,\n  VisitedContext\n} from './types.ts';\nimport { resolveTraversalOptions } from './graph.ts';\nimport { getAdjacencyMap } from './adjacency.ts';\nimport { alterPath } from './alterPath.ts';\nimport { createMockActorScope } from './actorScope.ts';\n\nexport function getSimplePaths<TLogic extends AnyActorLogic>(\n  logic: TLogic,\n  options?: TraversalOptions<\n    ReturnType<TLogic['transition']>,\n    EventFromLogic<TLogic>,\n    InputFrom<TLogic>\n  >\n): Array<StatePath<ReturnType<TLogic['transition']>, EventFromLogic<TLogic>>> {\n  type TState = ReturnType<TLogic['transition']>;\n  type TEvent = EventFromLogic<TLogic>;\n\n  const resolvedOptions = resolveTraversalOptions(logic, options);\n  const actorScope = createMockActorScope();\n  const fromState =\n    resolvedOptions.fromState ??\n    logic.getInitialSnapshot(actorScope, options?.input);\n  const serializeState = resolvedOptions.serializeState as (\n    ...args: Parameters<typeof resolvedOptions.serializeState>\n  ) => SerializedSnapshot;\n  const adjacency = getAdjacencyMap(logic, resolvedOptions);\n  const stateMap = new Map<SerializedSnapshot, TState>();\n  const visitCtx: VisitedContext<TState, TEvent> = {\n    vertices: new Set(),\n    edges: new Set()\n  };\n  const steps: Steps<TState, TEvent> = [];\n  const pathMap: Record<\n    SerializedSnapshot,\n    { state: TState; paths: Array<StatePath<TState, TEvent>> }\n  > = {};\n\n  function util(\n    fromStateSerial: SerializedSnapshot,\n    toStateSerial: SerializedSnapshot\n  ) {\n    const fromState = stateMap.get(fromStateSerial)!;\n    visitCtx.vertices.add(fromStateSerial);\n\n    if (fromStateSerial === toStateSerial) {\n      if (!pathMap[toStateSerial]) {\n        pathMap[toStateSerial] = {\n          state: stateMap.get(toStateSerial)!,\n          paths: []\n        };\n      }\n\n      const toStatePlan = pathMap[toStateSerial];\n\n      const path2: StatePath<TState, TEvent> = {\n        state: fromState,\n        weight: steps.length,\n        steps: [...steps]\n      };\n\n      toStatePlan.paths.push(path2);\n    } else {\n      for (const serializedEvent of Object.keys(\n        adjacency[fromStateSerial].transitions\n      ) as SerializedEvent[]) {\n        const { state: nextState, event: subEvent } =\n          adjacency[fromStateSerial].transitions[serializedEvent];\n\n        if (!(serializedEvent in adjacency[fromStateSerial].transitions)) {\n          continue;\n        }\n        const prevState = stateMap.get(fromStateSerial);\n\n        const nextStateSerial = serializeState(nextState, subEvent, prevState);\n        stateMap.set(nextStateSerial, nextState);\n\n        if (!visitCtx.vertices.has(nextStateSerial)) {\n          visitCtx.edges.add(serializedEvent);\n          steps.push({\n            state: stateMap.get(fromStateSerial)!,\n            event: subEvent\n          });\n          util(nextStateSerial, toStateSerial);\n        }\n      }\n    }\n\n    steps.pop();\n    visitCtx.vertices.delete(fromStateSerial);\n  }\n\n  const fromStateSerial = serializeState(fromState, undefined);\n  stateMap.set(fromStateSerial, fromState);\n\n  for (const nextStateSerial of Object.keys(\n    adjacency\n  ) as SerializedSnapshot[]) {\n    util(fromStateSerial, nextStateSerial);\n  }\n\n  const simplePaths = Object.values(pathMap).flatMap((p) => p.paths);\n\n  if (resolvedOptions.toState) {\n    return simplePaths\n      .filter((path) => resolvedOptions.toState!(path.state))\n      .map(alterPath);\n  }\n\n  return simplePaths.map(alterPath);\n}\n"],"names":["Mailbox","constructor","_process","this","_active","_current","_last","start","flush","clear","next","enqueue","event","enqueued","value","consumed","XSTATE_INIT","XSTATE_STOP","getDevTools","w","globalThis","self","window","__xstate__","devToolsAdapter","service","devTools","register","createDoneStateEvent","id","output","type","createInitEvent","input","reportUnhandledError","err","setTimeout","symbolObservable","Symbol","observable","matchesState","parentStateId","childStateId","parentStateValue","toStateValue","childStateValue","Object","keys","every","key","toStatePath","stateId","isArray","result","segment","i","length","charCodeAt","push","stateValue","isMachineSnapshot","statePath","marker","previous","pathToStateValue","mapValues","collection","iteratee","collectionKeys","toArrayStrict","toArray","undefined","resolveOutput","mapper","context","Array","toTransitionConfigArray","configLike","map","transitionLike","target","normalizeTarget","toObserver","nextHandler","errorHandler","completionHandler","isObserver","bind","error","complete","createInvokeId","stateNodeId","index","resolveReferencedActor","machine","src","match","implementations","actors","indexStr","nodeId","invokeConfig","getStateNodeById","config","invoke","getAllOwnEventDescriptors","snapshot","Set","_nodes","flatMap","sn","ownEvents","createScheduledEventId","actorRef","sessionId","idCounter","executingCustomAction","ProcessingStatus","defaultOptions","clock","fn","ms","clearTimeout","logger","console","log","Actor","logic","options","_snapshot","mailbox","observers","eventListeners","Map","_processingStatus","NotStarted","_parent","_syncSnapshot","ref","_actorScope","_systemId","system","_doneEvent","_deferred","resolvedOptions","parent","syncSnapshot","systemId","inspect","rootActor","children","keyedActors","reverseKeyedActors","WeakMap","inspectionObservers","timerMap","scheduler","schedule","source","delay","Math","random","toString","slice","scheduledEvent","startedAt","Date","now","scheduledEventId","_scheduledEvents","timeout","_relay","cancel","cancelAll","_bookId","_register","set","_unregister","delete","get","_set","existing","Error","observerOrFn","observer","add","unsubscribe","_sendInspectionEvent","size","resolvedInspectionEvent","rootId","forEach","sourceRef","_send","getSnapshot","scheduledEvents","scheduledId","_clock","_logger","createSystem","defer","stopChild","child","_stop","emit","emittedEvent","listeners","wildcardListener","allListeners","values","handler","actionExecutor","action","exec","params","saveExecutingCustomAction","info","Running","send","_initState","state","status","persistedState","restoreSnapshot","getInitialSnapshot","update","deferredFn","shift","_stopProcedure","_complete","invokeId","actorId","_error","subscribe","nextListenerOrObserver","errorListener","completeListener","Stopped","on","wrappedHandler","initEvent","attachDevTools","nextState","caughtError","transition","stop","_reportError","reportError","err2","toJSON","xstate$$type","getPersistedSnapshot","createActor","resolveCancel","_","actionArgs","actionParams","sendId","executeCancel","actorScope","resolveSpawn","_actionParams","resolvedId","resolvedInput","cloneMachineSnapshot","executeSpawn","spawnChild","_args","_params","resolve","execute","resolveStop","args","actorRefOrString","resolvedActorRef","executeStop","evaluateGuard","guard","isInline","resolved","guards","guardArgs","guardParams","check","isAtomicStateNode","stateNode","getChildren","states","filter","getProperAncestors","toStateNode","ancestors","m","getAllStateNodes","stateNodes","nodeSet","adjList","getAdjList","s","has","initialStates","getInitialStateNodesWithTheirAncestors","initialStateNode","getValueFromAdj","baseNode","childStateNodes","childStateNode","getStateValue","rootNode","isInFinalState","stateNodeSet","some","isStateId","str","getDelayedTransitions","afterConfig","after","mutateEntryExit","afterEvent","delayRef","eventType","entry","eventOrExpr","raise","resolveRaise","executeRaise","exit","configTransition","resolvedTransition","resolvedDelay","Number","isNaN","delayedTransition","formatTransition","descriptor","transitionConfig","normalizedTarget","reenter","targets","isInternalTarget","getStateNodeByPath","resolvedTarget","message","resolveTarget","actions","t","resolveHistoryDefaultTransition","initial","isHistoryNode","getInitialStateNodes","initialState","ancestor","iter","descStateNode","getStateNode","stateKey","arrayStatePath","currentStateNode","getStateNodes","childStateKeys","subStateKey","Boolean","root","concat","reduce","allSubStateNodes","subStateNode","subStateNodes","transitionNode","transitionAtomicNode","subStateKeys","transitionCompoundNode","allInnerTransitions","subStateValue","innerTransitions","transitionParallelNode","getHistoryNodes","isDescendant","parentStateNode","hasIntersection","s1","s2","set1","set2","item","removeConflictingTransitions","enabledTransitions","historyValue","filteredTransitions","t1","t1Preempted","transitionsToRemove","t2","computeExitSet","t3","from","getEffectiveTargetStates","targetNode","node","getTransitionDomain","targetStates","lca","head","tail","findLeastCommonAncestor","transitions","statesToExit","domain","microstep","currentSnapshot","isInitial","internalQueue","mutStateNodeSet","nextSnapshot","changedHistory","sort","a","b","order","exitStateNode","historyNode","predicate","history","resolveActionsAndContext","def","exitStates","statesToEnter","statesForDefaultEntry","addDescendantStatesToEnter","addAncestorStatesToEnter","computeEntrySet","completedNodes","stateNodeToEnter","invokeDef","onSnapshot","initialActions","ancestorMarker","rootCompletionNode","getMachineOutput","enterStates","nextStateNodes","prevStateNodes","nextStateNodeSet","areStateNodeCollectionsEqual","e","doneStateEvent","historyStateNodes","addProperAncestorStatesToEnter","historyDefaultTransition","reentrancyDomain","anc","getAction","actionType","resolveAndExecuteActionsWithContext","extra","retries","intermediateSnapshot","resolvedAction","name","builtinAction","deferredActorIds","retryResolve","macrostep","microstates","addMicrostate","microstate","_transitions","stopChildren","nextEvent","currentEvent","isErr","startsWith","isErrorActorEvent","selectTransitions","shouldSelectEventlessTransitions","selectEventlessTransitions","previousState","getTransitionData","enabledTransitionSet","atomicStates","loop","always","machineSnapshotMatches","testValue","machineSnapshotHasTag","tag","tags","machineSnapshotCan","transitionData","machineSnapshotToJSON","nodes","getMeta","can","hasTag","matches","jsonValues","machineSnapshotGetMeta","acc","meta","createMachineSnapshot","serializeHistoryValue","persistContext","contextPart","copy","createSpawner","spawnedChildren","spawn","resolveAssign","assignment","assignArgs","partialUpdate","propAssignment","assign","delaysMap","delays","resolvedEvent","configDelay","emptyLogic","initialContext","cache","memo","object","memoizedData","EMPTY_OBJECT","toSerializableAction","StateNode","path","description","_key","_machine","join","idMap","stateConfig","_initialize","transitionsConfig","onDone","onError","formatTransitions","definition","version","flat","sourceName","invokeDefValues","_target","formatInitialTransition","selectedTransition","candidates","getCandidates","receivedEventType","eventDescriptor","endsWith","partialEventTokens","split","eventTokens","tokenIndex","partialEventToken","eventToken","candidate","resolvedContext","guardPassed","guardType","events","StateMachine","schemas","__xstatenode","provide","resolveState","resolvedStateValue","getPreInitialState","preInitial","preInitialState","macroState","fullPath","relativePath","resolvedStateId","STATE_IDENTIFIER","childrenJson","snapshotChildren","resolveHistoryReferencedState","referenced","actorData","childState","revivedHistoryValue","revived","arr","reviveHistoryValue","restoredSnapshot","seen","reviveContext","simpleStringify","JSON","stringify","getDescription","contextString","stateStrings","trim","createShortestPathsGen","getShortestPaths","createSimplePathsGen","getSimplePaths","validateState","TestModel","getDefaultOptions","serializeState","serializeEvent","serializeTransition","stateMatcher","testLogic","defaultTraversalOptions","_toTestPath","eventsString","steps","other","formatEvent","test","testPath","getPaths","pathGenerator","allowDuplicatePaths","paths","_resolveOptions","deduplicatePaths","allPathsWithEventSequence","eventSequence","step","z","superpathsWithEventSequence","pathLoop","pathWithEventSequence","superpathLoop","superpathWithEventSequence","getShortestPathsFrom","resultPaths","shortestPaths","fromState","shortestPath","joinPaths","getSimplePathsFrom","getPathsFromEvents","getAdjacencyMap","testPathResult","testStepResult","testTransition","testState","formatColor","_color","string","targetStateString","errMessage","hasFailed","stateString","eventString","formatPathTestResult","stateTestKeys","_getStateTestKeys","stateTestKey","_getEventExec","eventExec","stateValuesEqual","aKeys","bKeys","serializeMachineTransition","previousSnapshot","prevStateString","createMockActorScope","emptyActor","serializeSnapshot","createDefaultMachineOptions","getEvents","otherOptions","__unsafe_getAllOwnEventDescriptors","matchingEvents","ev","createDefaultLogicOptions","resolveTraversalOptions","traversalOptions","resolvedDefaultOptions","isMachineLogic","limit","Infinity","toState","stopWhen","headPath","tailPath","weight","customFromState","adj","iterations","queue","prevState","stateMap","serializedState","alterPath","adjacency","serializedFromState","stateSerial","eventSerial","_nextEvent","nextStateSerial","weightMap","unvisited","visited","eventObject","nextSerializedState","nextWeight","statePlanMap","fromEvent","visitCtx","vertices","edges","pathMap","util","fromStateSerial","toStateSerial","toStatePlan","path2","serializedEvent","subEvent","pop","simplePaths","p","adjMap","adjValue","validateMachine","includes","accNodes","toDirectedGraph","stateMachine","transitionIndex","targetIndex","edge","label","text","graph","graphEdges"],"mappings":"mPAKO,MAAMA,EAKXC,WAAAA,CAAoBC,GAA2BC,KAA3BD,SAAAA,EAAyBC,KAJrCC,SAAmB,EAAKD,KACxBE,SAAkC,KAAIF,KACtCG,MAA+B,IAES,CAEzCC,KAAAA,GACLJ,KAAKC,SAAU,EACfD,KAAKK,OACP,CAEOC,KAAAA,GAGDN,KAAKE,WACPF,KAAKE,SAASK,KAAO,KACrBP,KAAKG,MAAQH,KAAKE,SAEtB,CAEOM,OAAAA,CAAQC,GACb,MAAMC,EAAW,CACfC,MAAOF,EACPF,KAAM,MAGR,GAAIP,KAAKE,SAGP,OAFAF,KAAKG,MAAOI,KAAOG,OACnBV,KAAKG,MAAQO,GAIfV,KAAKE,SAAWQ,EAChBV,KAAKG,MAAQO,EAETV,KAAKC,SACPD,KAAKK,OAET,CAEQA,KAAAA,GACN,KAAOL,KAAKE,UAAU,CAGpB,MAAMU,EAAWZ,KAAKE,SACtBF,KAAKD,SAASa,EAASD,OACvBX,KAAKE,SAAWU,EAASL,IAC3B,CACAP,KAAKG,MAAQ,IACf,ECvDK,MAKMU,EAAc,cAEdC,EAAc,cCiC3B,SAASC,IACP,MAAMC,EApBoB,oBAAfC,WACFA,WAEW,oBAATC,KACFA,KAGAC,OAcT,GAAKH,EAAUI,WACb,OAAQJ,EAAUI,UAItB,CAcO,MAAMC,EAAoCC,IAK/C,MAAMC,EAAWR,IAEbQ,GACFA,EAASC,SAASF,IChDf,SAASG,EACdC,EACAC,GAEA,MAAO,CACLC,KAAM,qBAAqBF,IAC3BC,SAEJ,CA6BO,SAASE,EAAgBC,GAC9B,MAAO,CAAEF,KAAMf,EAAaiB,QAC9B,CCpDO,SAASC,EAAqBC,GACnCC,YAAW,KACT,MAAMD,IAEV,CCZO,MAAME,EACQ,mBAAXC,QAAyBA,OAAOC,YACxC,eCqBK,SAASC,EACdC,EACAC,GAEA,MAAMC,EAAmBC,EAAaH,GAChCI,EAAkBD,EAAaF,GAErC,MAA+B,iBAApBG,EACuB,iBAArBF,GACFE,IAAoBF,EAOC,iBAArBA,EACFA,KAAoBE,EAGtBC,OAAOC,KAAKJ,GAAkBK,OAAOC,GACpCA,KAAOJ,GAINL,EAAaG,EAAiBM,GAAOJ,EAAgBI,KAEhE,CAEO,SAASC,EAAYC,GAC1B,GAAIC,EAAQD,GACV,OAAOA,EAGT,MAAME,EAAmB,GACzB,IAAIC,EAAU,GAEd,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAAQK,OAAQD,IAAK,CAEvC,OADaJ,EAAQM,WAAWF,IAG9B,KAAK,GAEHD,GAAWH,EAAQI,EAAI,GAEvBA,IACA,SAEF,KAAK,GACHF,EAAOK,KAAKJ,GACZA,EAAU,GACV,SAEJA,GAAWH,EAAQI,EACrB,CAIA,OAFAF,EAAOK,KAAKJ,GAELD,CACT,CAEA,SAAST,EAAae,GACpB,GAAIC,GAAkBD,GACpB,OAAOA,EAAW7C,MAGpB,GAA0B,iBAAf6C,EACT,OAAOA,EAKT,OAGK,SAA0BE,GAC/B,GAAyB,IAArBA,EAAUL,OACZ,OAAOK,EAAU,GAGnB,MAAM/C,EAAoB,CAAA,EAC1B,IAAIgD,EAAShD,EAEb,IAAK,IAAIyC,EAAI,EAAGA,EAAIM,EAAUL,OAAS,EAAGD,IACxC,GAAIA,IAAMM,EAAUL,OAAS,EAC3BM,EAAOD,EAAUN,IAAMM,EAAUN,EAAI,OAChC,CACL,MAAMQ,EAAWD,EACjBA,EAAS,CAAA,EACTC,EAASF,EAAUN,IAAMO,CAC3B,CAGF,OAAOhD,CACT,CAtBSkD,CAFWd,EAAYS,GAGhC,CA2BO,SAASM,EACdC,EACAC,GAOA,MAAMd,EAAkC,CAAA,EAElCe,EAAiBtB,OAAOC,KAAKmB,GACnC,IAAK,IAAIX,EAAI,EAAGA,EAAIa,EAAeZ,OAAQD,IAAK,CAC9C,MAAMN,EAAMmB,EAAeb,GAC3BF,EAAOJ,GAAOkB,EAASD,EAAWjB,GAAMA,EAAKiB,EAAYX,EAC3D,CAEA,OAAOF,CACT,CAEA,SAASgB,EAAiBvD,GACxB,OAAIsC,EAAQtC,GACHA,EAEF,CAACA,EACV,CAEO,SAASwD,EAAWxD,GACzB,YAAcyD,IAAVzD,EACK,GAEFuD,EAAcvD,EACvB,CAEO,SAAS0D,EAIdC,EAGAC,EACA9D,EACAS,GAEA,MAAsB,mBAAXoD,EACFA,EAAO,CAAEC,UAAS9D,QAAOS,SAwB3BoD,CACT,CAEA,SAASrB,EAAQtC,GACf,OAAO6D,MAAMvB,QAAQtC,EACvB,CAQO,SAAS8D,EACdC,GAEA,OAAOR,EAAcQ,GAAYC,KAAKC,QAER,IAAnBA,GACmB,iBAAnBA,EAEA,CAAEC,OAAQD,GAGZA,GAEX,CAEO,SAASE,EAIdD,GAEA,QAAeT,IAAXS,GLlOwB,KKkOAA,EAG5B,OAAOV,EAAQU,EACjB,CAEO,SAASE,EACdC,EACAC,EACAC,GAEA,MAAMC,EAAoC,iBAAhBH,EACpB9D,EAAOiE,EAAaH,OAAcZ,EAExC,MAAO,CACL7D,MAAO4E,EAAaH,EAAYzE,KAAOyE,IAAcI,KAAKlE,GAC1DmE,OAAQF,EAAaH,EAAYK,MAAQJ,IAAeG,KAAKlE,GAC7DoE,UAAWH,EAAaH,EAAYM,SAAWJ,IAAoBE,KACjElE,GAGN,CAEO,SAASqE,EAAeC,EAAqBC,GAClD,MAAO,GAAGA,KAASD,GACrB,CAEO,SAASE,EAAuBC,EAA0BC,GAC/D,MAAMC,EAAQD,EAAIC,MAAM,gCACxB,IAAKA,EACH,OAAOF,EAAQG,gBAAgBC,OAAOH,GAExC,OAASI,EAAUC,GAAUJ,EAEvBK,EADOP,EAAQQ,iBAAiBF,GACZG,OAAOC,OACjC,OACE7B,MAAMvB,QAAQiD,GACVA,EAAaF,GACZE,GAULN,GACJ,CAEO,SAASU,EAA0BC,GACxC,MAAO,IAAI,IAAIC,IAAI,IAAID,EAASE,OAAOC,SAASC,GAAOA,EAAGC,cAC5D,CChPA,SAASC,EACPC,EACApF,GAEA,MAAO,GAAGoF,EAASC,aAAarF,GAClC,CA2CA,IAAIsF,EAAY,ECjET,IAAIC,GAAiC,EA4BhCC,IAAAA,WAAAA,GAAgB,OAAhBA,EAAAA,EAAgB,WAAA,GAAA,aAAhBA,EAAAA,EAAgB,QAAA,GAAA,UAAhBA,EAAAA,EAAgB,QAAA,GAAA,UAAhBA,CAAgB,EAAA,CAAA,GAM5B,MAAMC,EAAiB,CACrBC,MAAO,CACLnF,WAAYA,CAACoF,EAAIC,IACRrF,WAAWoF,EAAIC,GAExBC,aAAe7F,GACN6F,aAAa7F,IAGxB8F,OAAQC,QAAQC,IAAItC,KAAKqC,SACzBlG,UAAU,GAQL,MAAMoG,EAiEX7H,WAAAA,CACS8H,EACPC,GACA7H,KAFO4H,MAAAA,EA9DT5H,KACQ8H,eAAS,EACjB9H,KAIOoH,WAAK,EAAApH,KACL6H,aAAO,EAEd7H,KACO0B,QAAE,EAAA1B,KAED+H,QAA2C,IAAIlI,EACrDG,KAAKD,SAASqF,KAAKpF,OACpBA,KAEOgI,UAAiD,IAAIxB,IAAKxG,KAC1DiI,eAGJ,IAAIC,IAAKlI,KACLwH,YAAM,EAEdxH,KACOmI,kBAAsCjB,EAAiBkB,WAE9DpI,KACOqI,aAAO,EACdrI,KACOsI,mBAAa,EAAAtI,KACbuI,SAAG,EAKVvI,KACQwI,iBAAW,EAAAxI,KAOXyI,eAAS,EAEjBzI,KACO+G,eAAS,EAEhB/G,KACO0I,YAAM,EAAA1I,KACL2I,gBAAU,EAAA3I,KAEX4F,SAAG,EA+IV5F,KACQ4I,UAA+B,GAnIrC,MAAMC,EAAkB,IACnB1B,KACAU,IAGCT,MAAEA,EAAKI,OAAEA,EAAMsB,OAAEA,EAAMC,aAAEA,EAAYrH,GAAEA,EAAEsH,SAAEA,EAAQC,QAAEA,GACzDJ,EAEF7I,KAAK0I,OAASI,EACVA,EAAOJ,ODhER,SACLQ,EACArB,GAMA,MAAMsB,EAAW,IAAIjB,IACfkB,EAAc,IAAIlB,IAClBmB,EAAqB,IAAIC,QACzBC,EAAsB,IAAI/C,IAC1BgD,EAA+C,CAAA,GAC/CpC,MAAEA,EAAKI,OAAEA,GAAWK,EAEpB4B,EAAuB,CAC3BC,SAAUA,CACRC,EACA9E,EACApE,EACAmJ,EACAlI,EAAKmI,KAAKC,SAASC,SAAS,IAAIC,MAAM,MAEtC,MAAMC,EAAiC,CACrCN,SACA9E,SACApE,QACAmJ,QACAlI,KACAwI,UAAWC,KAAKC,OAEZC,EAAmBxD,EAAuB8C,EAAQjI,GACxDgH,EAAOZ,UAAUwC,iBAAiBD,GAAoBJ,EAEtD,MAAMM,EAAUnD,EAAMnF,YAAW,YACxBuH,EAASa,UACT3B,EAAOZ,UAAUwC,iBAAiBD,GAEzC3B,EAAO8B,OAAOb,EAAQ9E,EAAQpE,KAC7BmJ,GAEHJ,EAASa,GAAoBE,GAE/BE,OAAQA,CAACd,EAAQjI,KACf,MAAM2I,EAAmBxD,EAAuB8C,EAAQjI,GAClD6I,EAAUf,EAASa,UAElBb,EAASa,UACT3B,EAAOZ,UAAUwC,iBAAiBD,QAEzBjG,IAAZmG,GACFnD,EAAMG,aAAagD,IAGvBG,UAAY5D,IACV,IAAK,MAAMuD,KAAoB3B,EAAOZ,UAAUwC,iBAAkB,CAChE,MAAML,EACJvB,EAAOZ,UAAUwC,iBACfD,GAEAJ,EAAeN,SAAW7C,GAC5B2C,EAAUgB,OAAO3D,EAAUmD,EAAevI,GAE9C,IAgBEgH,EAAyB,CAC7BZ,UAAW,CACTwC,kBACGzC,GAAStB,UAAasB,EAAQtB,SAAiBkD,YAAc,CAAC,GAEnEkB,QAASA,IAAM,KAAK3D,IACpB4D,UAAWA,CAAC7D,EAAWD,KACrBqC,EAAS0B,IAAI9D,EAAWD,GACjBC,GAET+D,YAAchE,IACZqC,EAAS4B,OAAOjE,EAASC,WACzB,MAAMiC,EAAWK,EAAmB2B,IAAIlE,QAEvB1C,IAAb4E,IACFI,EAAY2B,OAAO/B,GACnBK,EAAmB0B,OAAOjE,KAG9BkE,IAAMhC,GACGI,EAAY4B,IAAIhC,GAEzBiC,KAAMA,CAACjC,EAAUlC,KACf,MAAMoE,EAAW9B,EAAY4B,IAAIhC,GACjC,GAAIkC,GAAYA,IAAapE,EAC3B,MAAM,IAAIqE,MACR,yBAAyBnC,sBAI7BI,EAAYyB,IAAI7B,EAAUlC,GAC1BuC,EAAmBwB,IAAI/D,EAAUkC,IAEnCC,QAAUmC,IACR,MAAMC,EAAWtG,EAAWqG,GAG5B,OAFA7B,EAAoB+B,IAAID,GAEjB,CACLE,WAAAA,GACEhC,EAAoBwB,OAAOM,EAC7B,IAGJG,qBAxD2B/K,IAC3B,IAAK8I,EAAoBkC,KACvB,OAEF,MAAMC,EAA2C,IAC5CjL,EACHkL,OAAQzC,EAAUnC,WAEpBwC,EAAoBqC,SAASP,GAC3BA,EAAS9K,OAAOmL,MAgDlBlB,OAAQA,CAACb,EAAQ9E,EAAQpE,KACvBiI,EAAO8C,qBAAqB,CAC1B5J,KAAM,gBACNiK,UAAWlC,EACX7C,SAAUjC,EACVpE,UAGFoE,EAAOiH,MAAMrL,IAEfgJ,YACAsC,YAAaA,KACJ,CACLzB,iBAAkB,IAAK5B,EAAOZ,UAAUwC,oBAG5ClK,MAAOA,KACL,MAAM4L,EAAkBtD,EAAOZ,UAAUwC,iBACzC5B,EAAOZ,UAAUwC,iBAAmB,GACpC,IAAK,MAAM2B,KAAeD,EAAiB,CACzC,MAAMrC,OAAEA,EAAM9E,OAAEA,EAAMpE,MAAEA,EAAKmJ,MAAEA,EAAKlI,GAAEA,GACpCsK,EAAgBC,GAClBxC,EAAUC,SAASC,EAAQ9E,EAAQpE,EAAOmJ,EAAOlI,EACnD,GAEFwK,OAAQ9E,EACR+E,QAAS3E,GAGX,OAAOkB,CACT,CCxFQ0D,CAAapM,KAAM,CACjBoH,QACAI,WAGFyB,IAAYH,GAEd9I,KAAK0I,OAAOO,QAAQlE,EAAWkE,IAGjCjJ,KAAK+G,UAAY/G,KAAK0I,OAAOiC,UAC7B3K,KAAK0B,GAAKA,GAAM1B,KAAK+G,UACrB/G,KAAKwH,OAASK,GAASL,QAAUxH,KAAK0I,OAAOyD,QAC7CnM,KAAKoH,MAAQS,GAAST,OAASpH,KAAK0I,OAAOwD,OAC3ClM,KAAKqI,QAAUS,EACf9I,KAAKsI,cAAgBS,EACrB/I,KAAK6H,QAAUgB,EAEf7I,KAAK4F,IAAMiD,EAAgBjD,KAAOgC,EAClC5H,KAAKuI,IAAMvI,KACXA,KAAKwI,YAAc,CACjBtH,KAAMlB,KACN0B,GAAI1B,KAAK0B,GACTqF,UAAW/G,KAAK+G,UAChBS,OAAQxH,KAAKwH,OACb6E,MAAQhF,IACNrH,KAAK4I,UAAUrF,KAAK8D,IAEtBqB,OAAQ1I,KAAK0I,OACb4D,UAAYC,IACV,GAAIA,EAAMlE,UAAYrI,KACpB,MAAM,IAAImL,MACR,2BAA2BoB,EAAM7K,SAAS1B,KAAK0B,gCAGlD6K,EAAcC,SAEjBC,KAAOC,IACL,MAAMC,EAAY3M,KAAKiI,eAAe+C,IAAI0B,EAAa9K,MACjDgL,EAAmB5M,KAAKiI,eAAe+C,IAAI,KACjD,IAAK2B,IAAcC,EACjB,OAEF,MAAMC,EAAe,IACfF,EAAYA,EAAUG,SAAW,MACjCF,EAAmBA,EAAiBE,SAAW,IAErD,IAAK,MAAMC,KAAWF,EACpBE,EAAQL,IAGZM,eAAiBC,IACf,MAAMC,EAAOA,KASX,GARAlN,KAAKwI,YAAYE,OAAO8C,qBAAqB,CAC3C5J,KAAM,iBACNkF,SAAU9G,KACViN,OAAQ,CACNrL,KAAMqL,EAAOrL,KACbuL,OAAQF,EAAOE,WAGdF,EAAOC,KACV,OAEF,MAAME,EAA4BnG,EAClC,IACEA,GAAwB,EACxBgG,EAAOC,KAAKD,EAAOI,KAAMJ,EAAOE,OAClC,CAAU,QACRlG,EAAwBmG,CAC1B,GAEEpN,KAAKmI,oBAAsBjB,EAAiBoG,QAC9CJ,IAEAlN,KAAK4I,UAAUrF,KAAK2J,KAO1BlN,KAAKuN,KAAOvN,KAAKuN,KAAKnI,KAAKpF,MAE3BA,KAAK0I,OAAO8C,qBAAqB,CAC/B5J,KAAM,gBACNkF,SAAU9G,OAGRgJ,IACFhJ,KAAKyI,UAAYO,EACjBhJ,KAAK0I,OAAOuC,KAAKjC,EAAUhJ,OAG7BA,KAAKwN,WAAW3F,GAAStB,UAAYsB,GAAS4F,OAE1CzE,GAA+C,WAAlChJ,KAAK8H,UAAkB4F,QACtC1N,KAAK0I,OAAOoC,YAAY9K,KAE5B,CAEQwN,UAAAA,CAAWG,GACjB,IACE3N,KAAK8H,UAAY6F,EACb3N,KAAK4H,MAAMgG,gBACT5N,KAAK4H,MAAMgG,gBAAgBD,EAAgB3N,KAAKwI,aAChDmF,EACF3N,KAAK4H,MAAMiG,mBAAmB7N,KAAKwI,YAAaxI,KAAK6H,SAAS/F,MACnE,CAAC,MAAOE,GAIPhC,KAAK8H,UAAY,CACf4F,OAAQ,QACR/L,YAAQyC,EACRiB,MAAOrD,EAEX,CACF,CAKQ8L,MAAAA,CAAOvH,EAAgC9F,GAK7C,IAAIsN,EAEJ,IALA/N,KAAK8H,UAAYvB,EAKTwH,EAAa/N,KAAK4I,UAAUoF,SAClC,IACED,GACD,CAAC,MAAO/L,GAMPhC,KAAK4I,UAAUvF,OAAS,EACxBrD,KAAK8H,UAAY,IACXvB,EACJmH,OAAQ,QACRrI,MAAOrD,EAEX,CAGF,OAAShC,KAAK8H,UAAkB4F,QAC9B,IAAK,SACH,IAAK,MAAMrC,KAAYrL,KAAKgI,UAC1B,IACEqD,EAAS9K,OAAOgG,EACjB,CAAC,MAAOvE,GACPD,EAAqBC,EACvB,CAEF,MACF,IAAK,OAOH,IAAK,MAAMqJ,KAAYrL,KAAKgI,UAC1B,IACEqD,EAAS9K,OAAOgG,EACjB,CAAC,MAAOvE,GACPD,EAAqBC,EACvB,CAGFhC,KAAKiO,iBACLjO,KAAKkO,YACLlO,KAAK2I,YLhSXwF,EKiSQnO,KAAK0B,GLhSbC,EKiSS3B,KAAK8H,UAAkBnG,OL/RzB,CACLC,KAAM,qBAAqBuM,IAC3BxM,SACAyM,QAASD,IK8RDnO,KAAKqI,SACPrI,KAAK0I,OAAO8B,OAAOxK,KAAMA,KAAKqI,QAASrI,KAAK2I,YAG9C,MACF,IAAK,QACH3I,KAAKqO,OAAQrO,KAAK8H,UAAkBzC,OL3SrC,IACL8I,EACAxM,EK4SE3B,KAAK0I,OAAO8C,qBAAqB,CAC/B5J,KAAM,mBACNkF,SAAU9G,KACVS,QACA8F,YAEJ,CAmEO+H,SAAAA,CACLC,EAGAC,EACAC,GAEA,MAAMpD,EAAWtG,EACfwJ,EACAC,EACAC,GAGF,GAAIzO,KAAKmI,oBAAsBjB,EAAiBwH,QAC9C1O,KAAKgI,UAAUsD,IAAID,QAEnB,OAASrL,KAAK8H,UAAkB4F,QAC9B,IAAK,OACH,IACErC,EAAS/F,YACV,CAAC,MAAOtD,GACPD,EAAqBC,EACvB,CACA,MACF,IAAK,QAAS,CACZ,MAAMA,EAAOhC,KAAK8H,UAAkBzC,MACpC,GAAKgG,EAAShG,MAGZ,IACEgG,EAAShG,MAAMrD,EAChB,CAAC,MAAOA,GACPD,EAAqBC,EACvB,MANAD,EAAqBC,GAQvB,KACF,EAIJ,MAAO,CACLuJ,YAAaA,KACXvL,KAAKgI,UAAU+C,OAAOM,IAG5B,CAEOsD,EAAAA,CACL/M,EACAmL,GAKA,IAAIJ,EAAY3M,KAAKiI,eAAe+C,IAAIpJ,GACnC+K,IACHA,EAAY,IAAInG,IAChBxG,KAAKiI,eAAe4C,IAAIjJ,EAAM+K,IAEhC,MAAMiC,EAAiB7B,EAAQ3H,UAAKhB,GAGpC,OAFAuI,EAAUrB,IAAIsD,GAEP,CACLrD,YAAaA,KACXoB,EAAU5B,OAAO6D,IAGvB,CAGOxO,KAAAA,GACL,GAAIJ,KAAKmI,oBAAsBjB,EAAiBoG,QAE9C,OAAOtN,KAGLA,KAAKsI,eACPtI,KAAKsO,UAAU,CACb/N,KAAOgG,IACmB,WAApBA,EAASmH,QACX1N,KAAK0I,OAAO8B,OAAOxK,KAAMA,KAAKqI,QAAU,CACtCzG,KAAM,mBAAmB5B,KAAK0B,KAC9B6E,cAINlB,MAAOA,SAIXrF,KAAK0I,OAAOkC,UAAU5K,KAAK+G,UAAW/G,MAClCA,KAAKyI,WACPzI,KAAK0I,OAAOuC,KAAKjL,KAAKyI,UAAWzI,MAEnCA,KAAKmI,kBAAoBjB,EAAiBoG,QAG1C,MAAMuB,EAAYhN,EAAgB7B,KAAK6H,QAAQ/F,OAE/C9B,KAAK0I,OAAO8C,qBAAqB,CAC/B5J,KAAM,gBACNiK,UAAW7L,KAAKqI,QAChBvB,SAAU9G,KACVS,MAAOoO,IAKT,OAFgB7O,KAAK8H,UAAkB4F,QAGrC,IAAK,OAQH,OALA1N,KAAK8N,OACH9N,KAAK8H,UACL+G,GAGK7O,KACT,IAAK,QAEH,OADAA,KAAKqO,OAAQrO,KAAK8H,UAAkBzC,OAC7BrF,KAOX,GAJKA,KAAKqI,SACRrI,KAAK0I,OAAOtI,QAGVJ,KAAK4H,MAAMxH,MACb,IACEJ,KAAK4H,MAAMxH,MAAMJ,KAAK8H,UAAW9H,KAAKwI,YACvC,CAAC,MAAOxG,GAOP,OANAhC,KAAK8H,UAAY,IACX9H,KAAK8H,UACT4F,OAAQ,QACRrI,MAAOrD,GAEThC,KAAKqO,OAAOrM,GACLhC,IACT,CAcF,OARAA,KAAK8N,OAAO9N,KAAK8H,UAAW+G,GAExB7O,KAAK6H,QAAQtG,UACfvB,KAAK8O,iBAGP9O,KAAK+H,QAAQ3H,QAENJ,IACT,CAEQD,QAAAA,CAASU,GACf,IAAIsO,EACAC,EACJ,IACED,EAAY/O,KAAK4H,MAAMqH,WACrBjP,KAAK8H,UACLrH,EACAT,KAAKwI,YAER,CAAC,MAAOxG,GAEPgN,EAAc,CAAEhN,MAClB,CAEA,GAAIgN,EAAa,CACf,MAAMhN,IAAEA,GAAQgN,EAQhB,OANAhP,KAAK8H,UAAY,IACX9H,KAAK8H,UACT4F,OAAQ,QACRrI,MAAOrD,QAEThC,KAAKqO,OAAOrM,EAEd,CAEAhC,KAAK8N,OAAOiB,EAAWtO,GACnBA,EAAMmB,OAASd,IACjBd,KAAKiO,iBACLjO,KAAKkO,YAET,CAEQ1B,KAAAA,GACN,OAAIxM,KAAKmI,oBAAsBjB,EAAiBwH,QACvC1O,MAETA,KAAK+H,QAAQzH,QACTN,KAAKmI,oBAAsBjB,EAAiBkB,YAC9CpI,KAAKmI,kBAAoBjB,EAAiBwH,QACnC1O,OAETA,KAAK+H,QAAQvH,QAAQ,CAAEoB,KAAMd,IAEtBd,MACT,CAGOkP,IAAAA,GACL,GAAIlP,KAAKqI,QACP,MAAM,IAAI8C,MAAM,gDAElB,OAAOnL,KAAKwM,OACd,CACQ0B,SAAAA,GACN,IAAK,MAAM7C,KAAYrL,KAAKgI,UAC1B,IACEqD,EAAS/F,YACV,CAAC,MAAOtD,GACPD,EAAqBC,EACvB,CAEFhC,KAAKgI,UAAU1H,OACjB,CACQ6O,YAAAA,CAAanN,GACnB,IAAKhC,KAAKgI,UAAUyD,KAIlB,YAHKzL,KAAKqI,SACRtG,EAAqBC,IAIzB,IAAIoN,GAAc,EAElB,IAAK,MAAM/D,KAAYrL,KAAKgI,UAAW,CACrC,MAAMwG,EAAgBnD,EAAShG,MAC/B+J,KAAiBZ,EACjB,IACEA,IAAgBxM,EACjB,CAAC,MAAOqN,GACPtN,EAAqBsN,EACvB,CACF,CACArP,KAAKgI,UAAU1H,QACX8O,GACFrN,EAAqBC,EAEzB,CACQqM,MAAAA,CAAOrM,GL9lBV,IACLN,EK8lBE1B,KAAKiO,iBACLjO,KAAKmP,aAAanN,GACdhC,KAAKqI,SACPrI,KAAK0I,OAAO8B,OACVxK,KACAA,KAAKqI,QLhmBJ,CAAEzG,KAAM,sBAHfF,EKomB4B1B,KAAK0B,KLjmBU2D,MKimBNrD,ELjmBaoM,QAAS1M,GKomB3D,CAMQuM,cAAAA,GACN,OAAIjO,KAAKmI,oBAAsBjB,EAAiBoG,UAMhDtN,KAAK0I,OAAOe,UAAUiB,UAAU1K,MAGhCA,KAAK+H,QAAQzH,QAKbN,KAAK+H,QAAU,IAAIlI,EAAQG,KAAKD,SAASqF,KAAKpF,OAE9CA,KAAKmI,kBAAoBjB,EAAiBwH,QAC1C1O,KAAK0I,OAAOoC,YAAY9K,OAffA,IAkBX,CAGO8L,KAAAA,CAAMrL,GACPT,KAAKmI,oBAAsBjB,EAAiBwH,SAYhD1O,KAAK+H,QAAQvH,QAAQC,EACvB,CAOO8M,IAAAA,CAAK9M,GAMVT,KAAK0I,OAAO8B,YAAOpG,EAAWpE,KAAMS,EACtC,CAEQqO,cAAAA,GACN,MAAMvN,SAAEA,GAAavB,KAAK6H,QAC1B,GAAItG,EAAU,EAEU,mBAAbA,EAA0BA,EAAWF,GAEtBrB,KAC1B,CACF,CACOsP,MAAAA,GACL,MAAO,CACLC,aAlrBsB,EAmrBtB7N,GAAI1B,KAAK0B,GAEb,CAgBO8N,oBAAAA,CAAqB3H,GAC1B,OAAO7H,KAAK4H,MAAM4H,qBAAqBxP,KAAK8H,UAAWD,EACzD,CAEA,CAAQ3F,KACN,OAAOlC,IACT,CAgBO+L,WAAAA,GAML,OAAO/L,KAAK8H,SACd,EA4CK,SAAS2H,EACd7H,MACIC,IASJ,OAAO,IAAIF,EAAMC,EAAOC,EAC1B,CCnzBA,SAAS6H,EACPC,EACApJ,EACAqJ,EACAC,GACAC,OAAEA,IAIF,MAAO,CAACvJ,EAAU,CAAEuJ,OADA,mBAAXA,EAAwBA,EAAOF,EAAYC,GAAgBC,QACtB1L,EAChD,CAEA,SAAS2L,EAAcC,EAA2B7C,GAChD6C,EAAW3D,OAAM,KACf2D,EAAWtH,OAAOe,UAAUgB,OAAOuF,EAAW9O,KAAMiM,EAAO2C,UAE/D,CCPA,SAASG,EACPD,EACAzJ,EACAqJ,EACAM,GACAxO,GACEA,EAAEsH,SACFA,EAAQpD,IACRA,EAAG9D,MACHA,EAAKiH,aACLA,IASF,MAAMnB,EACW,iBAARhC,EACHF,EAAuBa,EAASZ,QAASC,GACzCA,EACAuK,EAA2B,mBAAPzO,EAAoBA,EAAGkO,GAAclO,EAC/D,IAAIoF,EACAsJ,EA2BJ,OAzBIxI,IACFwI,EACmB,mBAAVtO,EACHA,EAAM,CACJyC,QAASgC,EAAShC,QAClB9D,MAAOmP,EAAWnP,MAClBS,KAAM8O,EAAW9O,OAEnBY,EACNgF,EAAW2I,EAAY7H,EAAO,CAC5BlG,GAAIyO,EACJvK,MACAkD,OAAQkH,EAAW9O,KACnB6H,eACAC,WACAlH,MAAOsO,KAUJ,CACLC,GAAqB9J,EAAU,CAC7B4C,SAAU,IACL5C,EAAS4C,SACZgH,CAACA,GAAarJ,KAGlB,CACEpF,KACAsH,WACAlC,WACAlB,MACA9D,MAAOsO,QAEThM,EAEJ,CAEA,SAASkM,EACPN,GACAlJ,SAAEA,IAEGA,GAILkJ,EAAW3D,OAAM,KACXvF,EAASqB,oBAAsBjB,EAAiBwH,SAGpD5H,EAAS1G,UAEb,CA6EO,SAASmQ,MAQZ3K,GACAlE,GAAEA,EAAEsH,SAAEA,EAAQlH,MAAEA,EAAKiH,aAAEA,GAAe,GAAU,CAAS,IAa3D,SAASwH,EACPC,EACAC,GAKF,CAYA,OAVAF,EAAW3O,KAAO,oBAClB2O,EAAW7O,GAAKA,EAChB6O,EAAWvH,SAAWA,EACtBuH,EAAW3K,IAAMA,EACjB2K,EAAWzO,MAAQA,EACnByO,EAAWxH,aAAeA,EAE1BwH,EAAWG,QAAUT,EACrBM,EAAWI,QAAUL,EAEdC,CACT,CChNA,SAASK,EACPjB,EACApJ,EACAsK,EACAhB,GACA/I,SAAEA,IAEF,MAAMgK,EACgB,mBAAbhK,EAA0BA,EAAS+J,EAAMhB,GAAgB/I,EAC5DiK,EACwB,iBAArBD,EACHvK,EAAS4C,SAAS2H,GAClBA,EAEN,IAAI3H,EAAW5C,EAAS4C,SAKxB,OAJI4H,IACF5H,EAAW,IAAKA,UACTA,EAAS4H,EAAiBrP,KAE5B,CACL2O,GAAqB9J,EAAU,CAC7B4C,aAEF4H,OACA3M,EAEJ,CACA,SAAS4M,EACPhB,EACAlJ,GAEKA,IAOLkJ,EAAWtH,OAAOoC,YAAYhE,GAI1BA,EAASqB,oBAAsBjB,EAAiBoG,QAQpD0C,EAAW3D,OAAM,KACf2D,EAAW1D,UAAUxF,MARrBkJ,EAAW1D,UAAUxF,GAUzB,CAgBO,SAASwF,EAMdxF,GAEA,SAASoI,EACPsB,EACAC,GAKF,CAQA,OANAvB,EAAKtN,KAAO,mBACZsN,EAAKpI,SAAWA,EAEhBoI,EAAKwB,QAAUE,EACf1B,EAAKyB,QAAUK,EAER9B,CACT,CCwNO,SAAS+B,EAIdC,EACA3M,EACA9D,EACA8F,GAEA,MAAMZ,QAAEA,GAAYY,EACd4K,EAA4B,mBAAVD,EAElBE,EAAWD,EACbD,EACAvL,EAAQG,gBAAgBuL,OACL,iBAAVH,EAAqBA,EAAQA,EAAMtP,MAGhD,IAAKuP,IAAaC,EAChB,MAAM,IAAIjG,MACR,UACmB,iBAAV+F,EAAqBA,EAAQA,EAAMtP,+BAKhD,GAAwB,mBAAbwP,EACT,OAAOH,EAAcG,EAAW7M,EAAS9D,EAAO8F,GAGlD,MAAM+K,EAAY,CAChB/M,UACA9D,SAGI8Q,EACJJ,GAA6B,iBAAVD,OACf9M,EACA,WAAY8M,EACc,mBAAjBA,EAAM/D,OACX+D,EAAM/D,OAAO,CAAE5I,UAAS9D,UACxByQ,EAAM/D,YACR/I,EAER,KAAM,UAAWgN,GAIf,OAAOA,EAASE,EAAWC,GAK7B,OAFqBH,EAEDI,MAClBjL,EACA+K,EACAF,EAEJ,CChVA,MAAMK,EAAqBC,GACN,WAAnBA,EAAU9P,MAAwC,UAAnB8P,EAAU9P,KAE3C,SAAS+P,EACPD,GAEA,OAAO/O,OAAOmK,OAAO4E,EAAUE,QAAQC,QAAQlL,GAAmB,YAAZA,EAAG/E,MAC3D,CAEA,SAASkQ,EACPJ,EACAK,GAEA,MAAMC,EAAqC,GAE3C,GAAID,IAAgBL,EAClB,OAAOM,EAIT,IAAIC,EAAIP,EAAU5I,OAClB,KAAOmJ,GAAKA,IAAMF,GAChBC,EAAUzO,KAAK0O,GACfA,EAAIA,EAAEnJ,OAGR,OAAOkJ,CACT,CAEO,SAASE,EACdC,GAEA,MAAMC,EAAU,IAAI5L,IAAI2L,GAElBE,EAAUC,EAAWF,GAG3B,IAAK,MAAMG,KAAKH,EAEd,GAAe,aAAXG,EAAE3Q,MAAyByQ,EAAQrH,IAAIuH,IAAOF,EAAQrH,IAAIuH,GAAIlP,QAKhE,GAAe,aAAXkP,EAAE3Q,KACJ,IAAK,MAAM2K,KAASoF,EAAYY,GAC9B,GAAmB,YAAfhG,EAAM3K,OAILwQ,EAAQI,IAAIjG,GAAQ,CACvB,MAAMkG,EAAgBC,EAAuCnG,GAC7D,IAAK,MAAMoG,KAAoBF,EAC7BL,EAAQ9G,IAAIqH,EAEhB,OAfJD,EAAuCH,GAAG3G,SAASjF,GACjDyL,EAAQ9G,IAAI3E,KAqBlB,IAAK,MAAM4L,KAAKH,EAAS,CACvB,IAAIH,EAAIM,EAAEzJ,OAEV,KAAOmJ,GACLG,EAAQ9G,IAAI2G,GACZA,EAAIA,EAAEnJ,MAEV,CAEA,OAAOsJ,CACT,CAEA,SAASQ,EAAgBC,EAAwBR,GAC/C,MAAMS,EAAkBT,EAAQrH,IAAI6H,GAEpC,IAAKC,EACH,MAAO,GAGT,GAAsB,aAAlBD,EAASjR,KAAqB,CAChC,MAAMmR,EAAiBD,EAAgB,GACvC,IAAIC,EAKF,MAAO,GAJP,GAAItB,EAAkBsB,GACpB,OAAOA,EAAejQ,GAK5B,CAEA,MAAMU,EAAyB,CAAA,EAC/B,IAAK,MAAMuP,KAAkBD,EAC3BtP,EAAWuP,EAAejQ,KAAO8P,EAAgBG,EAAgBV,GAGnE,OAAO7O,CACT,CAEA,SAAS8O,EACPH,GAEA,MAAME,EAAmB,IAAInK,IAE7B,IAAK,MAAMqK,KAAKJ,EACTE,EAAQG,IAAID,IACfF,EAAQxH,IAAI0H,EAAG,IAGbA,EAAEzJ,SACCuJ,EAAQG,IAAID,EAAEzJ,SACjBuJ,EAAQxH,IAAI0H,EAAEzJ,OAAQ,IAGxBuJ,EAAQrH,IAAIuH,EAAEzJ,QAASvF,KAAKgP,IAIhC,OAAOF,CACT,CAEO,SAASW,EACdC,EACAd,GAGA,OAAOS,EAAgBK,EAAUX,EADlBJ,EAAiBC,IAElC,CAEO,SAASe,EACdC,EACAzB,GAEA,MAAuB,aAAnBA,EAAU9P,KACL+P,EAAYD,GAAW0B,MAC3Bb,GAAiB,UAAXA,EAAE3Q,MAAoBuR,EAAaX,IAAID,KAG3B,aAAnBb,EAAU9P,KACL+P,EAAYD,GAAW7O,OAAO8D,GACnCuM,EAAeC,EAAcxM,KAIP,UAAnB+K,EAAU9P,IACnB,CAEO,MAAMyR,EAAaC,GZ3MM,MY2MUA,EAAI,GA+DvC,SAASC,EACd7B,GAEA,MAAM8B,EAAc9B,EAAUtL,OAAOqN,MACrC,IAAKD,EACH,MAAO,GAGT,MAAME,EAAmB9J,IACvB,MAAM+J,GV5QuBC,EU4QOhK,EV5QoBlI,EU4QbgQ,EAAUhQ,GV3QhD,CAAEE,KAAM,gBAAgBgS,KAAYlS,MADtC,IAA0BkS,EAA2BlS,EU6QxD,MAAMmS,EAAYF,EAAW/R,KAS7B,OAPA8P,EAAUoC,MAAMvQ,KC3Jb,SAQLwQ,EAGAlM,GAwBA,SAASmM,EACPxD,EACAC,GAKF,CAUA,OARAuD,EAAMpS,KAAO,eACboS,EAAMvT,MAAQsT,EACdC,EAAMtS,GAAKmG,GAASnG,GACpBsS,EAAMpK,MAAQ/B,GAAS+B,MAEvBoK,EAAMtD,QAAUuD,GAChBD,EAAMrD,QAAUuD,GAETF,CACT,CDuGMA,CAAML,EAAY,CAChBjS,GAAImS,EACJjK,WAGJ8H,EAAUyC,KAAK5Q,KJ7MZ,SAMLuM,GAEA,SAASrF,EACP+F,EACAC,GAKF,CAQA,OANAhG,EAAO7I,KAAO,gBACd6I,EAAOqF,OAASA,EAEhBrF,EAAOiG,QAAUhB,EACjBjF,EAAOkG,QAAUZ,EAEVtF,CACT,CIqLwBA,CAAOoJ,IACpBA,GAiBT,OAd2BlR,OAAOC,KAAK4Q,GAAa9M,SAASkD,IAC3D,MAAMwK,EAAmBZ,EAAY5J,GAC/ByK,EACwB,iBAArBD,EACH,CAAEvP,OAAQuP,GACVA,EACAE,EAAgBC,OAAOC,OAAO5K,GAASA,GAASA,EAChDiK,EAAYH,EAAgBY,GAClC,OAAOnQ,EAAQkQ,GAAoB1P,KAAKsK,IAAgB,IACnDA,EACHxO,MAAOoT,EACPjK,MAAO0K,SAGe3P,KAAK8P,IAC7B,MAAM7K,MAAEA,GAAU6K,EAClB,MAAO,IACFC,EACDhD,EACA+C,EAAkBhU,MAClBgU,GAEF7K,WAGN,CAEO,SAAS8K,EACdhD,EACAiD,EACAC,GAEA,MAAMC,EAAmB/P,EAAgB8P,EAAiB/P,QACpDiQ,EAAUF,EAAiBE,UAAW,EACtCjQ,EA6IR,SACE6M,EACAqD,GAEA,QAAgB3Q,IAAZ2Q,EAEF,OAEF,OAAOA,EAAQpQ,KAAKE,IAClB,GAAsB,iBAAXA,EACT,OAAOA,EAET,GAAIwO,EAAUxO,GACZ,OAAO6M,EAAU/L,QAAQQ,iBAAiBtB,GAG5C,MAAMmQ,EZleqB,MYkeFnQ,EAAO,GAGhC,GAAImQ,IAAqBtD,EAAU5I,OACjC,OAAOmM,GAAmBvD,EAAW7M,EAAOmF,MAAM,IAEpD,MAAMkL,EAAiBF,EAAmBtD,EAAU5O,IAAM+B,EAASA,EACnE,IAAI6M,EAAU5I,OAaZ,MAAM,IAAIqC,MACR,oBAAoBtG,+DAAoEA,OAb1F,IAKE,OAJwBoQ,GACtBvD,EAAU5I,OACVoM,EAGH,CAAC,MAAOlT,GACP,MAAM,IAAImJ,MACR,iDAAiDuG,EAAUhQ,SAASM,EAAImT,UAE5E,IAON,CAtLiBC,CAAc1D,EAAWmD,GASlC5F,EAAa,IACd2F,EACHS,QAASlR,EAAQyQ,EAAiBS,SAClCnE,MAAO0D,EAAiB1D,MACxBrM,SACA8E,OAAQ+H,EACRoD,UACAjB,UAAWc,EACXrF,OAAQA,KAAO,IACVL,EACHtF,OAAQ,IAAI+H,EAAUhQ,KACtBmD,OAAQA,EAASA,EAAOF,KAAK2Q,GAAM,IAAIA,EAAE5T,YAAQ0C,KAIrD,OAAO6K,CACT,CA+JA,SAASsG,EAGP7D,GACA,MAAMmD,EAAmB/P,EACvB4M,EAAUtL,OAAOvB,QAEnB,OAAKgQ,EAGE,CACLhQ,OAAQgQ,EAAiBlQ,KAAK2Q,GACf,iBAANA,EAAiBL,GAAmBvD,EAAU5I,OAASwM,GAAKA,KAJ9D5D,EAAU5I,OAAQ0M,OAO7B,CAEA,SAASC,EACP/D,GAEA,MAA0B,YAAnBA,EAAU9P,IACnB,CAEA,SAAS8Q,EAAuChB,GAC9C,MAAME,EAAS8D,GAAqBhE,GACpC,IAAK,MAAMiE,KAAgB/D,EACzB,IAAK,MAAMgE,KAAY9D,EAAmB6D,EAAcjE,GACtDE,EAAOtG,IAAIsK,GAGf,OAAOhE,CACT,CAEO,SAAS8D,GAAqBhE,GACnC,MAAM7G,EAAM,IAAIrE,IAkBhB,OAhBA,SAASqP,EAAKC,GACZ,IAAIjL,EAAI2H,IAAIsD,GAIZ,GADAjL,EAAIS,IAAIwK,GACmB,aAAvBA,EAAclU,KAChBiU,EAAKC,EAAcN,QAAQ3Q,OAAO,SAC7B,GAA2B,aAAvBiR,EAAclU,KACvB,IAAK,MAAM2K,KAASoF,EAAYmE,GAC9BD,EAAKtJ,EAGX,CAEAsJ,CAAKnE,GAEE7G,CACT,CAEA,SAASkL,GAAarE,EAAyBsE,GAC7C,GAAI3C,EAAU2C,GACZ,OAAOtE,EAAU/L,QAAQQ,iBAAiB6P,GAE5C,IAAKtE,EAAUE,OACb,MAAM,IAAIzG,MACR,mCAAmC6K,YAAmBtE,EAAUhQ,+BAGpE,MAAMwB,EAASwO,EAAUE,OAAOoE,GAChC,IAAK9S,EACH,MAAM,IAAIiI,MACR,gBAAgB6K,yBAAgCtE,EAAUhQ,OAG9D,OAAOwB,CACT,CAOO,SAAS+R,GACdvD,EACAhO,GAEA,GAAyB,iBAAdA,GAA0B2P,EAAU3P,GAC7C,IACE,OAAOgO,EAAU/L,QAAQQ,iBAAiBzC,EAC5C,CAAE,MAEA,CAGJ,MAAMuS,EAAiBlT,EAAYW,GAAWsG,QAC9C,IAAIkM,EAAiCxE,EACrC,KAAOuE,EAAe5S,QAAQ,CAC5B,MAAMP,EAAMmT,EAAejI,QAC3B,IAAKlL,EAAIO,OACP,MAEF6S,EAAmBH,GAAaG,EAAkBpT,EACpD,CACA,OAAOoT,CACT,CAOO,SAASC,GACdzE,EACAlO,GAEA,GAA0B,iBAAfA,EAAyB,CAClC,MAAMuP,EAAiBrB,EAAUE,OAAOpO,GACxC,IAAKuP,EACH,MAAM,IAAI5H,MACR,UAAU3H,yBAAkCkO,EAAUhQ,OAG1D,MAAO,CAACgQ,EAAWqB,EACrB,CAEA,MAAMqD,EAAiBzT,OAAOC,KAAKY,GAC7BsP,EAAuCsD,EAC1CzR,KAAK0R,GAAgBN,GAAarE,EAAW2E,KAC7CxE,OAAOyE,SAEV,MAAO,CAAC5E,EAAU/L,QAAQ4Q,KAAM7E,GAAW8E,OACzC1D,EACAsD,EAAeK,QAAO,CAACC,EAAkBL,KACvC,MAAMM,EAAeZ,GAAarE,EAAW2E,GAC7C,IAAKM,EACH,OAAOD,EAET,MAAME,EAAgBT,GACpBQ,EACAnT,EAAW6S,IAGb,OAAOK,EAAiBF,OAAOI,KAC9B,IAEP,CA8GO,SAASC,GAIdnF,EACAlO,EACA+C,EAUA9F,GAGA,MAA0B,iBAAf+C,EA/Hb,SAIEkO,EACAlO,EACA+C,EAUA9F,GAEA,MACMF,EADiBwV,GAAarE,EAAWlO,GACnBjD,KAAKgG,EAAU9F,GAE3C,OAAKF,GAASA,EAAK8C,OAIZ9C,EAHEmR,EAAUnR,KAAKgG,EAAU9F,EAIpC,CAsGWqW,CAAqBpF,EAAWlO,EAAY+C,EAAU9F,GAIxB,IAAnCkC,OAAOC,KAAKY,GAAYH,OAxG9B,SAIEqO,EACAlO,EACA+C,EAUA9F,GAEA,MAAMsW,EAAepU,OAAOC,KAAKY,GAG3BjD,EAAOsW,GADUd,GAAarE,EAAWqF,EAAa,IAG1DvT,EAAWuT,EAAa,IACxBxQ,EACA9F,GAGF,OAAKF,GAASA,EAAK8C,OAIZ9C,EAHEmR,EAAUnR,KAAKgG,EAAU9F,EAIpC,CAwEWuW,CAAuBtF,EAAWlO,EAAY+C,EAAU9F,GAtEnE,SAIEiR,EACAlO,EACA+C,EAUA9F,GAEA,MAAMwW,EAAqE,GAE3E,IAAK,MAAMZ,KAAe1T,OAAOC,KAAKY,GAAa,CACjD,MAAM0T,EAAgB1T,EAAW6S,GAEjC,IAAKa,EACH,SAGF,MACMC,EAAmBN,GADJd,GAAarE,EAAW2E,GAG3Ca,EACA3Q,EACA9F,GAEE0W,GACFF,EAAoB1T,QAAQ4T,EAEhC,CACA,OAAKF,EAAoB5T,OAIlB4T,EAHEvF,EAAUnR,KAAKgG,EAAU9F,EAIpC,CA+BS2W,CAAuB1F,EAAWlO,EAAY+C,EAAU9F,EACjE,CAEA,SAAS4W,GAAgB3F,GACvB,OAAO/O,OAAOC,KAAK8O,EAAUE,QAC1BjN,KAAK7B,GAAQ4O,EAAUE,OAAO9O,KAC9B+O,QAAQlL,GAAmB,YAAZA,EAAG/E,MACvB,CAEA,SAAS0V,GACPvE,EACAwE,GAEA,IAAI5T,EAASoP,EACb,KAAOpP,EAAOmF,QAAUnF,EAAOmF,SAAWyO,GACxC5T,EAASA,EAAOmF,OAGlB,OAAOnF,EAAOmF,SAAWyO,CAC3B,CAEA,SAASC,GAAmBC,EAAiBC,GAC3C,MAAMC,EAAO,IAAInR,IAAIiR,GACfG,EAAO,IAAIpR,IAAIkR,GAErB,IAAK,MAAMG,KAAQF,EACjB,GAAIC,EAAKpF,IAAIqF,GACX,OAAO,EAGX,IAAK,MAAMA,KAAQD,EACjB,GAAID,EAAKnF,IAAIqF,GACX,OAAO,EAGX,OAAO,CACT,CAEA,SAASC,GACPC,EACA5E,EACA6E,GAEA,MAAMC,EAAsB,IAAIzR,IAEhC,IAAK,MAAM0R,KAAMH,EAAoB,CACnC,IAAII,GAAc,EAClB,MAAMC,EAAsB,IAAI5R,IAChC,IAAK,MAAM6R,KAAMJ,EACf,GACET,GACEc,GAAe,CAACJ,GAAK/E,EAAc6E,GACnCM,GAAe,CAACD,GAAKlF,EAAc6E,IAErC,CACA,IAAIV,GAAaY,EAAGvO,OAAQ0O,EAAG1O,QAExB,CACLwO,GAAc,EACd,KACF,CAJEC,EAAoB9M,IAAI+M,EAK5B,CAEF,IAAKF,EAAa,CAChB,IAAK,MAAMI,KAAMH,EACfH,EAAoBlN,OAAOwN,GAE7BN,EAAoB3M,IAAI4M,EAC1B,CACF,CAEA,OAAO1T,MAAMgU,KAAKP,EACpB,CAaA,SAASQ,GACPxJ,EACA+I,GAEA,IAAK/I,EAAWpK,OACd,MAAO,GAGT,MAAMkQ,EAAU,IAAIvO,IAEpB,IAAK,MAAMkS,KAAczJ,EAAWpK,OAClC,GAAI4Q,EAAciD,GAChB,GAAIV,EAAaU,EAAWhX,IAC1B,IAAK,MAAMiX,KAAQX,EAAaU,EAAWhX,IACzCqT,EAAQzJ,IAAIqN,QAGd,IAAK,MAAMA,KAAQF,GACjBlD,EAAgCmD,GAChCV,GAEAjD,EAAQzJ,IAAIqN,QAIhB5D,EAAQzJ,IAAIoN,GAIhB,MAAO,IAAI3D,EACb,CAEA,SAAS6D,GACP3J,EACA+I,GAEA,MAAMa,EAAeJ,GAAyBxJ,EAAY+I,GAE1D,IAAKa,EACH,OAGF,IACG5J,EAAW6F,SACZ+D,EAAahW,OACVgC,GACCA,IAAWoK,EAAWtF,QAAU2N,GAAazS,EAAQoK,EAAWtF,UAGpE,OAAOsF,EAAWtF,OAGpB,MAAMmP,EA/DR,SACE3G,GAEA,MAAO4G,KAASC,GAAQ7G,EACxB,IAAK,MAAMyD,KAAY9D,EAAmBiH,OAAM3U,GAC9C,GAAI4U,EAAKnW,OAAO8D,GAAO2Q,GAAa3Q,EAAIiP,KACtC,OAAOA,CAGb,CAsDcqD,CAAwBJ,EAAarC,OAAOvH,EAAWtF,SAEnE,OAAImP,IAKA7J,EAAW6F,aAAf,EAIO7F,EAAWtF,OAAOhE,QAAQ4Q,KACnC,CAEA,SAAS+B,GACPY,EACA/F,EACA6E,GAEA,MAAMmB,EAAe,IAAI3S,IAEzB,IAAK,MAAM8O,KAAK4D,EACd,GAAI5D,EAAEzQ,QAAQxB,OAAQ,CACpB,MAAM+V,EAASR,GAAoBtD,EAAG0C,GAElC1C,EAAER,SAAWQ,EAAE3L,SAAWyP,GAC5BD,EAAa7N,IAAI8N,GAGnB,IAAK,MAAM1H,KAAayB,EAClBmE,GAAa5F,EAAW0H,IAC1BD,EAAa7N,IAAIoG,EAGvB,CAGF,MAAO,IAAIyH,EACb,CAkBO,SAASE,GACdH,EACAI,EACAtJ,EACAvP,EACA8Y,EACAC,GAEA,IAAKN,EAAY7V,OACf,OAAOiW,EAET,MAAMG,EAAkB,IAAIjT,IAAI8S,EAAgB7S,QAChD,IAAIuR,EAAesB,EAAgBtB,aAEnC,MAAMC,EAAsBH,GAC1BoB,EACAO,EACAzB,GAGF,IAAIjJ,EAAYuK,EAGXC,KACFxK,EAAWiJ,GAsZhB,SACEsB,EACA7Y,EACAuP,EACAkJ,EACAO,EACAzB,EACAwB,GAGA,IAAIE,EAAeJ,EACnB,MAAMH,EAAeb,GACnBY,EACAO,EACAzB,GAKF,IAAI2B,EAFJR,EAAaS,MAAK,CAACC,EAAGC,IAAMA,EAAEC,MAAQF,EAAEE,QAKxC,IAAK,MAAMC,KAAiBb,EAC1B,IAAK,MAAMc,KAAe5C,GAAgB2C,GAAgB,CACxD,IAAIE,EAEFA,EAD0B,SAAxBD,EAAYE,QACDxT,GACX8K,EAAkB9K,IAAO2Q,GAAa3Q,EAAIqT,GAE/BrT,GACJA,EAAGmC,SAAWkR,EAGzBL,IAAmB,IAAK3B,GACxB2B,EAAeM,EAAYvY,IACzB8C,MAAMgU,KAAKiB,GAAiB5H,OAAOqI,EACvC,CAGF,IAAK,MAAM3H,KAAK4G,EACdO,EAAeU,GACbV,EACAjZ,EACAuP,EACA,IAAIuC,EAAE4B,QAAS5B,EAAElM,OAAO1B,KAAK0V,GAAQ/N,EAAU+N,EAAI3Y,OACnD8X,OACApV,GAEFqV,EAAgB1O,OAAOwH,GAEzB,MAAO,CAACmH,EAAcC,GAAkB3B,EAC1C,CAzcgCsC,CAC1BvL,EACAtO,EACAuP,EACAiI,EACAwB,EACAzB,EACAwB,EACAxJ,EAAWhD,iBAKf+B,EAAYqL,GACVrL,EACAtO,EACAuP,EACAiI,EAAoBvR,SAAS4O,GAAMA,EAAED,UACrCmE,OACApV,GAIF2K,EA0EF,SACEuK,EACA7Y,EACAuP,EACAiI,EACAwB,EACAD,EACAxB,EACAuB,GAEA,IAAIG,EAAeJ,EACnB,MAAMiB,EAAgB,IAAI/T,IAIpBgU,EAAwB,IAAIhU,KAmGpC,SACE0S,EACAlB,EACAwC,EACAD,GAEA,IAAK,MAAMjF,KAAK4D,EAAa,CAC3B,MAAME,EAASR,GAAoBtD,EAAG0C,GAEtC,IAAK,MAAMzF,KAAK+C,EAAEzQ,QAAU,GAEvB4Q,EAAclD,IAEd+C,EAAE3L,SAAW4I,GAGZ+C,EAAE3L,SAAWyP,IAEb9D,EAAER,UAEJyF,EAAcjP,IAAIiH,GAClBiI,EAAsBlP,IAAIiH,IAE5BkI,GACElI,EACAyF,EACAwC,EACAD,GAGJ,MAAM1B,EAAeJ,GAAyBnD,EAAG0C,GACjD,IAAK,MAAMzF,KAAKsG,EAAc,CAC5B,MAAM7G,EAAYF,EAAmBS,EAAG6G,GACnB,aAAjBA,GAAQxX,MACVoQ,EAAUzO,KAAK6V,GAEjBsB,GACEH,EACAvC,EACAwC,EACAxI,GACCsD,EAAE3L,OAAOb,QAAUwM,EAAER,aAAU1Q,EAAYgV,EAEhD,CACF,CACF,EA/IEuB,CACE1C,EACAD,EACAwC,EACAD,GAIEhB,GACFiB,EAAsBlP,IAAIgO,EAAgB3T,QAAQ4Q,MAGpD,MAAMqE,EAAiB,IAAIpU,IAE3B,IAAK,MAAMqU,IAAoB,IAAIN,GAAeX,MAChD,CAACC,EAAGC,IAAMD,EAAEE,MAAQD,EAAEC,QACrB,CACDN,EAAgBnO,IAAIuP,GACpB,MAAMxF,EAA2B,GAGjCA,EAAQ9R,QAAQsX,EAAiB/G,OAEjC,IAAK,MAAMgH,KAAaD,EAAiBxU,OACvCgP,EAAQ9R,KACNgN,EAAWuK,EAAUlV,IAAK,IACrBkV,EACH/R,eAAgB+R,EAAUC,cAKhC,GAAIP,EAAsBhI,IAAIqI,GAAmB,CAC/C,MAAMG,EAAiBH,EAAiBrF,QAAQH,QAChDA,EAAQ9R,QAAQyX,EAClB,CAWA,GATAtB,EAAeU,GACbV,EACAjZ,EACAuP,EACAqF,EACAmE,EACAqB,EAAiBxU,OAAO1B,KAAKmW,GAAcA,EAAUpZ,MAGzB,UAA1BmZ,EAAiBjZ,KAAkB,CACrC,MAAMkH,EAAS+R,EAAiB/R,OAEhC,IAAImS,EACe,aAAjBnS,GAAQlH,KAAsBkH,EAASA,GAAQA,OAC7CoS,EAAqBD,GAAkBJ,EAiB3C,IAfqB,aAAjB/R,GAAQlH,MACV4X,EAAcjW,KACZ9B,EACEqH,EAAOpH,QACqB0C,IAA5ByW,EAAiBlZ,OACb0C,EACEwW,EAAiBlZ,OACjB+X,EAAanV,QACb9D,EACAuP,EAAW9O,WAEbkD,IAKiB,aAAzB6W,GAAgBrZ,OACfgZ,EAAepI,IAAIyI,IACpB/H,EAAeuG,EAAiBwB,IAEhCL,EAAetP,IAAI2P,GACnBzB,EAAcjW,KAAK9B,EAAqBwZ,EAAevZ,KACvDwZ,EAAqBD,EACrBA,EAAiBA,EAAenS,OAElC,GAAImS,EACF,SAGFvB,EAAerJ,GAAqBqJ,EAAc,CAChDhM,OAAQ,OACR/L,OAAQwZ,GACNzB,EACAjZ,EACAuP,EACA0J,EAAa/T,QAAQ4Q,KACrB2E,IAGN,CACF,CAEA,OAAOxB,CACT,CA1Lc0B,CACVrM,EACAtO,EACAuP,EACAiI,EACAwB,EACAD,EACAxB,EACAuB,GAGF,MAAM8B,EAAiB,IAAI5B,GAEF,SAArB1K,EAAUrB,SACZqB,EAAYqL,GACVrL,EACAtO,EACAuP,EACAqL,EACGzB,MAAK,CAACC,EAAGC,IAAMA,EAAEC,MAAQF,EAAEE,QAC3BrT,SAAS+G,GAAUA,EAAM0G,OAC5BqF,OACApV,IAKJ,IACE,OACE4T,IAAiBsB,EAAgBtB,cA5FvC,SACEsD,EACAC,GAEA,GAAID,EAAejY,SAAWkY,EAAiB9P,KAC7C,OAAO,EAET,IAAK,MAAMkN,KAAQ2C,EACjB,IAAKC,EAAiB/I,IAAImG,GACxB,OAAO,EAGX,OAAO,CACT,CAgFM6C,CAA6BlC,EAAgB7S,OAAQgT,GAE9C1K,EAEFsB,GAAqBtB,EAAW,CACrCtI,OAAQ4U,EACRrD,gBAEH,CAAC,MAAOyD,GAGP,MAAMA,CACR,CACF,CAEA,SAASN,GACP5U,EACA9F,EACAuP,EACAiD,EACAiI,GAEA,QAAwB9W,IAApB6O,EAAStR,OACX,OAEF,MAAM+Z,EAAiBja,EACrByZ,EAAmBxZ,QACW0C,IAA9B8W,EAAmBvZ,QAAwBuZ,EAAmBpS,OAC1DzE,EACE6W,EAAmBvZ,OACnB4E,EAAShC,QACT9D,EACAuP,EAAW9O,WAEbkD,GAEN,OAAOC,EACL4O,EAAStR,OACT4E,EAAShC,QACTmX,EACA1L,EAAW9O,KAEf,CAmKA,SAASuZ,GAIP/I,EACAsG,EACAwC,EACAD,GAEA,GAAI9E,EAAc/D,GAChB,GAAIsG,EAAatG,EAAUhQ,IAAK,CAC9B,MAAMia,EAAoB3D,EAAatG,EAAUhQ,IACjD,IAAK,MAAM6Q,KAAKoJ,EACdpB,EAAcjP,IAAIiH,GAElBkI,GACElI,EACAyF,EACAwC,EACAD,GAGJ,IAAK,MAAMhI,KAAKoJ,EACdC,GACErJ,EACAb,EAAU5I,OACVyR,EACAvC,EACAwC,EAGN,KAAO,CACL,MAAMqB,EAA2BtG,EAG/B7D,GACF,IAAK,MAAMa,KAAKsJ,EAAyBhX,OACvC0V,EAAcjP,IAAIiH,GAEdsJ,IAA6BnK,EAAU5I,QAAQ0M,SACjDgF,EAAsBlP,IAAIoG,EAAU5I,QAGtC2R,GACElI,EACAyF,EACAwC,EACAD,GAIJ,IAAK,MAAMhI,KAAKsJ,EAAyBhX,OACvC+W,GACErJ,EACAb,EAAU5I,OACVyR,EACAvC,EACAwC,EAGN,MAEA,GAAuB,aAAnB9I,EAAU9P,KAAqB,CACjC,MAAO+T,GAAgBjE,EAAU8D,QAAQ3Q,OAEpC4Q,EAAcE,KACjB4E,EAAcjP,IAAIqK,GAClB6E,EAAsBlP,IAAIqK,IAE5B8E,GACE9E,EACAqC,EACAwC,EACAD,GAGFqB,GACEjG,EACAjE,EACA6I,EACAvC,EACAwC,EAEJ,MACE,GAAuB,aAAnB9I,EAAU9P,KACZ,IAAK,MAAM2K,KAASoF,EAAYD,GAAWG,QACxClL,IAAQ8O,EAAc9O,KAElB,IAAI4T,GAAenH,MAAMb,GAAM+E,GAAa/E,EAAGhG,OAC7CkJ,EAAclJ,KACjBgO,EAAcjP,IAAIiB,GAClBiO,EAAsBlP,IAAIiB,IAE5BkO,GACElO,EACAyL,EACAwC,EACAD,GAOd,CAEA,SAASG,GACPH,EACAvC,EACAwC,EACAxI,EACA8J,GAEA,IAAK,MAAMC,KAAO/J,EAIhB,GAHK8J,IAAoBxE,GAAayE,EAAKD,IACzCvB,EAAcjP,IAAIyQ,GAEH,aAAbA,EAAIna,KACN,IAAK,MAAM2K,KAASoF,EAAYoK,GAAKlK,QAAQlL,IAAQ8O,EAAc9O,KAC5D,IAAI4T,GAAenH,MAAMb,GAAM+E,GAAa/E,EAAGhG,OAClDgO,EAAcjP,IAAIiB,GAClBkO,GACElO,EACAyL,EACAwC,EACAD,GAMZ,CAEA,SAASqB,GACPlK,EACAK,EACAwI,EACAvC,EACAwC,GAEAE,GACEH,EACAvC,EACAwC,EACA1I,EAAmBJ,EAAWK,GAElC,CA8EA,SAASiK,GAAUrW,EAA0BsW,GAC3C,OAAOtW,EAAQG,gBAAgBuP,QAAQ4G,EACzC,CAEA,SAASC,GACP5C,EACA7Y,EACAuP,EACAqF,EACA8G,EAIAC,GAEA,MAAMzW,QAAEA,GAAY2T,EACpB,IAAI+C,EAAuB/C,EAE3B,IAAK,MAAMrM,KAAUoI,EAAS,CAC5B,MAAMlE,EAA6B,mBAAXlE,EAClBqP,EAAiBnL,EACnBlE,EAKA+O,GAAUrW,EAA2B,iBAAXsH,EAAsBA,EAASA,EAAOrL,MAC9DgO,EAAa,CACjBrL,QAAS8X,EAAqB9X,QAC9B9D,QACAS,KAAM8O,EAAW9O,KACjBwH,OAAQsH,EAAWtH,QAGfmH,EACJsB,GAA8B,iBAAXlE,OACf7I,EACA,WAAY6I,EACe,mBAAlBA,EAAOE,OACZF,EAAOE,OAAO,CAAE5I,QAAS8X,EAAqB9X,QAAS9D,UACvDwM,EAAOE,YACT/I,EAER,IAAKkY,KAAoB,YAAaA,GAAiB,CACrDtM,EAAWhD,eAAe,CACxBpL,KACoB,iBAAXqL,EACHA,EACkB,iBAAXA,EACLA,EAAOrL,KACPqL,EAAOsP,MAAQ,cACvBlP,KAAMuC,EACNzC,OAAQ0C,EACR3C,KAAMoP,IAER,QACF,CAEA,MAAME,EAAgBF,GAEfvN,EAAW5B,EAAQkI,GAAWmH,EAAc9L,QACjDV,EACAqM,EACAzM,EACAC,EACAyM,EACAH,GAEFE,EAAuBtN,EAEnB,iBAAkByN,GACpBJ,GAAS7Y,KAAK,CAACiZ,EAAerP,IAG5B,YAAaqP,GACfxM,EAAWhD,eAAe,CACxBpL,KAAM4a,EAAc5a,KACpByL,KAAMuC,EACNzC,SACAD,KAAMsP,EAAc7L,QAAQvL,KAAK,KAAM4K,EAAY7C,KAInDkI,IACFgH,EAAuBH,GACrBG,EACA5b,EACAuP,EACAqF,EACA8G,EACAC,GAGN,CAEA,OAAOC,CACT,CAEO,SAASjC,GACdd,EACA7Y,EACAuP,EACAqF,EACAmE,EACAiD,GAEA,MAAML,EACJK,EAAmB,QAAKrY,EACpB2K,EAAYmN,GAChB5C,EACA7Y,EACAuP,EACAqF,EACA,CAAEmE,gBAAeiD,oBACjBL,GAKF,OAHAA,GAASxQ,SAAQ,EAAE4Q,EAAerP,MAChCqP,EAAcE,aAAa1M,EAAYjB,EAAW5B,MAE7C4B,CACT,CAEO,SAAS4N,GACdpW,EACA9F,EACAuP,EACAwJ,GASA,IAAIE,EAAenT,EACnB,MAAMqW,EAAoC,GAE1C,SAASC,EACPC,EACArc,EACAyY,GAEAlJ,EAAWtH,OAAO8C,qBAAqB,CACrC5J,KAAM,oBACNkF,SAAUkJ,EAAW9O,KACrBT,QACA8F,SAAUuW,EACVC,aAAc7D,IAEhB0D,EAAYrZ,KAAKuZ,EACnB,CAGA,GAAIrc,EAAMmB,OAASd,EASjB,OARA4Y,EAAerJ,GACb2M,GAAatD,EAAcjZ,EAAOuP,GAClC,CACEtC,OAAQ,YAGZmP,EAAcnD,EAAcjZ,EAAO,IAE5B,CACL8F,SAAUmT,EACVkD,eAIJ,IAAIK,EAAYxc,EAIhB,GAAIwc,EAAUrb,OAASf,EAAa,CAClC,MAAMqc,EAAeD,EACfE,EPv7CH,SACL1c,GAEA,OAAOA,EAAMmB,KAAKwb,WAAW,qBAC/B,COm7CkBC,CAAkBH,GAE1BhE,EAAcoE,GAAkBJ,EAAcxD,GAEpD,GAAIyD,IAAUjE,EAAY7V,OASxB,OALAqW,EAAerJ,GAAsC9J,EAAU,CAC7DmH,OAAQ,QACRrI,MAAO6X,EAAa7X,QAEtBwX,EAAcnD,EAAcwD,EAAc,IACnC,CACL3W,SAAUmT,EACVkD,eAGJlD,EAAeL,GACbH,EACA3S,EACAyJ,EACAiN,GACA,EACAzD,GAEFqD,EAAcnD,EAAcwD,EAAchE,EAC5C,CAEA,IAAIqE,GAAmC,EAEvC,KAA+B,WAAxB7D,EAAahM,QAAqB,CACvC,IAAIqK,EACFwF,EACIC,GAA2B9D,EAAcuD,GACzC,GAIN,MAAMQ,EAAgB1F,EAAmB1U,OAASqW,OAAetV,EAEjE,IAAK2T,EAAmB1U,OAAQ,CAC9B,IAAKmW,EAAcnW,OACjB,MAEF4Z,EAAYzD,EAAcxL,QAC1B+J,EAAqBuF,GAAkBL,EAAWvD,EACpD,CAEAA,EAAeL,GACbtB,EACA2B,EACA1J,EACAiN,GACA,EACAzD,GAEF+D,EAAmC7D,IAAiB+D,EACpDZ,EAAcnD,EAAcuD,EAAWlF,EACzC,CAMA,MAJ4B,WAAxB2B,EAAahM,QACfsP,GAAatD,EAAcuD,EAAWjN,GAGjC,CACLzJ,SAAUmT,EACVkD,cAEJ,CAEA,SAASI,GACPjO,EACAtO,EACAuP,GAEA,OAAOoK,GACLrL,EACAtO,EACAuP,EACArN,OAAOmK,OAAOiC,EAAU5F,UAAUxE,KAAK4H,GAAeD,EAAUC,KAChE,QACAnI,EAEJ,CAEA,SAASkZ,GACP7c,EACAsO,GAEA,OAAOA,EAAUpJ,QAAQ+X,kBAAkB3O,EAAkBtO,EAC/D,CAEA,SAAS+c,GACPzO,EACAtO,GAEA,MAAMkd,EAAqD,IAAInX,IACzDoX,EAAe7O,EAAUtI,OAAOoL,OAAOJ,GAE7C,IAAK,MAAMC,KAAakM,EACtBC,EAAM,IAAK,MAAMtL,IAAK,CAACb,GAAW8E,OAChC1E,EAAmBJ,OAAWtN,IAE9B,GAAKmO,EAAEuL,OAGP,IAAK,MAAM7O,KAAcsD,EAAEuL,OACzB,QACuB1Z,IAArB6K,EAAWiC,OACXD,EAAchC,EAAWiC,MAAOnC,EAAUxK,QAAS9D,EAAOsO,GAC1D,CACA4O,EAAqBrS,IAAI2D,GACzB,MAAM4O,CACR,CAKN,OAAO/F,GACLtT,MAAMgU,KAAKmF,GACX,IAAInX,IAAIuI,EAAUtI,QAClBsI,EAAUiJ,aAEd,CEptDO,SAASvU,GAAkB9C,GAChC,QACIA,GACe,iBAAVA,GACP,YAAaA,GACb,UAAWA,CAEf,CAoPA,MAAMod,GAAyB,SAE7BC,GAEA,OAAO3b,EAAa2b,EAAWhe,KAAKW,MACtC,EAEMsd,GAAwB,SAE5BC,GAEA,OAAOle,KAAKme,KAAK3L,IAAI0L,EACvB,EAEME,GAAqB,SAEzB3d,GAQA,MAAM4d,EAAiBre,KAAK2F,QAAQ+X,kBAAkB1d,KAAMS,GAE5D,QACI4d,GAAgBhb,QAElBgb,EAAejL,MAAMkC,QAAmBlR,IAAbkR,EAAEzQ,QAAwByQ,EAAED,QAAQhS,QAEnE,EAEMib,GAAwB,WAC5B,MACE7X,OAAQ8X,EAAKJ,KACbA,EAAIxY,QACJA,EAAO6Y,QACPA,EAAOlP,OACPA,EAAMmP,IACNA,EAAGC,OACHA,EAAMC,QACNA,KACGC,GACD5e,KACJ,MAAO,IAAK4e,EAAYT,KAAM3Z,MAAMgU,KAAK2F,GAC3C,EAEMU,GAAyB,WAC7B,OAAO7e,KAAKyG,OAAOgQ,QACjB,CAACqI,EAAKpN,UACmBtN,IAAnBsN,EAAUqN,OACZD,EAAIpN,EAAUhQ,IAAMgQ,EAAUqN,MAEzBD,IAET,CACF,EACF,EAEO,SAASE,GASd5Y,EACAT,GAWA,MAAO,CACL+H,OAAQtH,EAAOsH,OACf/L,OAAQyE,EAAOzE,OACf0D,MAAOe,EAAOf,MACdM,UACApB,QAAS6B,EAAO7B,QAChBkC,OAAQL,EAAOK,OACf9F,MAAOqS,EAAcrN,EAAQ4Q,KAAMnQ,EAAOK,QAC1C0X,KAAM,IAAI3X,IAAIJ,EAAOK,OAAOC,SAASC,GAAOA,EAAGwX,QAC/ChV,SAAU/C,EAAO+C,SACjB6O,aAAc5R,EAAO4R,cAAgB,CAAE,EACvC2G,QAASZ,GACTW,OAAQT,GACRQ,IAAKL,GACLI,QAASK,GACTvP,OAAQgP,GAEZ,CAEO,SAASjO,GACd9J,EACAH,EAAyC,IAEzC,OAAO4Y,GACL,IAAKzY,KAAaH,GAClBG,EAASZ,QAEb,CAEA,SAASsZ,GAGPjH,GACA,GAA4B,iBAAjBA,GAA8C,OAAjBA,EACtC,MAAO,GAET,MAAM9U,EAAgC,CAAA,EAEtC,IAAK,MAAMJ,KAAOkV,EAAc,CAC9B,MAAMrX,EAAQqX,EAAalV,GACvB0B,MAAMvB,QAAQtC,KAChBuC,EAAOJ,GAAOnC,EAAMgE,KAAKkT,IAAU,CAAEnW,GAAImW,EAAKnW,OAElD,CAEA,OAAOwB,CACT,CAoEA,SAASgc,GAAeC,GACtB,IAAIC,EACJ,IAAK,MAAMtc,KAAOqc,EAAa,CAC7B,MAAMxe,EAAQwe,EAAYrc,GAC1B,GAAInC,GAA0B,iBAAVA,EAClB,GAAI,cAAeA,GAAS,SAAUA,GAAS,QAASA,EACtDye,IAAS5a,MAAMvB,QAAQkc,GAClBA,EAAYnV,QACb,IAAKmV,GACTC,EAAKtc,GAAO,CACVyM,aP/bkB,EOgclB7N,GAAKf,EAA6Be,QAE/B,CACL,MAAMwB,EAASgc,GAAeve,GAC1BuC,IAAWvC,IACbye,IAAS5a,MAAMvB,QAAQkc,GAClBA,EAAYnV,QACb,IAAKmV,GACTC,EAAKtc,GAAOI,EAEhB,CAEJ,CACA,OAAOkc,GAAQD,CACjB,CC5aO,SAASE,GACdrP,GACArK,QAAEA,EAAOpB,QAAEA,GACX9D,EACA6e,GA4CA,MAAQ,CAAC1Z,EAAKiC,KACZ,MAAMf,EA3CqByY,EAAC3Z,EAAKiC,KACjC,GAAmB,iBAARjC,EAAkB,CAC3B,MAAMgC,EAAQlC,EAAuBC,EAASC,GAE9C,IAAKgC,EACH,MAAM,IAAIuD,MACR,gBAAgBvF,kCAAoCD,EAAQjE,OAIhE,MAAMoF,EAAW2I,EAAY7H,EAAO,CAClClG,GAAImG,GAASnG,GACboH,OAAQkH,EAAW9O,KACnB6H,aAAclB,GAASkB,aACvBjH,MAC4B,mBAAnB+F,GAAS/F,MACZ+F,EAAQ/F,MAAM,CACZyC,UACA9D,QACAS,KAAM8O,EAAW9O,OAEnB2G,GAAS/F,MACf8D,MACAoD,SAAUnB,GAASmB,WAKrB,OAFAsW,EAAgBxY,EAASpF,IAAMoF,EAExBA,CACT,CAUE,OATiB2I,EAAY7J,EAAK,CAChClE,GAAImG,GAASnG,GACboH,OAAQkH,EAAW9O,KACnB6H,aAAclB,GAASkB,aACvBjH,MAAO+F,GAAS/F,MAChB8D,MACAoD,SAAUnB,GAASmB,YAONuW,CAAM3Z,EAAKiC,GAQ5B,OAPAyX,EAAgBxY,EAASpF,IAAMoF,EAC/BkJ,EAAW3D,OAAM,KACXvF,EAASqB,oBAAsBjB,EAAiBwH,SAGpD5H,EAAS1G,WAEJ0G,EAEX,CC/GA,SAAS0Y,GACPxP,EACAzJ,EACAqJ,EACAC,GACA4P,WACEA,IAOF,IAAKlZ,EAAShC,QACZ,MAAM,IAAI4G,MACR,iGAGJ,MAAMmU,EAA+C,CAAA,EAE/CI,EAA6C,CACjDnb,QAASgC,EAAShC,QAClB9D,MAAOmP,EAAWnP,MAClB8e,MAAOF,GACLrP,EACAzJ,EACAqJ,EAAWnP,MACX6e,GAEFpe,KAAM8O,EAAW9O,KACjBwH,OAAQsH,EAAWtH,QAErB,IAAIiX,EAAyC,CAAA,EAC7C,GAA0B,mBAAfF,EACTE,EAAgBF,EAAWC,EAAY7P,QAEvC,IAAK,MAAM/M,KAAOH,OAAOC,KAAK6c,GAAa,CACzC,MAAMG,EAAiBH,EAAW3c,GAClC6c,EAAc7c,GACc,mBAAnB8c,EACHA,EAAeF,EAAY7P,GAC3B+P,CACR,CAKF,MAAO,CACLvP,GAAqB9J,EAAU,CAC7BhC,QAJmB5B,OAAOkd,OAAO,CAAE,EAAEtZ,EAAShC,QAASob,GAKvDxW,SAAUxG,OAAOC,KAAK0c,GAAiBjc,OACnC,IACKkD,EAAS4C,YACTmW,GAEL/Y,EAAS4C,gBAEf/E,OACAA,EAEJ,CA+CO,SAASyb,GAOdJ,GA0BA,SAASI,EACPrP,EACAC,GAKF,CAOA,OALAoP,EAAOje,KAAO,gBACdie,EAAOJ,WAAaA,EAEpBI,EAAOnP,QAAU8O,GAEVK,CACT,CHtKA,SAAS5L,GACPtE,EACApJ,EACAsK,EACAhB,GAEEpP,MAAOsT,EAAWrS,GAClBA,EAAEkI,MACFA,IAuBF4P,cAAEA,IAEF,MAAMsG,EAAYvZ,EAASZ,QAAQG,gBAAgBia,OAEnD,GAA2B,iBAAhBhM,EACT,MAAM,IAAI5I,MAER,iEAAiE4I,iBAGrE,MAAMiM,EACmB,mBAAhBjM,EACHA,EAAYlD,EAAMhB,GAClBkE,EAEN,IAAIO,EACJ,GAAqB,iBAAV1K,EAAoB,CAC7B,MAAMqW,EAAcH,GAAaA,EAAUlW,GAC3C0K,EACyB,mBAAhB2L,EACHA,EAAYpP,EAAMhB,GAClBoQ,CACR,MACE3L,EACmB,mBAAV1K,EAAuBA,EAAMiH,EAAMhB,GAAgBjG,EAK9D,MAH6B,iBAAlB0K,GACTkF,EAAcjW,KAAKyc,GAEd,CACLzZ,EACA,CACE9F,MAAOuf,EACPte,KACAkI,MAAO0K,QAETlQ,EAEJ,CAEA,SAAS8P,GACPlE,EACA7C,GAMA,MAAM1M,MAAEA,EAAKmJ,MAAEA,EAAKlI,GAAEA,GAAOyL,EACR,iBAAVvD,GACToG,EAAW3D,OAAM,KACf,MAAMnL,EAAO8O,EAAW9O,KACxB8O,EAAWtH,OAAOe,UAAUC,SAASxI,EAAMA,EAAMT,EAAOmJ,EAAOlI,KAIrE,CI5EA,MAAMwe,ICyJJC,QDzJkD/b,ECmK3C,CACLgC,OArBF6I,GD/IiCU,MCqK/BV,WAAYA,CAAC1I,EAAU9F,EAAOuP,KACrB,IACFzJ,EACHhC,QAAS0K,GAAW1I,EAAShC,QAAS9D,EAAOuP,KAGjDnC,mBAAoBA,CAAC8B,EAAG7N,KACf,CACL4L,OAAQ,SACR/L,YAAQyC,EACRiB,WAAOjB,EACPG,QAC4B,mBAAnB4b,GACFA,GAAuB,CAAEre,UAC1Bqe,KAGV3Q,qBAAuBjJ,GAAaA,EACpCqH,gBAAkBrH,GAAkBA,IA/CjC,IAOL0I,GAUAkR,GCvLF,MAAMC,GAAQ,IAAI9W,QAEX,SAAS+W,GAAQC,EAAaxd,EAAauE,GAChD,IAAIkZ,EAAeH,GAAMpV,IAAIsV,GAS7B,OAPKC,EAGQzd,KAAOyd,IAClBA,EAAazd,GAAOuE,MAHpBkZ,EAAe,CAAEzd,CAACA,GAAMuE,KACxB+Y,GAAMvV,IAAIyV,EAAQC,IAKbA,EAAazd,EACtB,CC6BA,MAAM0d,GAAe,CAAA,EAEfC,GAAwBxT,GACN,iBAAXA,EACF,CAAErL,KAAMqL,GAEK,mBAAXA,EACL,YAAaA,EACR,CAAErL,KAAOqL,EAAyBrL,MAEpC,CACLA,KAAMqL,EAAOsP,MAGVtP,EAYF,MAAMyT,GAgFX5gB,WAAAA,CAESsG,EAYPyB,GAoCA,GAnCA7H,KAbOoG,OAAAA,EA9ETpG,KAIO8C,SAAG,EACV9C,KACO0B,QAAE,EACT1B,KASO4B,UAAI,EACX5B,KACO2gB,UAAI,EACX3gB,KACO4R,YAAM,EACb5R,KAMOma,aAAO,EACdna,KACO8T,WAAK,EACZ9T,KACOmU,UAAI,EACXnU,KACO8I,YAAM,EACb9I,KACO2F,aAAO,EAgBd3F,KAIO+e,UAAI,EACX/e,KAIO2B,YAAM,EAIb3B,KAIO+Z,OAAiB,EAAC/Z,KAElB4gB,iBAAW,EAAA5gB,KAEXme,KAAiB,GAAEne,KACnBkZ,iBAAW,EAAAlZ,KACX8d,YAAM,EAkBX9d,KAAK8I,OAASjB,EAAQQ,QACtBrI,KAAK8C,IAAM+E,EAAQgZ,KACnB7gB,KAAK2F,QAAUkC,EAAQiZ,SACvB9gB,KAAK2gB,KAAO3gB,KAAK8I,OAAS9I,KAAK8I,OAAO6X,KAAKnK,OAAOxW,KAAK8C,KAAO,GAC9D9C,KAAK0B,GACH1B,KAAKoG,OAAO1E,IAAM,CAAC1B,KAAK2F,QAAQjE,MAAO1B,KAAK2gB,MAAMI,KpBzKzB,KoB0K3B/gB,KAAK4B,KACH5B,KAAKoG,OAAOxE,OACX5B,KAAKoG,OAAOwL,QAAUjP,OAAOC,KAAK5C,KAAKoG,OAAOwL,QAAQvO,OACnD,WACArD,KAAKoG,OAAO+T,QACV,UACA,UACRna,KAAK4gB,YAAc5gB,KAAKoG,OAAOwa,YAE/B5gB,KAAK+Z,MAAQ/Z,KAAK2F,QAAQqb,MAAMvV,KAChCzL,KAAK2F,QAAQqb,MAAMnW,IAAI7K,KAAK0B,GAAI1B,MAEhCA,KAAK4R,OACH5R,KAAKoG,OAAOwL,OACR9N,EACE9D,KAAKoG,OAAOwL,QACZ,CAACqP,EAAiCne,IACd,IAAI4d,GAAUO,EAAa,CAC3C5Y,QAASrI,KACT6gB,KAAM/d,EACNge,SAAU9gB,KAAK2F,YAKrB6a,GAGY,aAAdxgB,KAAK4B,OAAwB5B,KAAKoG,OAAOoP,QAC3C,MAAM,IAAIrK,MACR,wDACEnL,KAAK0B,+BAELiB,OAAOC,KAAK5C,KAAK4R,QAAQ,8BAM/B5R,KAAKma,SACqB,IAAxBna,KAAKoG,OAAO+T,QAAmB,UAAYna,KAAKoG,OAAO+T,UAAW,EAEpEna,KAAK8T,MAAQ3P,EAAQnE,KAAKoG,OAAO0N,OAAO9J,QACxChK,KAAKmU,KAAOhQ,EAAQnE,KAAKoG,OAAO+N,MAAMnK,QAEtChK,KAAK+e,KAAO/e,KAAKoG,OAAO2Y,KACxB/e,KAAK2B,OACW,UAAd3B,KAAK4B,MAAqB5B,KAAK8I,YAA8B1E,EAArBpE,KAAKoG,OAAOzE,OACtD3B,KAAKme,KAAOha,EAAQiC,EAAO+X,MAAMnU,OACnC,CAGOkX,WAAAA,GACLlhB,KAAKkZ,YRiIF,SAILxH,GAEA,MAAMwH,EAAc,IAAIhR,IAIxB,GAAIwJ,EAAUtL,OAAOuI,GACnB,IAAK,MAAMgG,KAAchS,OAAOC,KAAK8O,EAAUtL,OAAOuI,IAAK,CACzD,GZ1WoB,KY0WhBgG,EACF,MAAM,IAAIxJ,MACR,4FAGJ,MAAMgW,EAAoBzP,EAAUtL,OAAOuI,GAAGgG,GAC9CuE,EAAYrO,IACV8J,EACAlQ,EAAwB0c,GAAmBxc,KAAK2Q,GAC9CZ,EAAiBhD,EAAWiD,EAAYW,KAG9C,CAEF,GAAI5D,EAAUtL,OAAOgb,OAAQ,CAC3B,MAAMzM,EAAa,qBAAqBjD,EAAUhQ,KAClDwX,EAAYrO,IACV8J,EACAlQ,EAAwBiN,EAAUtL,OAAOgb,QAAQzc,KAAK2Q,GACpDZ,EAAiBhD,EAAWiD,EAAYW,KAG9C,CACA,IAAK,MAAMwF,KAAapJ,EAAUrL,OAAQ,CACxC,GAAIyU,EAAUsG,OAAQ,CACpB,MAAMzM,EAAa,qBAAqBmG,EAAUpZ,KAClDwX,EAAYrO,IACV8J,EACAlQ,EAAwBqW,EAAUsG,QAAQzc,KAAK2Q,GAC7CZ,EAAiBhD,EAAWiD,EAAYW,KAG9C,CACA,GAAIwF,EAAUuG,QAAS,CACrB,MAAM1M,EAAa,sBAAsBmG,EAAUpZ,KACnDwX,EAAYrO,IACV8J,EACAlQ,EAAwBqW,EAAUuG,SAAS1c,KAAK2Q,GAC9CZ,EAAiBhD,EAAWiD,EAAYW,KAG9C,CACA,GAAIwF,EAAUC,WAAY,CACxB,MAAMpG,EAAa,mBAAmBmG,EAAUpZ,KAChDwX,EAAYrO,IACV8J,EACAlQ,EAAwBqW,EAAUC,YAAYpW,KAAK2Q,GACjDZ,EAAiBhD,EAAWiD,EAAYW,KAG9C,CACF,CACA,IAAK,MAAMb,KAAqB/C,EAAU+B,MAAO,CAC/C,IAAIvI,EAAWgO,EAAYlO,IAAIyJ,EAAkBZ,WAC5C3I,IACHA,EAAW,GACXgO,EAAYrO,IAAI4J,EAAkBZ,UAAW3I,IAE/CA,EAAS3H,KAAKkR,EAChB,CACA,OAAOyE,CACT,CQ1MuBoI,CAAkBthB,MACjCA,KAAKoG,OAAO0X,SACd9d,KAAK8d,OAASrZ,EAAwBzE,KAAKoG,OAAO0X,QAAQnZ,KAAK2Q,GAC7DZ,EAAiB1U,KpBhOC,GoBgOiBsV,MAIvC3S,OAAOC,KAAK5C,KAAK4R,QAAQhG,SAAS9I,IAChC9C,KAAK4R,OAAO9O,GAAKoe,gBAErB,CAGA,cAAWK,GACT,MAAO,CACL7f,GAAI1B,KAAK0B,GACToB,IAAK9C,KAAK8C,IACV0e,QAASxhB,KAAK2F,QAAQ6b,QACtB5f,KAAM5B,KAAK4B,KACX4T,QAASxV,KAAKwV,QACV,CACE3Q,OAAQ7E,KAAKwV,QAAQ3Q,OACrB8E,OAAQ3J,KACRqV,QAASrV,KAAKwV,QAAQH,QAAQ1Q,IAAI8b,IAClC5M,UAAW,KACXiB,SAAS,EACTxF,OAAQA,KAAO,CACbzK,OAAQ7E,KAAKwV,QAAQ3Q,OAAOF,KAAK2Q,GAAM,IAAIA,EAAE5T,OAC7CiI,OAAQ,IAAI3J,KAAK0B,KACjB2T,QAASrV,KAAKwV,QAAQH,QAAQ1Q,IAAI8b,IAClC5M,UAAW,aAGfzP,EACJ+V,QAASna,KAAKma,QACdvI,OAAQ9N,EAAU9D,KAAK4R,QAASnE,GACvBA,EAAM8T,aAEf5S,GAAI3O,KAAK2O,GACTuK,YAAa,IAAIlZ,KAAKkZ,YAAYpM,UAAU2U,OAAO9c,KAAK2Q,IAAO,IAC1DA,EACHD,QAASC,EAAED,QAAQ1Q,IAAI8b,QAEzB3M,MAAO9T,KAAK8T,MAAMnP,IAAI8b,IACtBtM,KAAMnU,KAAKmU,KAAKxP,IAAI8b,IACpB1B,KAAM/e,KAAK+e,KACXhF,MAAO/Z,KAAK+Z,QAAU,EACtBpY,OAAQ3B,KAAK2B,OACb0E,OAAQrG,KAAKqG,OACbua,YAAa5gB,KAAK4gB,YAClBzC,KAAMne,KAAKme,KAEf,CAGO7O,MAAAA,GACL,OAAOtP,KAAKuhB,UACd,CAGA,UAAWlb,GAYT,OAAOga,GAAKrgB,KAAM,UAAU,IAC1BmE,EAAQnE,KAAKoG,OAAOC,QAAQ1B,KAAI,CAACuB,EAAc9C,KAC7C,MAAMwC,IAAEA,EAAGoD,SAAEA,GAAa9C,EACpBiK,EAAajK,EAAaxE,IAAM6D,EAAevF,KAAK0B,GAAI0B,GACxDse,EACW,iBAAR9b,EACHA,EACA,iBAAiBL,EAAevF,KAAK0B,GAAI0B,KAE/C,MAAO,IACF8C,EACHN,IAAK8b,EACLhgB,GAAIyO,EACJnH,SAAUA,EACVsG,MAAAA,GACE,MAAM8R,OAAEA,EAAMC,QAAEA,KAAYM,GAAoBzb,EAChD,MAAO,IACFyb,EACH/f,KAAM,gBACNgE,IAAK8b,EACLhgB,GAAIyO,EAER,OAaR,CAGA,MAAWxB,GACT,OAAO0R,GAAKrgB,KAAM,MAAM,IAGf,IAFaA,KAAKkZ,aAGtBxS,SAAQ,EAAEiO,EAAYW,KAAOA,EAAE3Q,KAAK2Q,GAAM,CAACX,EAAYW,OACvDmB,QACC,CAAC9R,GAAWgQ,EAAY1F,MACtBtK,EAAIgQ,GAAchQ,EAAIgQ,IAAe,GACrChQ,EAAIgQ,GAAYpR,KAAK0L,GACdtK,IAET,CACF,IAEN,CAEA,SAAW8O,GACT,OAAO4M,GACLrgB,KACA,sBACA,IAAMuT,EAAsBvT,OAEhC,CAEA,WAAWwV,GACT,OAAO6K,GAAKrgB,KAAM,WAAW,IRoE1B,SAIL0R,EACAkQ,GAKA,MAAM1M,EACe,iBAAZ0M,EACHlQ,EAAUE,OAAOgQ,GACjBA,EACElQ,EAAUE,OAAOgQ,EAAQ/c,aACzBT,EACR,IAAK8Q,GAAkB0M,EACrB,MAAM,IAAIzW,MAER,uBAAuByW,sCAA4ClQ,EAAUhQ,MAGjF,MAAMuN,EAA4D,CAChEtF,OAAQ+H,EACR2D,QACGuM,GAA8B,iBAAZA,EAA4Bzd,EAAQyd,EAAQvM,SAArB,GAC5CxB,UAAW,KACXiB,SAAS,EACTjQ,OAAQqQ,EAAiB,CAACA,GAAkB,GAC5C5F,OAAQA,KAAO,IACVL,EACHtF,OAAQ,IAAI+H,EAAUhQ,KACtBmD,OAAQqQ,EAAiB,CAAC,IAAIA,EAAexT,MAAQ,MAIzD,OAAOuN,CACT,CQxGM4S,CAAwB7hB,KAAMA,KAAKoG,OAAOoP,UAE9C,CAGOjV,IAAAA,CACLgG,EAUA9F,GAEA,MAAMoT,EAAYpT,EAAMmB,KAClByT,EAA2B,GAEjC,IAAIyM,EAEJ,MAAMC,EAA4D1B,GAChErgB,KACA,cAAc6T,KACd,KAAMmO,ORhLVC,EQgL8BpO,GRjL9BnC,EQiLwB1R,MR7KZkZ,YAAYlO,IAAIiX,IAC1B,IAAIvQ,EAAUwH,YAAYtW,QACvBiP,QAAQqQ,IAGP,GZtNgB,MYsNZA,EACF,OAAO,EAGT,IAAKA,EAAgBC,SAAS,MAC5B,OAAO,EAST,MAAMC,EAAqBF,EAAgBG,MAAM,KAC3CC,EAAcL,EAAkBI,MAAM,KAE5C,IACE,IAAIE,EAAa,EACjBA,EAAaH,EAAmB/e,OAChCkf,IACA,CACA,MAAMC,EAAoBJ,EAAmBG,GACvCE,EAAaH,EAAYC,GAE/B,GAA0B,MAAtBC,EASF,OARoBD,IAAeH,EAAmB/e,OAAS,EAWjE,GAAImf,IAAsBC,EACxB,OAAO,CAEX,CAEA,OAAO,KAER7I,MAAK,CAACC,EAAGC,IAAMA,EAAEzW,OAASwW,EAAExW,SAC5BqD,SAAS5D,GAAQ4O,EAAUwH,YAAYlO,IAAIlI,KAvD3C,IACL4O,EACAuQ,KQmLE,IAAK,MAAMS,KAAaX,EAAY,CAClC,MAAM7Q,MAAEA,GAAUwR,EACZC,EAAkBpc,EAAShC,QAEjC,IAAIqe,GAAc,EAElB,IACEA,GACG1R,GACDD,EACEC,EACAyR,EACAliB,EACA8F,EAEL,CAAC,MAAOvE,GACP,MAAM6gB,EACa,iBAAV3R,EACHA,EACiB,iBAAVA,EACLA,EAAMtP,UACNwC,EACR,MAAM,IAAI+G,MACR,4BACE0X,EAAY,IAAIA,MAAgB,8BACNhP,qBAC1B7T,KAAK0B,SACAM,EAAImT,UAEf,CAEA,GAAIyN,EAAa,CACfvN,EAAQ9R,QAAQmf,EAAUrN,SAC1ByM,EAAqBY,EACrB,KACF,CACF,CAEA,OAAOZ,EAAqB,CAACA,QAAsB1d,CACrD,CAGA,UAAW0e,GACT,OAAOzC,GAAKrgB,KAAM,UAAU,KAC1B,MAAM4R,OAAEA,GAAW5R,KACb8iB,EAAS,IAAItc,IAAIxG,KAAK4G,WAE5B,GAAIgL,EACF,IAAK,MAAM5O,KAAWL,OAAOC,KAAKgP,GAAS,CACzC,MAAMnE,EAAQmE,EAAO5O,GACrB,GAAIyK,EAAMmE,OACR,IAAK,MAAMnR,KAASgN,EAAMqV,OACxBA,EAAOxX,IAAI,GAAG7K,IAGpB,CAGF,OAAO+D,MAAMgU,KAAKsK,KAEtB,CAOA,aAAWlc,GACT,MAAMkc,EAAS,IAAItc,IACjB,IAAIxG,KAAKkZ,YAAYtW,QAAQiP,QAAQ8C,GAC5B3U,KAAKkZ,YACTlO,IAAI2J,GACJvB,MACEnE,MAEIA,EAAWpK,SACXoK,EAAWoG,QAAQhS,SACnB4L,EAAW6F,cAMxB,OAAOtQ,MAAMgU,KAAKsK,EACpB,ECjaK,MAAMC,GAqDXjjB,WAAAA,CAESsG,EAePN,GACA9F,KAhBOoG,OAAAA,EAtBTpG,KACOwhB,aAAO,EAAAxhB,KAEPgjB,aAAO,EAAAhjB,KAEP8F,qBAAe,EAEtB9F,KACOijB,cAAe,EAEtBjjB,KACOghB,MAAkD,IAAI9Y,IAAKlI,KAE3DuW,UAAI,EAAAvW,KAEJ0B,QAAE,EAAA1B,KAEF4R,YAAM,EAAA5R,KACN8iB,YAAM,EAqBX9iB,KAAK0B,GAAK0E,EAAO1E,IAAM,YACvB1B,KAAK8F,gBAAkB,CACrBC,OAAQD,GAAiBC,QAAU,CAAE,EACrCsP,QAASvP,GAAiBuP,SAAW,CAAE,EACvC0K,OAAQja,GAAiBia,QAAU,CAAE,EACrC1O,OAAQvL,GAAiBuL,QAAU,CAAC,GAEtCrR,KAAKwhB,QAAUxhB,KAAKoG,OAAOob,QAC3BxhB,KAAKgjB,QAAUhjB,KAAKoG,OAAO4c,QAE3BhjB,KAAKiP,WAAajP,KAAKiP,WAAW7J,KAAKpF,MACvCA,KAAK6N,mBAAqB7N,KAAK6N,mBAAmBzI,KAAKpF,MACvDA,KAAKwP,qBAAuBxP,KAAKwP,qBAAqBpK,KAAKpF,MAC3DA,KAAK4N,gBAAkB5N,KAAK4N,gBAAgBxI,KAAKpF,MACjDA,KAAKI,MAAQJ,KAAKI,MAAMgF,KAAKpF,MAE7BA,KAAKuW,KAAO,IAAImK,GAAUta,EAAQ,CAChCya,KAAM7gB,KAAK0B,GACXof,SAAU9gB,OAGZA,KAAKuW,KAAK2K,cAEVlhB,KAAK4R,OAAS5R,KAAKuW,KAAK3E,OACxB5R,KAAK8iB,OAAS9iB,KAAKuW,KAAKuM,MAa1B,CASOI,OAAAA,CACLpd,GA4BA,MAAMuP,QAAEA,EAAOhE,OAAEA,EAAMtL,OAAEA,EAAMga,OAAEA,GAAW/f,KAAK8F,gBAEjD,OAAO,IAAIid,GAAa/iB,KAAKoG,OAAQ,CACnCiP,QAAS,IAAKA,KAAYvP,EAAgBuP,SAC1ChE,OAAQ,IAAKA,KAAWvL,EAAgBuL,QACxCtL,OAAQ,IAAKA,KAAWD,EAAgBC,QACxCga,OAAQ,IAAKA,KAAWja,EAAgBia,SAE5C,CAEOoD,YAAAA,CACL/c,GAoBA,MAAMgd,GT0hDRnQ,ES1hD+CjT,KAAKuW,KT2hDpD/S,ES3hD0D4C,EAAOzF,MT8hD1DqS,EAAcC,EAAU,IADTf,EAAiBiE,GAAclD,EAAUzP,OAJ1D,IACLyP,EACAzP,ES1hDE,MAAM4O,EAAUF,EACdiE,GAAcnW,KAAKuW,KAAM6M,IAG3B,OAAOpE,GACL,CACEvY,OAAQ,IAAI2L,GACZ7N,QAAS6B,EAAO7B,SAAY,CAAe,EAC3C4E,SAAU,CAAE,EACZuE,OAAQwF,EAAed,EAASpS,KAAKuW,MACjC,OACAnQ,EAAOsH,QAAU,SACrB/L,OAAQyE,EAAOzE,OACf0D,MAAOe,EAAOf,MACd2S,aAAc5R,EAAO4R,cAEvBhY,KAWJ,CASOiP,UAAAA,CACL1I,EAUA9F,EACAuP,GAWA,OAAO2M,GAAUpW,EAAU9F,EAAOuP,EAAY,IAC3CzJ,QACL,CASO8S,SAAAA,CACL9S,EAUA9F,EACAuP,GAaA,OAAO2M,GAAUpW,EAAU9F,EAAOuP,EAAY,IAAI4M,WACpD,CAEOc,iBAAAA,CACLnX,EAUA9F,GAEA,OAAOoW,GAAe7W,KAAKuW,KAAMhQ,EAAS5F,MAAO4F,EAAU9F,IAAU,EACvE,CAMQ4iB,kBAAAA,CACNrT,EACAnB,EACA2K,GAWA,MAAMjV,QAAEA,GAAYvE,KAAKoG,OAEnBkd,EAAatE,GACjB,CACEza,QACqB,mBAAZA,GAA0BA,EAAUA,EAAW,CAAe,EACvEkC,OAAQ,CAACzG,KAAKuW,MACdpN,SAAU,CAAE,EACZuE,OAAQ,UAEV1N,MAGF,GAAuB,mBAAZuE,EAAwB,CAGjC,OAAO6V,GACLkJ,EACAzU,EACAmB,EACA,CAAC6P,IANgBJ,EAAGF,QAAO9e,QAAOS,UAClCqD,EAAQ,CAAEgb,QAAOzd,MAAOrB,EAAMqB,MAAOZ,YAMrCsY,OACApV,EAEJ,CAEA,OAAOkf,CACT,CAMOzV,kBAAAA,CACLmC,EAeAlO,GAWA,MAAM+M,EAAYhN,EAAgBC,GAC5B0X,EAAkC,GAClC+J,EAAkBvjB,KAAKqjB,mBAC3BrT,EACAnB,EACA2K,GAEIzK,EAAYsK,GAChB,CACE,CACExU,OAAQ,IAAI6Q,GAAqB1V,KAAKuW,OACtC5M,OAAQ3J,KAAKuW,KACbzB,SAAS,EACTO,QAAS,GACTxB,UAAW,KACXvE,OAAQ,OAGZiU,EACAvT,EACAnB,GACA,EACA2K,IAGMjT,SAAUid,GAAe7G,GAC/B5N,EACAF,EACAmB,EACAwJ,GAGF,OAAOgK,CACT,CAEOpjB,KAAAA,CACLmG,GAWA5D,OAAOmK,OAAOvG,EAAS4C,UAAyCyC,SAC7DW,IACoC,WAA/BA,EAAMR,cAAc2B,QACtBnB,EAAMnM,UAId,CAEO+F,gBAAAA,CAAiBnD,GACtB,MAAMygB,EAAW1gB,EAAYC,GACvB0gB,EAAeD,EAASzZ,MAAM,GAC9B2Z,EAAkBtQ,EAAUoQ,EAAS,IACvCA,EAAS,GAAGzZ,MAAM4Z,GAClBH,EAAS,GAEP/R,EAAY1R,KAAKghB,MAAMhW,IAAI2Y,GACjC,IAAKjS,EACH,MAAM,IAAIvG,MACR,sBAAsBwY,iCAA+C3jB,KAAK0B,OAG9E,OAAOuT,GAAmBvD,EAAWgS,EACvC,CAEA,cAAWnC,GACT,OAAOvhB,KAAKuW,KAAKgL,UACnB,CAEOjS,MAAAA,GACL,OAAOtP,KAAKuhB,UACd,CAEO/R,oBAAAA,CACLjJ,EAUAsB,GAEA,OPrGG,SASLtB,EAUAsB,GAEA,MACEpB,OAAQ8X,EAAKJ,KACbA,EAAIxY,QACJA,EAAOwD,SACPA,EAAQ5E,QACRA,EAAOka,IACPA,EAAGC,OACHA,EAAMC,QACNA,EAAOH,QACPA,EAAOlP,OACPA,KACGsP,GACDrY,EAEEsd,EAAwC,CAAA,EAE9C,IAAK,MAAMniB,KAAMyH,EAAU,CACzB,MAAMoD,EAAQpD,EAASzH,GAQvBmiB,EAAaniB,GAAmC,CAC9C6E,SAAUgG,EAAMiD,qBAAqB3H,GACrCjC,IAAK2G,EAAM3G,IACXoD,SAAUuD,EAAM9D,UAChBM,aAAcwD,EAAMjE,cAExB,CAWA,MATkB,IACbsW,EACHra,QAAS2a,GAAe3a,GACxB4E,SAAU0a,EACV7L,aAAciH,GACZL,EAAW5G,cAKjB,COqCWxI,CAAqBjJ,EAAUsB,EACxC,CAEO+F,eAAAA,CACLrH,EACAiC,GAyBA,MAAMW,EAAwC,CAAA,EACxC2a,EAQDvd,EAAiB4C,SA0BtB,SAAS4a,EACPxN,EACAyN,GAEA,GAAIA,aAAsBtD,GACxB,OAAOsD,EAET,IACE,OAAOzN,EAAK5Q,QAAQQ,iBAAiB6d,EAAWtiB,GAClD,CAAE,MAIF,CACF,CAtCAiB,OAAOC,KAAKkhB,GAAkBlY,SAASwC,IACrC,MAAM6V,EAAYH,EAAiB1V,GAC7B8V,EAAaD,EAAU1d,SACvBX,EAAMqe,EAAUre,IAEhBgC,EACW,iBAARhC,EAAmBF,EAAuB1F,KAAM4F,GAAOA,EAEhE,IAAKgC,EACH,OAGF,MAAMd,EAAW2I,EAAY7H,EAAO,CAClClG,GAAI0M,EACJtF,OAAQN,EAAYtH,KACpB6H,aAAckb,EAAUlb,aACxBxC,SAAU2d,EACVte,MACAoD,SAAUib,EAAUjb,WAGtBG,EAASiF,GAAWtH,KA+CtB,MAAMqd,EA5BN,SACE5N,EACAyB,GAKA,IAAKA,GAAwC,iBAAjBA,EAC1B,MAAO,GAET,MAAMoM,EAA0C,CAAA,EAChD,IAAK,MAAMthB,KAAOkV,EAAc,CAC9B,MAAMqM,EAAMrM,EAAalV,GAEzB,IAAK,MAAM+U,KAAQwM,EAAK,CACtB,MAAMjT,EAAW2S,EAA8BxN,EAAMsB,GAEhDzG,IAILgT,EAAQthB,KAAS,GACjBshB,EAAQthB,GAAKS,KAAK6N,GACpB,CACF,CACA,OAAOgT,CACT,CAE4BE,CAC1BtkB,KAAKuW,KACJhQ,EAAiByR,cAGduM,EAAmBvF,GACvB,IACMzY,EACJ4C,WACA1C,OAAQjC,MAAMgU,KACZtG,EAAiBiE,GAAcnW,KAAKuW,KAAOhQ,EAAiB5F,SAE9DqX,aAAcmM,GAEhBnkB,MAYIwkB,EAAO,IAAIhe,IAyBjB,OAvBA,SAASie,EACPtF,EACAhW,GAEA,IAAIqb,EAAKhS,IAAI2M,GAAb,CAGAqF,EAAKlZ,IAAI6T,GACT,IAAK,MAAMrc,KAAOqc,EAAa,CAC7B,MAAMxe,EAAiBwe,EAAYrc,GAEnC,GAAInC,GAA0B,iBAAVA,EAAoB,CACtC,GAAI,iBAAkBA,Gd7mBJ,Ic6mBaA,EAAM4O,aAA+B,CAClE4P,EAAYrc,GAAOqG,EAAUxI,EAAce,IAC3C,QACF,CACA+iB,EAAc9jB,EAA6BwI,EAC7C,CACF,CAZA,CAaF,CAEAsb,CAAcF,EAAiBhgB,QAAS4E,GAEjCob,CACT,EC7pBK,SAASG,GAAgB/jB,GAC9B,OAAOgkB,KAAKC,UAAUjkB,EACxB,CAkEO,SAASkkB,GACdte,GAEA,MAAMue,EAAiBniB,OAAOC,KAAK2D,EAAShC,SAASlB,OAEjD,IAAIshB,KAAKC,UAAUre,EAAShC,YAD5B,GAGEwgB,EAAexe,EAASE,OAC3BoL,QAAQlL,GAAmB,WAAZA,EAAG/E,MAAiC,UAAZ+E,EAAG/E,OAC1C+C,KAAI,EAAGjD,KAAIif,WACV,MAAM5B,EAAOxY,EAASiY,UAAU9c,GAChC,IAAKqd,EACH,MAAO,IAAI4B,EAAKI,KAAK,QAGvB,MAAMH,YAAEA,GAAgB7B,EAExB,MAA2B,mBAAhB6B,EACFA,EAAYra,GAGdqa,EAAc,IAAIA,KAAiB+D,KAAKC,UAAUre,EAAS5F,UAGtE,MACE,QAAgC,IAAxBokB,EAAa1hB,OAAe,GAAK,OACzC0hB,EAAahE,KAAK,MAClB,IAAI+D,IAAgBE,MAExB,CCrGO,MCJMC,GACXA,IAKA,CAACrd,EAAOT,IACQ+d,GAAiBtd,EAAOT,GAK7Bge,GACXA,IAKA,CAACvd,EAAOT,IACQie,GAAexd,EAAOT,GCrBlCke,GAAiB5X,IACrB,GAAIA,EAAMpH,OAAOhD,OAAS,EACxB,MAAM,IAAI8H,MAAM,kDAElB,GAAIsC,EAAMgG,MAAMpQ,OAAS,EACvB,MAAM,IAAI8H,MAAM,mDAGlB,IACKsC,EAAMqG,SACNrG,EAAM0G,QACN,IAAI1G,EAAMyL,YAAYpM,UAAUpG,SAAS4O,GAC1CA,EAAE5O,SAAS4O,GAAMA,EAAED,aAErBzJ,SAASqB,IAET,GACoB,mBAAXA,GACP,YAAaA,GACoB,iBAAzBA,EAAerD,MAEvB,MAAM,IAAIuB,MAAM,yDAIpB,IAAK,MAAMoB,KAAS5J,OAAOmK,OAAOW,EAAMmE,QACtCyT,GAAc9Y,IC2CX,MAAM+Y,GAOJC,iBAAAA,GACL,MAAO,CACLC,eAAiB/X,GAAUiX,GAAgBjX,GAC3CgY,eAAiBhlB,GAAUikB,GAAgBjkB,GAG3CilB,oBAAqBA,CAACjY,EAAOhN,IAC3B,GAAGikB,GAAgBjX,MAAUhN,GAAOmB,OACtCkhB,OAAQ,GACR6C,aAAcA,CAAChW,EAAGqG,IAA0B,MAAbA,EAC/BxO,OAAQ,CACNE,IAAKD,QAAQC,IAAItC,KAAKqC,SACtBpC,MAAOoC,QAAQpC,MAAMD,KAAKqC,UAGhC,CAEA3H,WAAAA,CACS8lB,EACP/d,GACA7H,KAFO4lB,UAAAA,EAAgD5lB,KApBlD6H,aAAO,EAAA7H,KACP6lB,6BAAuB,EAAA7lB,KAyFtB8lB,YACNpiB,IAYA,MAAMqiB,EAAeriB,EAAUsiB,MAC5BrhB,KAAK4N,GAXR,SAAqB9R,GACnB,MAAMmB,KAAEA,KAASqkB,GAAUxlB,EAM3B,MAAO,GAAGmB,IAJae,OAAOC,KAAKqjB,GAAO5iB,OACtC,KAAKshB,KAAKC,UAAUqB,MACpB,IAGN,CAGcC,CAAY3T,EAAE9R,SACzBsgB,KAAK,OACR,MAAO,IACFrd,EACHyiB,KAAOhZ,GACLnN,KAAKomB,SAAS1iB,EAAWyJ,GAC3ByT,YAAand,GAAkBC,EAAU+J,OACrC,WAAWoX,GACTnhB,EAAU+J,OACVuX,WAAWe,IACbpB,KAAKC,UAAUlhB,EAAU+J,SA3F/BzN,KAAK6H,QAAU,IACV7H,KAAKulB,uBACL1d,EAEP,CAEOwe,QAAAA,CACLC,EACAze,GAEA,MAAM0e,EAAsB1e,GAAS0e,sBAAuB,EACtDC,EAAQF,EAActmB,KAAK4lB,UAAW5lB,KAAKymB,gBAAgB5e,IACjE,OAAQ0e,EAAsBC,EHvGFE,EAI9BF,EACAf,EAA4Cf,MAG5C,MAAMiC,EAGD,GAELH,EAAM5a,SAAS+U,IACbgG,EAA0BpjB,KAAK,CAC7Bod,OACAiG,cAAejG,EAAKqF,MAAMrhB,KAAKkiB,GAASpB,EAAeoB,EAAKpmB,cAKhEkmB,EAA0B/M,MACxB,CAACC,EAAGiN,IAAMA,EAAEnG,KAAKqF,MAAM3iB,OAASwW,EAAE8G,KAAKqF,MAAM3iB,SAG/C,MAAM0jB,EAAgE,GAGtEC,EAAU,IAAK,MAAMC,KAAyBN,EAA2B,CAEvEO,EAAe,IAAK,MAAMC,KAA8BJ,EAA6B,CAEnF,IAAK,MAAM3jB,KAAK6jB,EAAsBL,cAUpC,GACEK,EAAsBL,cAAcxjB,KACpC+jB,EAA2BP,cAAcxjB,GAIzC,SAAS8jB,EAMb,SAASF,CACX,CAIAD,EAA4BxjB,KAAK0jB,EACnC,CAEA,OAAOF,EAA4BpiB,KAAKgc,GAASA,EAAKA,QGyCd+F,CAAiBF,IAAQ7hB,IAC7D3E,KAAK8lB,YAET,CAEOZ,gBAAAA,CACLrd,GAEA,OAAO7H,KAAKqmB,SAASpB,KAA0Bpd,EACjD,CAEOuf,oBAAAA,CACLZ,EACA3e,GAEA,MAAMwf,EAA6C,GAEnD,IAAK,MAAM1G,KAAQ6F,EAAO,CACxB,MAAMc,EAAgBtnB,KAAKklB,iBAAiB,IACvCrd,EACH0f,UAAW5G,EAAKlT,QAElB,IAAK,MAAM+Z,KAAgBF,EACzBD,EAAY9jB,KAAKvD,KAAK8lB,YAAY2B,GAAU9G,EAAM6G,IAEtD,CAEA,OAAOH,CACT,CAEOjC,cAAAA,CACLvd,GAEA,OAAO7H,KAAKqmB,SAASlB,KAAwBtd,EAC/C,CAEO6f,kBAAAA,CACLlB,EACA3e,GAEA,MAAMwf,EAA6C,GAEnD,IAAK,MAAM1G,KAAQ6F,EAAO,CACxB,MAAMc,EAAgBtnB,KAAKolB,eAAe,IACrCvd,EACH0f,UAAW5G,EAAKlT,QAElB,IAAK,MAAM+Z,KAAgBF,EACzBD,EAAY9jB,KAAKvD,KAAK8lB,YAAY2B,GAAU9G,EAAM6G,IAEtD,CAEA,OAAOH,CACT,CA8BOM,kBAAAA,CACL7E,EACAjb,GAIA,OAFc8f,GAAmB3nB,KAAK4lB,UAAW9C,EAAQjb,GAE5ClD,IAAI3E,KAAK8lB,YACxB,CAMO8B,eAAAA,GAEL,OADeA,GAAgB5nB,KAAK4lB,UAAW5lB,KAAK6H,QAEtD,CAEA,cAAaue,CACXzF,EACAxT,EACAtF,GAEA,MAAMggB,EAAiC,CACrC7B,MAAO,GACPvY,MAAO,CACLpI,MAAO,OAIX,IACE,IAAK,MAAMwhB,KAAQlG,EAAKqF,MAAO,CAC7B,MAAM8B,EAAiC,CACrCjB,OACApZ,MAAO,CAAEpI,MAAO,MAChB5E,MAAO,CAAE4E,MAAO,OAGlBwiB,EAAe7B,MAAMziB,KAAKukB,GAE1B,UACQ9nB,KAAK+nB,eAAe5a,EAAQ0Z,EACnC,CAAC,MAAO7kB,GAGP,MAFA8lB,EAAernB,MAAM4E,MAAQrD,EAEvBA,CACR,CAEA,UACQhC,KAAKgoB,UAAU7a,EAAQ0Z,EAAKpZ,MAAO5F,EAC1C,CAAC,MAAO7F,GAGP,MAFA8lB,EAAera,MAAMpI,MAAQrD,EAEvBA,CACR,CACF,CACD,CAAC,MAAOA,GAGP,MADAA,EAAImT,SJ5OH,SACLwL,EACAkH,EACAhgB,GAEA,MAAMgB,EAA2C,CAC/Cof,YAAaA,CAACC,EAAQC,IAAWA,EACjC3C,eAAgBd,GAChBe,eAAgBf,MACb7c,IAGCogB,YAAEA,EAAWzC,eAAEA,EAAcC,eAAEA,GAAmB5c,GAElD4E,MAAEA,GAAUkT,EAEZyH,EAAoB5C,EACxB/X,EACAkT,EAAKqF,MAAM3iB,OAASsd,EAAKqF,MAAMrF,EAAKqF,MAAM3iB,OAAS,GAAG5C,WAAQ2D,GAGhE,IAAIikB,EAAa,GACbC,GAAY,EAuChB,OAtCAD,GACE,YACAR,EAAe7B,MACZrhB,KAAI,CAAC4N,EAAGnP,EAAG4iB,KACV,MAAMuC,EAAc/C,EAClBjT,EAAEsU,KAAKpZ,MACPrK,EAAI,EAAI4iB,EAAM5iB,EAAI,GAAGyjB,KAAKpmB,WAAQ2D,GAE9BokB,EAAc/C,EAAelT,EAAEsU,KAAKpmB,OAiB1C,MAAO,CAfa,YAClB6nB,EACIL,EAAY,OAAQM,GACpBhW,EAAE9E,MAAMpI,OACJijB,GAAY,EAAOL,EAAY,YAAaM,IAC9CN,EAAY,cAAeM,KAEf,YAClBD,EACIL,EAAY,OAAQO,GACpBjW,EAAE9R,MAAM4E,OACJijB,GAAY,EAAOL,EAAY,MAAOO,IACxCP,EAAY,QAASO,MAGKzH,KAAK,SAExCvK,OACC,YACE8R,EACIL,EAAY,OAAQG,GACpBP,EAAepa,MAAMpI,MACnB4iB,EAAY,MAAOG,GACnBH,EAAY,QAASG,MAG9BrH,KAAK,QAEHsH,CACT,CI8KqBI,CAAqB9H,EAAMkH,EAAgB7nB,KAAK6H,SACzD7F,CACR,CAEA,OAAO6lB,CACT,CAEA,eAAaG,CACX7a,EACAM,EACA5F,GAEA,MAAMgB,EAAkB7I,KAAKymB,gBAAgB5e,GAEvC6gB,EAAgB1oB,KAAK2oB,kBACzBxb,EACAM,EACA5E,GAGF,IAAK,MAAM+f,KAAgBF,QACnBvb,EAAOyE,SAASgX,GAAcnb,GAExC,CAEQkb,iBAAAA,CACNxb,EACAM,EACA5E,GAEA,MAAM+I,EAASzE,EAAOyE,QAAU,GAC1B8W,EAAgB/lB,OAAOC,KAAKgP,GAAQC,QAAQmE,GACzCnN,EAAgB8c,aAAalY,EAAOuI,KAQ7C,OAJK0S,EAAcrlB,QAAU,MAAOuO,GAClC8W,EAAcnlB,KAAK,KAGdmlB,CACT,CAEQG,aAAAA,CACN1b,EACA0Z,GAEA,MAAMiC,EACJ3b,EAAO2V,SAAU+D,EAAKpmB,MAAcmB,MAEtC,OAAOknB,CACT,CAEA,oBAAaf,CACX5a,EACA0Z,GAEA,MAAMiC,EAAY9oB,KAAK6oB,cAAc1b,EAAQ0Z,SACtCiC,IAAiDjC,GAC1D,CAEQJ,eAAAA,CACN5e,GAEA,MAAO,IAAK7H,KAAK6lB,2BAA4B7lB,KAAK6H,WAAYA,EAChE,EAGF,SAASkhB,GACPlP,EACAC,GAEA,GAAID,IAAMC,EACR,OAAO,EAGT,QAAU1V,IAANyV,QAAyBzV,IAAN0V,EACrB,OAAO,EAGT,GAAiB,iBAAND,GAA+B,iBAANC,EAClC,OAAOD,IAAMC,EAGf,MAAMkP,EAAQrmB,OAAOC,KAAKiX,GACpBoP,EAAQtmB,OAAOC,KAAKkX,GAE1B,OACEkP,EAAM3lB,SAAW4lB,EAAM5lB,QACvB2lB,EAAMnmB,OAAOC,GAAQimB,GAAiBlP,EAAE/W,GAAMgX,EAAEhX,KAEpD,CAEA,SAASomB,GACP3iB,EAUA9F,EACA0oB,GAYA1D,eAAEA,IAIF,IACGhlB,GACA0oB,GACCJ,GAAiBI,EAAiBxoB,MAAO4F,EAAS5F,OAEpD,MAAO,GAGT,MAAMyoB,EAAkBD,EACpB,SAASzE,GAAgByE,EAAiBxoB,SAC1C,GAEJ,MAAO,QAAQ8kB,EAAehlB,KAAS2oB,GACzC,CChYO,SAASC,KACd,MAAMC,EVkCC7Z,EAAYyQ,IUjCnB,MAAO,CACLhf,KAAMooB,EACN9hB,OAAQC,QAAQC,IAChBhG,GAAI,GACJqF,UAAW8C,KAAKC,SAASC,SAAS,IAAIC,MAAM,GAC5CqC,MAAOA,OACP3D,OAAQ4gB,EAAW5gB,OACnB4D,UAAWA,OACXG,KAAMA,OACNO,eAAgBA,OAEpB,CC2BA,SAAS2E,GAAYD,GACnB,IAAKA,EAAUE,OACb,MAAO,GAOT,OAJiBjP,OAAOC,KAAK8O,EAAUE,QAAQjN,KAAK7B,GAC3C4O,EAAUE,OAAO9O,IAI5B,CAEO,SAASymB,GAAkBhjB,GAChC,MAAM5F,MAAEA,EAAK4D,QAAEA,GAAYgC,EAC3B,OAAOoe,KAAKC,UAAU,CACpBjkB,QACA4D,QAAS5B,OAAOC,KAAK2B,GAAW,CAAA,GAAIlB,OAASkB,OAAUH,GAE3D,CAEA,SAASqhB,GACPhlB,GAEA,OAAOkkB,KAAKC,UAAUnkB,EACxB,CAEO,SAAS+oB,GACd7jB,EACAkC,GAUA,MAAQib,OAAQ2G,KAAcC,GAAiB7hB,GAAW,CAAA,EA0B1D,MArBI,CACF2d,eAAgB+D,GAChB9D,kBACA3C,OAASrV,IACP,MAAMqV,EACiB,mBAAd2G,EAA2BA,EAAUhc,GAAUgc,GAAa,GACrE,OAAOE,EAAmClc,GAAO/G,SAAS9E,IACxD,MAAMgoB,EAAiB9G,EAAOjR,QAAQgY,GAAQA,EAAWjoB,OAASA,IAClE,OAAIgoB,EAAevmB,OACVumB,EAEF,CAAC,CAAEhoB,aAGd2lB,UAAW5hB,EAAQkI,mBACjBwb,KACAxhB,GAAS/F,UAER4nB,EAIP,CAEO,SAASI,KACd,MAAO,CACLtE,eAAiB/X,GAAUkX,KAAKC,UAAUnX,GAC1CgY,kBAEJ,CAoDO,SAASsE,GACdniB,EACAoiB,EAKA7iB,GAMA,MAAM8iB,EACJ9iB,IAlBJ,SAAwBS,GACtB,MAAO,qBAAsBA,CAC/B,CAiBKsiB,CAAetiB,GACX4hB,GACC5hB,EACAoiB,QAMF5lB,GAsBN,MAdI,CACFohB,eAPAwE,GAAkBxE,gBAClByE,GAAwBzE,iBACtB/X,GAAUkX,KAAKC,UAAUnX,IAM3BgY,kBACA3C,OAAQ,GACRqH,MAAOC,IACP7C,eAAWnjB,EACXimB,aAASjmB,EAGTkmB,SAAUN,GAAkBK,WACzBJ,KACAD,EAIP,CAEO,SAASvC,GAId8C,EACAC,GAIA,GAFyBA,EAASxE,MAAM,GAAGvY,QAElB8c,EAAS9c,MAChC,MAAM,IAAItC,MAAM,0BAGlB,MAAO,CACLsC,MAAO+c,EAAS/c,MAEhBuY,MAAOuE,EAASvE,MAAMxP,OAAOgU,EAASxE,MAAMhc,MAAM,IAClDygB,OAAQF,EAASE,OAASD,EAASC,OAEvC,CCzNO,SAAS7C,GAMdhgB,EACAC,GAEA,MAAMoH,WAAEA,GAAerH,GACjB6d,eACJA,EAAcD,eACdA,EACA1C,OAAQ2G,EAASU,MACjBA,EACA5C,UAAWmD,EAAeJ,SAC1BA,GACEP,GAAwBniB,EAAOC,GAC7BmI,EAAaqZ,KAYbsB,EAAuC,CAAA,EAE7C,IAAIC,EAAa,EACjB,MAAMC,EAID,CAAC,CAAE9b,UAbN2b,GACA9iB,EAAMiG,mBACJmC,EAEAnI,EAAQ/F,OASkBrB,WAAO2D,EAAW0mB,eAAW1mB,IACrD2mB,EAAW,IAAI7iB,IAErB,KAAO2iB,EAAMxnB,QAAQ,CACnB,MAAQ0L,UAAWtB,EAAKhN,MAAEA,EAAKqqB,UAAEA,GAAcD,EAAM7c,QAErD,GAAI4c,IAAeT,EACjB,MAAM,IAAIhf,MAAM,4BAGlB,MAAM6f,EAAkBxF,EACtB/X,EACAhN,EACAqqB,GAEF,GAAIH,EAAIK,GACN,SASF,GAPAD,EAASlgB,IAAImgB,EAAiBvd,GAE9Bkd,EAAIK,GAAmB,CACrBvd,QACAyL,YAAa,CAAC,GAGZoR,GAAYA,EAAS7c,GACvB,SAGF,MAAMqV,EACiB,mBAAd2G,EAA2BA,EAAUhc,GAASgc,EAEvD,IAAK,MAAMxM,KAAa6F,EAAQ,CAC9B,MAAMpJ,EAAezK,EAAWxB,EAAOwP,EAAWjN,GAElD2a,EAAIK,GAAiB9R,YACnBuM,EAAexI,IACb,CACFxc,MAAOwc,EACPxP,MAAOiM,GAETmR,EAAMtnB,KAAK,CACTwL,UAAW2K,EACXjZ,MAAOwc,EACP6N,UAAWrd,GAEf,CACF,CAEA,OAAOkd,CACT,CCrGO,SAASM,GAAyCtK,GACvD,IAAIqF,EAAoB,GAExB,GAAKrF,EAAKqF,MAAM3iB,OAOT,CACL,IAAK,IAAID,EAAI,EAAGA,EAAIud,EAAKqF,MAAM3iB,OAAQD,IAAK,CAC1C,MAAMyjB,EAAOlG,EAAKqF,MAAM5iB,GAExB4iB,EAAMziB,KAAK,CACTkK,MAAOoZ,EAAKpZ,MACZhN,MAAa,IAAN2C,EAAU,CAAExB,KAAM,eAAkB+e,EAAKqF,MAAM5iB,EAAI,GAAG3C,OAEjE,CACAulB,EAAMziB,KAAK,CACTkK,MAAOkT,EAAKlT,MACZhN,MAAOkgB,EAAKqF,MAAMrF,EAAKqF,MAAM3iB,OAAS,GAAG5C,OAE7C,MAnBEulB,EAAQ,CACN,CACEvY,MAAOkT,EAAKlT,MACZhN,MAAO,CAAEmB,KAAM,iBAiBrB,MAAO,IACF+e,EACHqF,QAEJ,CCHO,SAAS2B,GAMd/f,EACAkb,EACAjb,GAEA,MAAMgB,EAAkBkhB,GACtBniB,EACA,CACEkb,YACGjb,IAlBUlH,EAoBJiH,IAnBK,iBAAkBjH,EAoB9B6oB,GAA4B5hB,GAC5BkiB,MAtBR,IAAmBnpB,EA4BjB,MAAMqP,EAAaqZ,KAKb9B,EACJ1e,EAAgB0e,WAChB3f,EAAMiG,mBACJmC,EAEAnI,GAAS/F,QAGP0jB,eAAEA,EAAcC,eAAEA,GAAmB5c,EAErCqiB,EAAYtD,GAAgBhgB,EAAOiB,GAEnCkiB,EAAW,IAAI7iB,IACf8d,EAAkC,GAElCmF,EAAsB3F,EAC1B+B,OACAnjB,OACAA,GAEF2mB,EAASlgB,IAAIsgB,EAAqB5D,GAElC,IAAI6D,EAAcD,EACd1d,EAAQ8Z,EACZ,IAAK,MAAM9mB,KAASqiB,EAAQ,CAC1BkD,EAAMziB,KAAK,CACTkK,MAAOsd,EAAS/f,IAAIogB,GACpB3qB,UAGF,MAAM4qB,EAAc5F,EAAehlB,IAC3BgN,MAAOsB,EAAWtO,MAAO6qB,GAC/BJ,EAAUE,GAAalS,YAAYmS,GAErC,IAAKtc,EACH,MAAM,IAAI5D,MACR,2BAA2BigB,UAAoBC,KAGnD,MACME,EAAkB/F,EACtBzW,EACAtO,EAHgBsqB,EAAS/f,IAAIogB,IAM/BL,EAASlgB,IAAI0gB,EAAiBxc,GAE9Bqc,EAAcG,EACd9d,EAAQsB,CACV,CAIA,OAAIlG,EAAgBwhB,UAAYxhB,EAAgBwhB,QAAQ5c,GAC/C,GAGF,CACLwd,GAAU,CACRxd,QACAuY,QACAyE,OAAQzE,EAAM3iB,SAGpB,CC5GO,SAAS6hB,GACdtd,EACAC,GASA,MAAMgB,EAAkBkhB,GAAwBniB,EAAOC,GACjD2d,EAAiB3c,EAAgB2c,eAGjC+B,EACJ1e,EAAgB0e,WAChB3f,EAAMiG,mBAAmBwb,KAAwBxhB,GAAS/F,OACtDopB,EAAYtD,GAAgBhgB,EAAOiB,GAGnC2iB,EAAY,IAAItjB,IAQhB6iB,EAAW,IAAI7iB,IACfijB,EAAsB3F,EAAe+B,OAAWnjB,OAAWA,GACjE2mB,EAASlgB,IAAIsgB,EAAqB5D,GAElCiE,EAAU3gB,IAAIsgB,EAAqB,CACjCV,OAAQ,EACRhd,WAAOrJ,EACP3D,WAAO2D,IAET,MAAMqnB,EAAY,IAAIjlB,IAChBklB,EAAU,IAAIllB,IAEpBilB,EAAUngB,IAAI6f,GACd,IAAK,MAAMH,KAAmBS,EAAW,CACvC,MAAMX,EAAYC,EAAS/f,IAAIggB,IACzBP,OAAEA,GAAWe,EAAUxgB,IAAIggB,GACjC,IAAK,MAAMvqB,KAASkC,OAAOC,KACzBsoB,EAAUF,GAAiB9R,aACL,CACtB,MAAQzL,MAAOsB,EAAWtO,MAAOkrB,GAC/BT,EAAUF,GAAiB9R,YAAYzY,GACnCmrB,EAAsBpG,EAC1BzW,EACA4c,EACAb,GAGF,GADAC,EAASlgB,IAAI+gB,EAAqB7c,GAC7Byc,EAAUhZ,IAAIoZ,GAMZ,CACL,MAAQnB,OAAQoB,GAAeL,EAAUxgB,IAAI4gB,GACzCC,EAAapB,EAAS,GACxBe,EAAU3gB,IAAI+gB,EAAqB,CACjCnB,OAAQA,EAAS,EACjBhd,MAAOud,EACPvqB,MAAOkrB,GAGb,MAdEH,EAAU3gB,IAAI+gB,EAAqB,CACjCnB,OAAQA,EAAS,EACjBhd,MAAOud,EACPvqB,MAAOkrB,IAYND,EAAQlZ,IAAIoZ,IACfH,EAAUngB,IAAIsgB,EAElB,CACAF,EAAQpgB,IAAI0f,GACZS,EAAU1gB,OAAOigB,EACnB,CAEA,MAAMc,EAAqD,CAAA,EACrDtF,EAAkD,GA8BxD,OA5BAgF,EAAU5f,SACR,EAAG6e,SAAQhd,MAAO8Z,EAAW9mB,MAAOsrB,GAAaX,KAC/C,MAAM3d,EAAQsd,EAAS/f,IAAIogB,GACrBpF,EAASuB,EAEXuE,EAAavE,GAAWf,MAAM,GAAGR,MAAMxP,OAAO,CAC5C/I,MAAOsd,EAAS/f,IAAIuc,GACpB9mB,MAAOsrB,IAHT,GAMJvF,EAAMjjB,KAAK,CACTkK,QACAuY,QACAyE,WAEFqB,EAAaV,GAAe,CAC1B3d,QACA+Y,MAAO,CACL,CACE/Y,QACAuY,QACAyE,eAON5hB,EAAgBwhB,QACX7D,EACJ3U,QAAQ8O,GAAS9X,EAAgBwhB,QAAS1J,EAAKlT,SAC/C9I,IAAIsmB,IAGFzE,EAAM7hB,IAAIsmB,GACnB,CCrHO,SAAS7F,GACdxd,EACAC,GASA,MAAMgB,EAAkBkhB,GAAwBniB,EAAOC,GACjDmI,EAAaqZ,KACb9B,EACJ1e,EAAgB0e,WAChB3f,EAAMiG,mBAAmBmC,EAAYnI,GAAS/F,OAC1C0jB,EAAiB3c,EAAgB2c,eAGjC0F,EAAYtD,GAAgBhgB,EAAOiB,GACnCkiB,EAAW,IAAI7iB,IACf8jB,EAA2C,CAC/CC,SAAU,IAAIzlB,IACd0lB,MAAO,IAAI1lB,KAEPwf,EAA+B,GAC/BmG,EAGF,CAAA,EAEJ,SAASC,EACPC,EACAC,GAEA,MAAM/E,EAAYwD,EAAS/f,IAAIqhB,GAG/B,GAFAL,EAASC,SAAS3gB,IAAI+gB,GAElBA,IAAoBC,EAAe,CAChCH,EAAQG,KACXH,EAAQG,GAAiB,CACvB7e,MAAOsd,EAAS/f,IAAIshB,GACpB9F,MAAO,KAIX,MAAM+F,EAAcJ,EAAQG,GAEtBE,EAAmC,CACvC/e,MAAO8Z,EACPkD,OAAQzE,EAAM3iB,OACd2iB,MAAO,IAAIA,IAGbuG,EAAY/F,MAAMjjB,KAAKipB,EACzB,MACE,IAAK,MAAMC,KAAmB9pB,OAAOC,KACnCsoB,EAAUmB,GAAiBnT,aACL,CACtB,MAAQzL,MAAOsB,EAAWtO,MAAOisB,GAC/BxB,EAAUmB,GAAiBnT,YAAYuT,GAEzC,KAAMA,KAAmBvB,EAAUmB,GAAiBnT,aAClD,SAEF,MAAM4R,EAAYC,EAAS/f,IAAIqhB,GAEzBd,EAAkB/F,EAAezW,EAAW2d,EAAU5B,GAC5DC,EAASlgB,IAAI0gB,EAAiBxc,GAEzBid,EAASC,SAASzZ,IAAI+Y,KACzBS,EAASE,MAAM5gB,IAAImhB,GACnBzG,EAAMziB,KAAK,CACTkK,MAAOsd,EAAS/f,IAAIqhB,GACpB5rB,MAAOisB,IAETN,EAAKb,EAAiBe,GAE1B,CAGFtG,EAAM2G,MACNX,EAASC,SAASlhB,OAAOshB,EAC3B,CAEA,MAAMA,EAAkB7G,EAAe+B,OAAWnjB,GAClD2mB,EAASlgB,IAAIwhB,EAAiB9E,GAE9B,IAAK,MAAMgE,KAAmB5oB,OAAOC,KACnCsoB,GAEAkB,EAAKC,EAAiBd,GAGxB,MAAMqB,EAAcjqB,OAAOmK,OAAOqf,GAASzlB,SAASmmB,GAAMA,EAAErG,QAE5D,OAAI3d,EAAgBwhB,QACXuC,EACJ/a,QAAQ8O,GAAS9X,EAAgBwhB,QAAS1J,EAAKlT,SAC/C9I,IAAIsmB,IAGF2B,EAAYjoB,IAAIsmB,GACzB,sCJXO,SACL6B,GAMA,MAAMza,EAID,GAEL,IAAK,MAAM0a,KAAYpqB,OAAOmK,OAAOggB,GACnC,IAAK,MAAM7d,KAActM,OAAOmK,OAC7BigB,EAA+C7T,aAEhD7G,EAAQ9O,KAAK,CACXkK,MAAQsf,EAA+Ctf,MACvDhN,MAAOwO,EAAWxO,MAClBsO,UAAWE,EAAWxB,QAK5B,OAAO4E,CACT,0EHyRO,SACL1M,EACAkC,GD/X8BlC,KAC9B0f,GAAc1f,EAAQ4Q,OCsYtByW,CAAgBrnB,GAEhB,MAAM8f,EAAkB5d,GAAS4d,gBAAkBf,GAG7CgB,EACJ7d,GAAS6d,qBAAuBwD,IAC1BpG,OAAQ2G,KAAcC,GAAiB7hB,GAAW,CAAA,EAwC1D,OAtCkB,IAAIyd,GAIpB3f,EAAgB,CAChB6f,eAAgBA,CAAC/X,EAAOhN,EAAOqqB,IAEtB,GAAGvB,GAAkB9b,KAASiY,EACnCjY,EACAhN,EACAqqB,EACA,CACErF,qBAINE,aAAcA,CAAClY,EAAO3K,IACbA,EAAIsa,WAAW,KACjB3P,EAAchH,OAAOwmB,SAAStnB,EAAQQ,iBAAiBrD,IACvD2K,EAAckR,QAAQ7b,GAE7BggB,OAASrV,IACP,MAAMqV,EACiB,mBAAd2G,EAA2BA,EAAUhc,GAAUgc,GAAa,GAErE,OAAOE,EAAmClc,GAAO/G,SAC9CmN,GACKiP,EAAO1P,MAAMqI,GAAOA,EAAkB7Z,OAASiS,IAC1CiP,EAAOjR,QAAQ4J,GAAOA,EAAkB7Z,OAASiS,IAGnD,CAAC,CAAEjS,KAAMiS,UAInB6V,GAIP,yGE5bO,SAASvT,EACdzE,GAEA,MAAME,OAAEA,GAAWF,EASnB,OARc/O,OAAOC,KAAKgP,GAAQ6E,QAAO,CAACyW,EAAUlX,KAClD,MAAMjD,EAAiBnB,EAAOoE,GACxBlD,EAAkBqD,EAAcpD,GAGtC,OADAma,EAAS3pB,KAAKwP,KAAmBD,GAC1Boa,IACN,GAGL,0DA4EO,SAASC,EACdC,GAEA,MAAM1b,EACJ0b,aAAwBrK,GAAeqK,EAAa7W,KAAO6W,EAEvDlB,EAA6B,IAAIxa,EAAUwH,YAAYpM,UAC1D2U,OACA/a,SAAQ,CAAC4O,EAAG+X,KACK/X,EAAEzQ,OAASyQ,EAAEzQ,OAAS,CAAC6M,IAExB/M,KAAI,CAACE,EAAQyoB,KAC1B,MAAMC,EAA0B,CAC9B7rB,GAAI,GAAGgQ,EAAUhQ,MAAM2rB,KAAmBC,IAC1C3jB,OAAQ+H,EACR7M,OAAQA,EACRoK,WAAYqG,EACZkY,MAAO,CACLC,KAAMnY,EAAEzB,UACRvE,OAAQA,KAAO,CAAEme,KAAMnY,EAAEzB,aAE3BvE,OAAQA,KACN,MAAMke,MAAEA,GAAUD,EAElB,MAAO,CAAE5jB,OAAQ+H,EAAUhQ,GAAImD,OAAQA,EAAOnD,GAAI8rB,WAItD,OAAOD,OAIPG,EAAQ,CACZhsB,GAAIgQ,EAAUhQ,GACdgQ,UAAWA,EACXvI,SAAUwI,GAAYD,GAAW/M,IAAIwoB,GACrCjB,QACA5c,OAAQA,KACN,MAAM5N,GAAEA,EAAEyH,SAAEA,EAAU+iB,MAAOyB,GAAeD,EAC5C,MAAO,CAAEhsB,KAAIyH,WAAU+iB,MAAOyB,KAIlC,OAAOD,CACT"}