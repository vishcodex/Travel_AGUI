import { bm as ExecutionEngine, f as Step, bo as Emitter, bu as StepResult, bl as ExecutionGraph, bc as SerializedStepFlowEntry, ba as StepFlowEntry, bn as ExecuteFunction, aw as DefaultEngineType } from '../base-5ZyKaTRr.js';
export { bw as DynamicMapping, bz as ExtractSchemaFromStep, by as ExtractSchemaType, bx as PathsToStringProps, bk as Run, bb as SerializedStep, bq as StepFailure, bs as StepRunning, bp as StepSuccess, br as StepSuspended, bt as StepWaiting, bd as StepWithComponent, bv as StepsRecord, bB as StreamEvent, bA as VariableReference, bD as WatchEvent, e as Workflow, ax as WorkflowConfig, bj as WorkflowResult, bF as WorkflowRunState, bC as WorkflowRunStatus, bE as ZodPathType, bg as cloneStep, bi as cloneWorkflow, bf as createStep, bh as createWorkflow, be as mapVariable } from '../base-5ZyKaTRr.js';
import { Span } from '@opentelemetry/api';
import { RuntimeContext } from '../runtime-context/index.js';
import 'ai';
import '../base-ClrXcCRx.js';
import '../logger-Bpa2oLL4.js';
import '../error/index.js';
import 'stream';
import '@opentelemetry/sdk-trace-base';
import 'json-schema';
import 'zod';
import '../types-Bo1uigWx.js';
import 'sift';
import 'xstate';
import 'node:events';
import '../vector/index.js';
import '../vector/filter/index.js';
import '../tts/index.js';
import 'node:http';
import 'hono';
import 'stream/web';
import 'events';
import 'node:stream/web';
import './constants.js';
import 'ai/test';
import '../deployer/index.js';
import '../bundler/index.js';
import 'hono/cors';
import 'hono-openapi';

type ExecutionContext = {
    workflowId: string;
    runId: string;
    executionPath: number[];
    suspendedPaths: Record<string, number[]>;
    retryConfig: {
        attempts: number;
        delay: number;
    };
    executionSpan: Span;
};
/**
 * Default implementation of the ExecutionEngine using XState
 */
declare class DefaultExecutionEngine extends ExecutionEngine {
    /**
     * The runCounts map is used to keep track of the run count for each step.
     * The step id is used as the key and the run count is the value.
     */
    protected runCounts: Map<string, number>;
    /**
     * Get or generate the run count for a step.
     * If the step id is not in the map, it will be added and the run count will be 0.
     * If the step id is in the map, it will return the run count.
     *
     * @param stepId - The id of the step.
     * @returns The run count for the step.
     */
    protected getOrGenerateRunCount(stepId: Step['id']): number;
    protected fmtReturnValue<TOutput>(executionSpan: Span | undefined, emitter: Emitter, stepResults: Record<string, StepResult<any, any, any, any>>, lastOutput: StepResult<any, any, any, any>, error?: Error | string): Promise<TOutput>;
    /**
     * Executes a workflow run with the provided execution graph and input
     * @param graph The execution graph to execute
     * @param input The input data for the workflow
     * @returns A promise that resolves to the workflow output
     */
    execute<TInput, TOutput>(params: {
        workflowId: string;
        runId: string;
        graph: ExecutionGraph;
        serializedStepGraph: SerializedStepFlowEntry[];
        input?: TInput;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
        };
        emitter: Emitter;
        retryConfig?: {
            attempts?: number;
            delay?: number;
        };
        runtimeContext: RuntimeContext;
        abortController: AbortController;
    }): Promise<TOutput>;
    getStepOutput(stepResults: Record<string, any>, step?: StepFlowEntry): any;
    executeSleep({ runId, entry, prevOutput, stepResults, emitter, abortController, runtimeContext, }: {
        workflowId: string;
        runId: string;
        serializedStepGraph: SerializedStepFlowEntry[];
        entry: {
            type: 'sleep';
            id: string;
            duration?: number;
            fn?: ExecuteFunction<any, any, any, any, DefaultEngineType>;
        };
        prevStep: StepFlowEntry;
        prevOutput: any;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
        };
        executionContext: ExecutionContext;
        emitter: Emitter;
        abortController: AbortController;
        runtimeContext: RuntimeContext;
    }): Promise<void>;
    executeSleepUntil({ runId, entry, prevOutput, stepResults, emitter, abortController, runtimeContext, }: {
        workflowId: string;
        runId: string;
        serializedStepGraph: SerializedStepFlowEntry[];
        entry: {
            type: 'sleepUntil';
            id: string;
            date?: Date;
            fn?: ExecuteFunction<any, any, any, any, DefaultEngineType>;
        };
        prevStep: StepFlowEntry;
        prevOutput: any;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
        };
        executionContext: ExecutionContext;
        emitter: Emitter;
        abortController: AbortController;
        runtimeContext: RuntimeContext;
    }): Promise<void>;
    executeWaitForEvent({ event, emitter, timeout, }: {
        event: string;
        emitter: Emitter;
        timeout?: number;
    }): Promise<any>;
    executeStep({ workflowId, runId, step, stepResults, executionContext, resume, prevOutput, emitter, abortController, runtimeContext, skipEmits, }: {
        workflowId: string;
        runId: string;
        step: Step<string, any, any>;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        executionContext: ExecutionContext;
        resume?: {
            steps: string[];
            resumePayload: any;
        };
        prevOutput: any;
        emitter: Emitter;
        abortController: AbortController;
        runtimeContext: RuntimeContext;
        skipEmits?: boolean;
    }): Promise<StepResult<any, any, any, any>>;
    executeParallel({ workflowId, runId, entry, prevStep, serializedStepGraph, stepResults, resume, executionContext, emitter, abortController, runtimeContext, }: {
        workflowId: string;
        runId: string;
        entry: {
            type: 'parallel';
            steps: StepFlowEntry[];
        };
        serializedStepGraph: SerializedStepFlowEntry[];
        prevStep: StepFlowEntry;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
        };
        executionContext: ExecutionContext;
        emitter: Emitter;
        abortController: AbortController;
        runtimeContext: RuntimeContext;
    }): Promise<StepResult<any, any, any, any>>;
    executeConditional({ workflowId, runId, entry, prevOutput, prevStep, serializedStepGraph, stepResults, resume, executionContext, emitter, abortController, runtimeContext, }: {
        workflowId: string;
        runId: string;
        serializedStepGraph: SerializedStepFlowEntry[];
        entry: {
            type: 'conditional';
            steps: StepFlowEntry[];
            conditions: ExecuteFunction<any, any, any, any, DefaultEngineType>[];
        };
        prevStep: StepFlowEntry;
        prevOutput: any;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
        };
        executionContext: ExecutionContext;
        emitter: Emitter;
        abortController: AbortController;
        runtimeContext: RuntimeContext;
    }): Promise<StepResult<any, any, any, any>>;
    executeLoop({ workflowId, runId, entry, prevOutput, stepResults, resume, executionContext, emitter, abortController, runtimeContext, }: {
        workflowId: string;
        runId: string;
        entry: {
            type: 'loop';
            step: Step;
            condition: ExecuteFunction<any, any, any, any, DefaultEngineType>;
            loopType: 'dowhile' | 'dountil';
        };
        prevStep: StepFlowEntry;
        prevOutput: any;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
        };
        executionContext: ExecutionContext;
        emitter: Emitter;
        abortController: AbortController;
        runtimeContext: RuntimeContext;
    }): Promise<StepResult<any, any, any, any>>;
    executeForeach({ workflowId, runId, entry, prevOutput, stepResults, resume, executionContext, emitter, abortController, runtimeContext, }: {
        workflowId: string;
        runId: string;
        entry: {
            type: 'foreach';
            step: Step;
            opts: {
                concurrency: number;
            };
        };
        prevStep: StepFlowEntry;
        prevOutput: any;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
        };
        executionContext: ExecutionContext;
        emitter: Emitter;
        abortController: AbortController;
        runtimeContext: RuntimeContext;
    }): Promise<StepResult<any, any, any, any>>;
    protected persistStepUpdate({ workflowId, runId, stepResults, serializedStepGraph, executionContext, workflowStatus, result, error, runtimeContext, }: {
        workflowId: string;
        runId: string;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        serializedStepGraph: SerializedStepFlowEntry[];
        executionContext: ExecutionContext;
        workflowStatus: 'success' | 'failed' | 'suspended' | 'running' | 'waiting';
        result?: Record<string, any>;
        error?: string | Error;
        runtimeContext: RuntimeContext;
    }): Promise<void>;
    executeEntry({ workflowId, runId, entry, prevStep, serializedStepGraph, stepResults, resume, executionContext, emitter, abortController, runtimeContext, }: {
        workflowId: string;
        runId: string;
        entry: StepFlowEntry;
        prevStep: StepFlowEntry;
        serializedStepGraph: SerializedStepFlowEntry[];
        stepResults: Record<string, StepResult<any, any, any, any>>;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
        };
        executionContext: ExecutionContext;
        emitter: Emitter;
        abortController: AbortController;
        runtimeContext: RuntimeContext;
    }): Promise<{
        result: StepResult<any, any, any, any>;
        stepResults?: Record<string, StepResult<any, any, any, any>>;
        executionContext?: ExecutionContext;
    }>;
}

export { DefaultEngineType, DefaultExecutionEngine, Emitter, ExecuteFunction, type ExecutionContext, ExecutionEngine, ExecutionGraph, SerializedStepFlowEntry, Step, StepFlowEntry, StepResult };
